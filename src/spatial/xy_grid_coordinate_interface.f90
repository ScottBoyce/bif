! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
! MODULE XY_GRID_COORDINATE_INTERFACE
!  MODULE CREATES A DATA TYPE THAT HOLDES SPACIAL X, Y CARTESIAN COORDINATE INFORMATION. 
!  IT IS MODEL/GRID INDEPENDENT AND JUST REQUIRES AN ORIGIN X,Y POINT, NROW, NCOL, AND THEIR LENGTHS/WIDTHS
!  VERSION 1.2 [10/01/2014] ADDED SUBROUTINE XYCOORD2CELL THAT RETURNS THE CELL FOR A QUIERIED XY COORDINATE
!  VERSION 1.1 [6/01/2014] NEW OPTIONS FOR POINT OF ORIGIN, NEW DEFAULT POINT OF ORIGIN LOCATION [LOWER LEFT CORNER IS (0,0) TO COFORM WITH A NORMAL AXIS], 
!                          ADDED NEW ARRAYS THAT STORE THE MODEL CELL CORNERS X,Y LOCATION,
!                          REMOVED DEPENDENCE ON BAS MODULE GLOBAL
!  VERSION 1.0 [8/14/2013] ORIGINAL VERSION THAT CALCULATES THE X, Y CARTESIAN COORDINATE OF THE AREAL MODEL CELL CENTERS (ROW/COL)
!
MODULE XY_GRID_COORDINATE_INTERFACE
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE,IEEE_QUIET_NAN
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: XY_GRID_COODINATES
  !
  DOUBLE PRECISION,PARAMETER::EPS=1D-5                              !TOLERANCE FOR APPROXIMATING SINE/COSINE TO EXACT VALUE WHEN NEARBY 0, 90, 180, and 270 degrees
  DOUBLE PRECISION,PARAMETER::RAD= 1.74532925199432958D-2           !CONVERSION FACTOR FROM DEGREES TO RADIANS --  3.1415926535897932D0/180D0 = 0.0174532925199432958D0
  DOUBLE PRECISION,PARAMETER::MINBOT = 1D-30                        !USED TO DETERMINE SLOPE OF GRID. IF RUN IS LESS THAN THIS THE VALUE IS USED INSTEAD. PREVENTS DIV/0 ERROR
  DOUBLE PRECISION,PARAMETER::nMINBOT=-1D-30
  !
  TYPE XY_GRID_COODINATES
     INTEGER::NROW,NCOL                                             ! CURRENT MODEL GRID # OF ROWS AND COLUMNS (COPIES OF WHAT IS STORED IN GLOBAL MODULE, THIS PREVENTS ANY LINK TO GLOBAL)
     DOUBLE PRECISION:: ROTDEG, ROTRAD, MAXDEL                      ! ROTDEG=GRID ROTATION IN DEGREES, ROTRAD=IN RADIANS, MAXDEL=LARGEST CELL WIDTH OR LENGTH MAX([DELR(:),DELC(:)]); MAXDEL IS USED TO DETRMINE A MINIMUM RADIUS AROUND A SEARCH POINT FOR LOCATING A REQUESTED XY COORDINATE.
     DOUBLE PRECISION:: SINROT, COSROT, SIN90ROT, COS90ROT          !TRIG FUNCTIONS CALCULATED BASED ON ANGLE
     !DOUBLE PRECISION:: SIN_NROT,COS_NROT                           !
     DOUBLE PRECISION,DIMENSION(:,:)  ,ALLOCATABLE::XCENT,YCENT     ! XCENT(NCOL,NROW)=CELL CENTER X COORDINATE,      YCENT(NCOL,NROW)=CELL CENTER Y COORDINATE 
     DOUBLE PRECISION,DIMENSION(:,:)  ,ALLOCATABLE::XCORN,YCORN     ! XCORN(0:NCOL,0:NROW)= CELL CORNER X COORDINATE, YCORN(0:NCOL,0:NROW)=CELL CORNER X COORDINATE; WHERE XCORN(0,0) IS THE X-COORDINATE OF THE OUTERMOST CORNER [WITH RESPECT TO THE MODEL GRID] OF ROW 1 COL 1 AND XCORN(1,1) IS THE INNER MOST CORNER OF ROW 1 COL 1
     DOUBLE PRECISION,DIMENSION(:,:,:),ALLOCATABLE::GRDSLP          ! GRDSLP(4,NCOL,NROW)=SLOPE OF A LINE DERIVED BY TWO POINTS DEFINED BY XCORN AND YCOR (USED TO IMPROVE SPEED OF CALCULATING AN XY COORDINATE LOCATION WITHIN A MODEL GRID) THE MEANING BEHIND THE FIRST DIMENSION IS GRDSLP(I,:,:) WHERE THE VALUE OF I REPRESENTS A CORNER POINT AS FOLLOWS:   1  4   WHERE GRDSLP(1,:,:)=THE SLOPE BETWEEN PNT 1 AND 2, AND GRDSLP(2,:,:)=THE SLOPE BETWEEN PNT 2 AND 3
     LOGICAL,         DIMENSION(:,:,:),ALLOCATABLE::SIGN            ! SIGN=FOLLOWS SAME STRUCTURE AS GRDSLP AND INDICATES IF THE THIRD POINT IS TO THE LEFT OR RIGHT OF THE SLOPE (SAY FOR PNT 1 AND 2 MAKE A LINE THEN IT IS TRUE WHEN PNT 3 IS TO THE RIGHT AND FALSE WHEN TO THE LEFT OF THAT LINE)                                                              2  3
     !
     CONTAINS
     ! 
     PROCEDURE, PASS(XY):: INIT  => ALLOC_XYCOORD_FROM_INITIAL_POINT!CALL XY%BUILD(Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC) TO BUILD XY COORDINATE SYSTEM
     PROCEDURE, PASS(XY):: BUILD => BUILD_XYCOORD_FROM_INITIAL_POINT!CALL XY%BUILD(Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC) TO BUILD XY COORDINATE SYSTEM
     PROCEDURE, PASS(XY):: XY2RC => XYCOORD2CELL                    !CALL XY%XY2RC(X,Y,ROW,COL) RECIEVES X AND Y COORDINATE AND RETURNS THE ROW AND COL THAT THE POINT RESIDES IN
     PROCEDURE, PASS(XY):: LOCAL => XYCOORD2LOCALCELLCOORD
     PROCEDURE, PASS(XY):: CENTER_OFFSET => XYCOORD2CENTOFFSET
     PROCEDURE, PASS(XY):: PRINT => PRINT_XY_GRID                   !CALL XY%PRINT(IOUT) PRINTS XCENT,YCENT,XCORN,YCORN TO FILE WITH UNIT # IOUT. 
     PROCEDURE, PASS(XY):: DESTROY => DEALLOCATE_XY_GRID_COODINATES
     FINAL:: FINAL_DEALLOCATE_XY_GRID_COODINATES                    !DEALLOCATE(XY) PROVIDES CLEAN DEALLOCATION OF DATA TYPE XY_GRID_COODINATES
  END TYPE
  !
  INTERFACE XY_GRID_COODINATES
    MODULE PROCEDURE ALLOCATE_XY_DTYPE                              !CONSTRUCTOR FUNCTION THAT RETURNS AN ALLOCATED XY_GRID_COODINATES POINTER. INVOKED AS: XY => XY_GRID_COODINATES(NROW,NCOL)
  END INTERFACE
  !
  CONTAINS
  !
  !################################################################
  !
  FUNCTION ALLOCATE_XY_DTYPE(NROW,NCOL) RESULT(XY)
    TYPE(XY_GRID_COODINATES),POINTER:: XY
    INTEGER,INTENT(IN)::NROW,NCOL
    !
    XY=>NULL()
    ALLOCATE(XY)
    !
    XY%NROW=NROW
    XY%NCOL=NCOL
    !
    ALLOCATE( XY%XCENT(  NCOL,  NROW), XY%YCENT(  NCOL,  NROW) )
    ALLOCATE( XY%XCORN(0:NCOL,0:NROW), XY%YCORN(0:NCOL,0:NROW) )
    !
    ALLOCATE( XY%GRDSLP(4,NCOL,NROW) )
    ALLOCATE( XY%SIGN  (4,NCOL,NROW) )
    !
  END FUNCTION
  !
  SUBROUTINE ALLOC_XYCOORD_FROM_INITIAL_POINT(XY,NROW,NCOL,Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC)
    CLASS(XY_GRID_COODINATES),  INTENT(INOUT):: XY
    INTEGER,                    INTENT(IN)::NROW,NCOL
    DOUBLE PRECISION, OPTIONAL, INTENT(IN)::Xin,Yin,ROT                         !Xin=X POINT OF REFERENCE,Yin=Y POINT OF REFERENCE,ROT=ROTATION OF MODEL GRID IN DEGREES
    LOGICAL,          OPTIONAL, INTENT(IN)::LLCOODRINATE,CORNERCOORD            !LLCOODRINATE=TRUE MEANSPOINT OF REFFERENCE IS AT ROW 1 COL NCOL, FALSE MEANS THAT ITS AT ROW 1 COL 1; CORNERCOORD=TRUE MEAND REFERENCE IS ON THE OUTER MOST CORNER, FALSE MEANS THAT IT IS A CELL CENTER
    REAL,DIMENSION(:),OPTIONAL, INTENT(IN)::DELR                                !DEFINED BY BAS/GLOBAL AND REPRESENTS THE MODEL SPACING. THIS CAN NOT BE CALLED FROM USE "GLOBAL, ONLY" BECAUSE IT WOULD CREATE A CIRCULAR DEPENDENCY.
    REAL,DIMENSION(:),OPTIONAL, INTENT(IN)::DELC    
    !
    XY%NROW=NROW
    XY%NCOL=NCOL
    !
    ALLOCATE( XY%XCENT(  NCOL,  NROW), XY%YCENT(  NCOL,  NROW) )
    ALLOCATE( XY%XCORN(0:NCOL,0:NROW), XY%YCORN(0:NCOL,0:NROW) )
    !
    ALLOCATE( XY%GRDSLP(4,NCOL,NROW) )
    ALLOCATE( XY%SIGN  (4,NCOL,NROW) )
    !
    IF(PRESENT(Xin)) THEN
        CALL BUILD_XYCOORD_FROM_INITIAL_POINT(XY,Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC)
    END IF
    !
  END SUBROUTINE
  !
  !################################################################
  !
  SUBROUTINE DEALLOCATE_XY_GRID_COODINATES(XY)
    CLASS(XY_GRID_COODINATES),INTENT(INOUT)::XY
    !
    IF(ALLOCATED(XY%XCENT))  DEALLOCATE( XY%XCENT, XY%YCENT )
    IF(ALLOCATED(XY%XCORN))  DEALLOCATE( XY%XCORN, XY%YCORN )
    !
    IF(ALLOCATED(XY%GRDSLP)) DEALLOCATE( XY%GRDSLP )
    IF(ALLOCATED(XY%SIGN)  ) DEALLOCATE( XY%SIGN   )
    !
    END SUBROUTINE
    !
    SUBROUTINE FINAL_DEALLOCATE_XY_GRID_COODINATES(XY)
    TYPE(XY_GRID_COODINATES),INTENT(INOUT)::XY
    !
    IF(ALLOCATED(XY%XCENT))  DEALLOCATE( XY%XCENT, XY%YCENT )
    IF(ALLOCATED(XY%XCORN))  DEALLOCATE( XY%XCORN, XY%YCORN )
    !
    IF(ALLOCATED(XY%GRDSLP)) DEALLOCATE( XY%GRDSLP )
    IF(ALLOCATED(XY%SIGN)  ) DEALLOCATE( XY%SIGN   )
    !
  END SUBROUTINE
  !
  !################################################################
  !      
  SUBROUTINE BUILD_XYCOORD_FROM_INITIAL_POINT(XY,Xin,Yin,ROT,LLCOODRINATE,CORNERCOORD,DELR,DELC)
    !SUBROUTINE TO PROCESS CELL CENTER COORDINATE FOR ENTIRE MODEL
    !NEW FEATURES INCLUDE PROCESSING CELL CORNERS AND CONVERSION OF MAIN ROUTINES TO TYPE-BOUND PROCEDURES FOR INCLUSION IN NEW DATA TYPE XY_GRID_COODINATES
    !CORDINATE SYSTEM IS CARTESIAN WITH A GRID ROTATION THAT STARTS AT 0 DEGREES ALONG THE POSITIVE X-AXIS AND INCREASES COUNTER CLOCWISE (POLAR ANGLE)
    !DEVELOPED BY SCOTT E BOYCE 8/14/2013
    CLASS(XY_GRID_COODINATES):: XY
    DOUBLE PRECISION, INTENT(IN)::Xin,Yin,ROT                         !Xin=X POINT OF REFERENCE,Yin=Y POINT OF REFERENCE,ROT=ROTATION OF MODEL GRID IN DEGREES
    LOGICAL,          INTENT(IN)::LLCOODRINATE,CORNERCOORD            !LLCOODRINATE=TRUE MEANSPOINT OF REFFERENCE IS AT ROW 1 COL NCOL, FALSE MEANS THAT ITS AT ROW 1 COL 1; CORNERCOORD=TRUE MEAND REFERENCE IS ON THE OUTER MOST CORNER, FALSE MEANS THAT IT IS A CELL CENTER
    REAL,DIMENSION(:),INTENT(IN)::DELR                                !DEFINED BY BAS/GLOBAL AND REPRESENTS THE MODEL SPACING. THIS CAN NOT BE CALLED FROM USE "GLOBAL, ONLY" BECAUSE IT WOULD CREATE A CIRCULAR DEPENDENCY.
    REAL,DIMENSION(:),INTENT(IN)::DELC                                !DEFINED BY BAS/GLOBAL AND REPRESENTS THE MODEL SPACING. THIS CAN NOT BE CALLED FROM USE "GLOBAL, ONLY" BECAUSE IT WOULD CREATE A CIRCULAR DEPENDENCY.
    CONTIGUOUS:: DELR, DELC
    DOUBLE PRECISION:: DISTR,DISTC,SINROT,COSROT,SIN90ROT,COS90ROT
    DOUBLE PRECISION:: X,Y,XCOL1,YCOL1                                !X,Y ARE COORD OF ROW 1, COL 1 CELL and XCOL1, YCOL1 HOLDS CELL CENTER COL 1 WHEN PROCESSING A ROW
    !DOUBLE PRECISION,PARAMETER::ANG= 57.295779513082321D0          !CONVERSION FACTOR FROM RADIANS TO DEGREES --  180D0/3.1415926535897932D0
    !DOUBLE PRECISION,DIMENSION(:,:),POINTER,CONTIGUOUS:: XCORD,YCORD,XPCORD,YPCORD
    DOUBLE PRECISION,DIMENSION(4)::XP,YP,SLOPE,RISE,RUNN,SGN
    DOUBLE PRECISION,DIMENSION(XY%NROW)::DC
    DOUBLE PRECISION,DIMENSION(XY%NCOL)::DR
    INTEGER::I,J,K,NROW,NCOL
    !
    NROW=XY%NROW
    NCOL=XY%NCOL
    DR=DBLE(DELR)                                                     !SETTING LOCAL DP NAMES TO GLOBAL DELR AND DELC WHICH ARE RENAMED AS DR AND DC, RESPECTIVELY
    DC=DBLE(DELC)
    !
    XY%ROTDEG=ROT
    XY%ROTRAD=ROT*RAD
    !MX    =>XY%MAXDEL
    !XCORD =>XY%XCENT                                              !SET UP LOCAL POINTERS
    !YCORD =>XY%YCENT
    !XPCORD=>XY%XCORN
    !YPCORD=>XY%YCORN
    !
    IF(ABS(ROT)<EPS .OR. ABS(360D0-ROT)<EPS)THEN                      !TO PREVENT NUMERICAL ERRORS SET OBVIOUS SINE/COSINE VALUES
      SINROT  =0D0
      COSROT  =1D0
      SIN90ROT=-1D0
      COS90ROT=0D0
    ELSEIF(ABS(90D0 -ROT)<EPS)THEN
      SINROT  =1D0
      COSROT  =0D0
      SIN90ROT=0D0
      COS90ROT=1D0
    ELSEIF(ABS(180D0-ROT)<EPS)THEN
      SINROT  =0D0
      COSROT  =-1D0
      SIN90ROT=1D0
      COS90ROT=0D0
    ELSEIF(ABS(270D0-ROT)<EPS)THEN
      SINROT  =-1D0
      COSROT  =0D0
      SIN90ROT=0D0
      COS90ROT=-1D0
    ELSE
      SINROT  =SIN(ROT*RAD)
      COSROT  =COS(ROT*RAD)
      SIN90ROT=SIN((ROT-90D0)*RAD)
      COS90ROT=COS((ROT-90D0)*RAD)
    END IF
    !
    XY%SINROT   = SINROT  
    XY%COSROT   = COSROT  
    XY%SIN90ROT = SIN90ROT
    XY%COS90ROT = COS90ROT
    !XY%SIN_NROT = SIN_NROT
    !XY%COS_NROT = COS_NROT
    !
    IF      (LLCOODRINATE       .AND.       CORNERCOORD) THEN
       !
       DISTC=0.5D0*DC(NROW)                                           !DISTANCE TO CENTER OF ROW NROW AND SIDE OF COL 1
       X=Xin - (DISTC*COS90ROT)                                       !X COORDINATE OF ROW NROW, COL 1
       Y=Yin - (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW NROW, COL 1
       !
       DISTR=0.5D0*DR(1)                                              !DISTANCE TO CENTER OF ROW NROW, COL 1
       X=X + (DISTR*COSROT)                                           !X COORDINATE OF ROW NROW, COL 1
       Y=Y + (DISTR*SINROT)                                           !Y COORDINATE OF ROW NROW, COL 1
       !
       DISTC=0.5D0*(DC(1)+DC(NROW)) + SUM(DC(2:NROW-1))               !DISTANCE TO ROW 1, COL 1
       X=X - (DISTC*COS90ROT)                                         !X COORDINATE OF ROW 1, COL 1
       Y=Y - (DISTC*SIN90ROT)                                         !Y COORDINATE OF ROW 1, COL 1
       !
    ELSE IF (LLCOODRINATE       .AND. .NOT. CORNERCOORD) THEN
       ! 
       DISTC=0.5D0*(DC(1)+DC(NROW)) + SUM(DC(2:NROW-1))               !DISTANCE TO ROW 1, COL 1
       X=Xin - (DISTC*COS90ROT)                                       !X COORDINATE OF ROW 1, COL 1
       Y=Yin - (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW 1, COL 1
       !
    ELSE IF (.NOT. LLCOODRINATE .AND.       CORNERCOORD) THEN
       !
       DISTC=0.5D0*DC(NROW)                                           !DISTANCE TO CENTER OF ROW NROW AND SIDE OF COL 1
       X=Xin + (DISTC*COS90ROT)                                       !X COORDINATE OF ROW NROW, COL 1
       Y=Yin + (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW NROW, COL 1
       !
       DISTR=0.5D0*DR(1)                                              !DISTANCE TO CENTER OF ROW NROW, COL 1
       X=X + (DISTR*COSROT)                                           !X COORDINATE OF ROW NROW, COL 1
       Y=Y + (DISTR*SINROT)                                           !Y COORDINATE OF ROW NROW, COL 1
       !
    ELSE
      X=Xin
      Y=Yin
    END IF
    !IF(LLCOODRINATE) THEN                                             !USING LOWER LEFT CORNER AS CORNER, SO CALCULATE ROW 1, COL 1 COORD
    !   DISTC=0.5D0*(DC(1)+DC(NROW)) + SUM(DC(2:NROW-1))               !DISTANCE TO ROW 1, COL 1
    !   X=Xin - (DISTC*COS90ROT)                                       !X COORDINATE OF ROW 1, COL 1
    !   Y=Yin - (DISTC*SIN90ROT)                                       !Y COORDINATE OF ROW 1, COL 1
    !ELSE
    !  X=Xin
    !  Y=Yin
    !END IF
    !
    XCOL1=X                                                           !STARTING X COORDINATE IS ROW 1, COL 1
    YCOL1=Y                                                           !STARTING Y COORDINATE IS ROW 1, COL 1   
    !
    DISTC=0D0
    DO I=1,NROW
      IF(I>1) THEN                                                    !MOVE DOWN 1 ROW AND PROCESS ALL COLUMNS
        DISTC=DISTC + 0.5D0*(DC(I-1)+DC(I))                           !DISTANCE TO NEXT ROW
        XCOL1=X + (DISTC*COS90ROT)                                    !NEXT ROW'S COLUMN 1's X COORDINATE
        YCOL1=Y + (DISTC*SIN90ROT)                                    !NEXT ROW'S COLUMN 1's Y COORDINATE
      END IF
      DISTR=0D0
      XY%XCENT (1,I)=XCOL1
      XY%YCENT (1,I)=YCOL1
      DO J=2,NCOL
        DISTR=DISTR + 0.5D0*(DR(J-1)+DR(J))
        XY%XCENT (J,I)=XCOL1 + (DISTR*COSROT)
        XY%YCENT (J,I)=YCOL1 + (DISTR*SINROT)
      END DO
    END DO
    !
    !BUILD CORNER POINT ARRAYS
    DO I=1,NROW                                                       !SOLVES FOR UPPER LEFT CORNER FOR EVERY CELL
       DISTC=0.5D0*DC(I)
    DO J=1,NCOL
       DISTR=0.5D0*DR(J)
       XY%XCORN(J-1,I-1)=XY%XCENT(J,I)-(DISTC*COS90ROT)-(DISTR*COSROT)
       XY%YCORN(J-1,I-1)=XY%YCENT(J,I)-(DISTC*SIN90ROT)-(DISTR*SINROT)
      END DO    
    END DO
    !
    I=NROW                                                            !SOLVE FOR THE BOTTOM LEFT CORNER OF THE LAST ROW
    DISTC=0.5D0*DC(I)
    DO J=1,NCOL
       DISTR=0.5D0*DR(J)
       XY%XCORN(J-1,I)=XY%XCENT(J,I)+(DISTC*COS90ROT) - (DISTR*COSROT)
       XY%YCORN(J-1,I)=XY%YCENT(J,I)+(DISTC*SIN90ROT) - (DISTR*SINROT)
    END DO
    !
    J=NCOL                                                            !SOLVE FOR THE UPPER RIGHT OF THE LAST COLUMN
    DISTR=0.5D0*DR(J)
    DO I=1,NROW
       DISTC=0.5D0*DC(I)
       XY%XCORN(J,I-1)=XY%XCENT(J,I)-(DISTC*COS90ROT) + (DISTR*COSROT)
       XY%YCORN(J,I-1)=XY%YCENT(J,I)-(DISTC*SIN90ROT) + (DISTR*SINROT)
    END DO
    !
    I=NROW                                                            !SOLVE FOR BOTTOM RIGHT CORNER OF MODEL
    J=NCOL
    XY%XCORN(J,I)=XY%XCENT(J,I) + (DISTC*COS90ROT) + (DISTR*COSROT)   !NOTE DISTR WAS SOLVED BEFORE AT I=NROW
    XY%YCORN(J,I)=XY%YCENT(J,I) + (DISTC*SIN90ROT) + (DISTR*SINROT)       
    !
    XY%MAXDEL=MAX(MAXVAL(DR),MAXVAL(DC))
    !
    !SET UP LOGICAL ARRAY REQUIRED TO DETERMINE A POINT LOCATION IN THE GRID
    DO I=1, NROW
    DO J=1, NCOL
        XP(1) = XY%XCORN(J-1,I-1)
        XP(2) = XY%XCORN(J-1,I  )
        XP(3) = XY%XCORN(J  ,I  )
        XP(4) = XY%XCORN(J  ,I-1)
        YP(1) = XY%YCORN(J-1,I-1)
        YP(2) = XY%YCORN(J-1,I  )
        YP(3) = XY%YCORN(J  ,I  )
        YP(4) = XY%YCORN(J  ,I-1)
        !
        RISE(1)=(YP(2)-YP(1))
        RISE(2)=(YP(3)-YP(2))
        RISE(3)=(YP(4)-YP(3))
        RISE(4)=(YP(1)-YP(4))
        !
        RUNN(1)=(XP(2)-XP(1))
        RUNN(2)=(XP(3)-XP(2))
        RUNN(3)=(XP(4)-XP(3))
        RUNN(4)=(XP(1)-XP(4))
        !
        DO CONCURRENT(K=1:4)
            IF(nMINBOT < RISE(K) .AND. RISE(K) < MINBOT) THEN
                SLOPE(K) = 0D0
            ELSEIF(nMINBOT < RUNN(K) .AND. RUNN(K) < MINBOT) THEN
                SLOPE(K) = 1D100 !ASSUM INF
            ELSE
                SLOPE(K) = RISE(K)/RUNN(K)
            END IF
        END DO
        !
        XY%GRDSLP(:,J,I)=SLOPE
        !
        SGN(1) = YP(3) - YP(1) - SLOPE(1)*( XP(3)-XP(1) )
        SGN(2) = YP(4) - YP(2) - SLOPE(2)*( XP(4)-XP(2) )
        SGN(3) = YP(1) - YP(3) - SLOPE(3)*( XP(1)-XP(3) )
        SGN(4) = YP(2) - YP(4) - SLOPE(4)*( XP(2)-XP(4) )
        !
        XY%SIGN(:,J,I) = (SGN.GE.0D0)
        !
    END DO
    END DO
    !
    !NULLIFY( XCORD, YCORD, XPCORD, YPCORD, MX )
    !DEALLOCATE(DR,DC)
    !
  END SUBROUTINE
  !
  !################################################################
  !
  ELEMENTAL SUBROUTINE XYCOORD2CELL(XY,X,Y,ROW,COL)                 !RETURN THE ROW AND COL OF THE COORDINATE SPECIFIED IN X AND Y
    CLASS (XY_GRID_COODINATES),INTENT(IN):: XY
    DOUBLE PRECISION,          INTENT(IN )::X,Y                        ! X AND Y COORDINATE TO LOOK UP AND RETURN ROW AND COL
    INTEGER,                   INTENT(OUT):: ROW,COL
    !
    DOUBLE PRECISION::XX,YY, DELX, DELY
    DOUBLE PRECISION,DIMENSION(4)::XP,YP,SLOPE
    LOGICAL,DIMENSION(4):: SIGN
    INTEGER::NROW,NCOL
    !
    NROW=XY%NROW
    NCOL=XY%NCOL
    !
    ROW=0
    COL=0
    !
    CALL XY_FIND_CELL(XY,X,Y,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    !
    IF(ROW==0) THEN
        IF(ABS(X) > 1D-20) THEN
            DELX = X*1D-10
        ELSE
            DELX = 1D-20
        END IF
        !
        XX = X + DELX
        YY = Y
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        IF(ABS(Y) > 1D-20) THEN
            DELY = Y*1D-10
        ELSE
            DELY = 1D-20
        END IF
        !
        XX = X
        YY = Y + DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X - DELX
        YY = Y
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X
        YY = Y - DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X + DELX
        YY = Y + DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
    IF(ROW==0) THEN
        XX = X - DELX
        YY = Y - DELY
        CALL XY_FIND_CELL(XY,XX,YY,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE XY_FIND_CELL(XY,X,Y,ROW,COL,NROW,NCOL,XP,YP,SLOPE,SIGN)
    CLASS (XY_GRID_COODINATES),INTENT(IN  ):: XY
    DOUBLE PRECISION,         INTENT(IN   ):: X,Y                        ! X AND Y COORDINATE TO LOOK UP AND RETURN ROW AND COL
    INTEGER,                  INTENT(INOUT):: ROW,COL
    INTEGER,                  INTENT(IN   ):: NROW,NCOL
    !
    DOUBLE PRECISION,DIMENSION(4),INTENT(INOUT)::XP,YP,SLOPE
    LOGICAL,         DIMENSION(4),INTENT(INOUT):: SIGN
    DOUBLE PRECISION::XC,YC,XMIN,XMAX,YMIN,YMAX,MXDEL
    INTEGER:: I, J
    !
    MXDEL = XY%MAXDEL * 5D0
    XMIN=X - MXDEL                                 !DROP ANY POINTS THAT ARE FARTHER THAN 5 TIMES THE MAX DISTANCE
    XMAX=X + MXDEL
    YMIN=Y - MXDEL
    YMAX=Y + MXDEL
    !
    LP:DO I=1, NROW
       DO J=1, NCOL
        XC=XY%XCENT(J,I)
        YC=XY%YCENT(J,I)
        IF(XC<XMIN.OR.XC>XMAX.OR.YC<YMIN.OR.YC>YMAX) CYCLE
        XP(1) = XY%XCORN(J-1,I-1)
        XP(2) = XY%XCORN(J-1,I  )
        XP(3) = XY%XCORN(J  ,I  )
        XP(4) = XY%XCORN(J  ,I-1)
        YP(1) = XY%YCORN(J-1,I-1)
        YP(2) = XY%YCORN(J-1,I  )
        YP(3) = XY%YCORN(J  ,I  )
        YP(4) = XY%YCORN(J  ,I-1)
        !
        SLOPE = XY%GRDSLP(:,J,I)
        !
        SIGN = ( Y-YP-SLOPE*(X-XP) ) >= 0D0
    
        !SIGN(1) = Y - YP(1) - SLOPE*( X - XP(1) )
        !SIGN(2) = Y - YP(2) - SLOPE*( X - XP(2) )
        !SIGN(3) = Y - YP(3) - SLOPE*( X - XP(3) )
        !SIGN(4) = Y - YP(4) - SLOPE*( X - XP(4) )
        !
        IF (ALL(  SIGN .EQV. XY%SIGN(:,J,I) )) THEN
            ROW=I
            COL=J
            EXIT LP
        END IF
       END DO
       END DO LP
  END SUBROUTINE
  !
  !################################################################
  !
  ELEMENTAL PURE SUBROUTINE XYCOORD2LOCALCELLCOORD(XY,X,Y,XL,YL,ROW,COL)   !RETURN THE ROW AND COL OF THE COORDINATE SPECIFIED IN X AND Y
    CLASS (XY_GRID_COODINATES),INTENT(IN):: XY
    DOUBLE PRECISION,          INTENT(IN ):: X, Y                     ! X AND Y COORDINATE TO LOOK UP AND RETURN LOCAL COORDINATE FOR CELL THAT CONTAINS X, Y
    DOUBLE PRECISION,          INTENT(OUT):: XL, YL
    INTEGER, OPTIONAL,         INTENT(IN ):: ROW,COL
    !
    DOUBLE PRECISION::XC,YC
    INTEGER:: I,J
    !
    IF(PRESENT(ROW)) THEN
         I = ROW
         J = COL
    ELSE
        CALL XYCOORD2CELL(XY,X,Y,I,J)
    END IF
    !
    IF (I==0 .OR. J==0) THEN
        XL = IEEE_VALUE(XL, IEEE_QUIET_NAN)
        YL = XL
    ELSE
       !
       XC = X - XY%XCENT(J,I)
       YC = Y - XY%YCENT(J,I)
       !
       !XL = XC * XY%COS_NROT  -   YC * XY%SIN_NROT             !NORMAL ROTATION IS FOR COUNTER-CLOCKWISE, BUT WANT TO ROTATE BACKWARDS, SO MOVE IN COCKWISE DIRECTION
       !                                                        !INSTEAD OF USING NORMAL ROTATION MATRIX, USE NEGATIVE VERSION
       !YL = XC * XY%SIN_NROT  +   YC * XY%COS_NROT
       !   
       XL = XC * XY%COSROT  +  YC * XY%SINROT                   !R(-THETA) from https://en.wikipedia.org/wiki/Rotation_matrix#In_two_dimensions
       !
       YL = YC * XY%COSROT  -  XC * XY%SINROT
       !
    END IF
    !
  END SUBROUTINE
  !
  !################################################################
  !
  ELEMENTAL PURE SUBROUTINE XYCOORD2CENTOFFSET(XY,X,Y,XL,YL,ROW,COL)   !RETURN THE ROW AND COL OF THE COORDINATE SPECIFIED IN X AND Y
    CLASS (XY_GRID_COODINATES),INTENT(IN):: XY
    DOUBLE PRECISION,          INTENT(IN ):: X, Y                     ! X AND Y COORDINATE TO LOOK UP AND RETURN LOCAL COORDINATE FOR CELL THAT CONTAINS X, Y
    DOUBLE PRECISION,          INTENT(OUT):: XL, YL
    INTEGER, OPTIONAL,         INTENT(IN ):: ROW,COL
    !
    DOUBLE PRECISION::XC,YC,DX,DY
    INTEGER:: I,J
    !
    IF(PRESENT(ROW)) THEN
         I = ROW
         J = COL
    ELSE
        CALL XYCOORD2CELL(XY,X,Y,I,J)
    END IF
    !
    IF (I==0 .OR. J==0) THEN
        XL = IEEE_VALUE(XL, IEEE_QUIET_NAN)
        YL = XL
    ELSE
       !
       DX = ABS(XY%XCORN(J-1,I) - XY%XCORN(J,I))
       DY = ABS(XY%YCORN(J,I-1) - XY%YCORN(J,I))
       !
       XC = X - XY%XCENT(J,I)
       YC = Y - XY%YCENT(J,I)
       !
       XL = XC * XY%COSROT  +  YC * XY%SINROT                   !R(-THETA) from https://en.wikipedia.org/wiki/Rotation_matrix#In_two_dimensions
       YL = YC * XY%COSROT  -  XC * XY%SINROT
       !
       XL =        XL  / DX
       YL = (-1D0* YL) / DY
       !
    END IF
    !
  END SUBROUTINE
  !
  !################################################################
  !
  SUBROUTINE PRINT_XY_GRID(XY,IOUT)
          !PRINT OUR GRID IF REQUESTED
    CLASS (XY_GRID_COODINATES):: XY
    INTEGER,INTENT(IN)::IOUT
    INTEGER::I
    CHARACTER(8):: NUM
    
    WRITE(NUM,'(F8.4)') XY%ROTDEG
    WRITE(IOUT,'(/,/ 4A,/,3A)')'X, Y CELL CENTER COORDINATES ',       &
         'WITH ROTATION = ',TRIM(ADJUSTL(NUM)), '°',                  &
         'CORDINATE SYSTEM IS CARTESIAN WITH A GRID ROTATION THAT ',  &
         'STARTS AT 0° ALONG THE POSITIVE X-AXIS AND INCREASES ',     &
         'COUNTER CLOCKWISE (POLAR ANGLE)'
    WRITE(IOUT,'(/A)')'X-COORDINATES'
    DO I=1,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%XCENT(:,I)
    END DO
    !
    WRITE(IOUT,'(/A)')'Y-COORDINATES'
    DO I=1,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%YCENT(:,I)
    END DO
    !
    !
    WRITE(IOUT,'(/,/ 2A)')'X, Y COORDINATES OF THE MODEL CELL ','CORNERS.'
    WRITE(IOUT,'(/A)')'X-COORDINATES'
    DO I=0,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%XCORN(:,I)
    END DO
    !
    WRITE(IOUT,'(/A)')'Y-COORDINATES'
    DO I=0,XY%NROW
      WRITE(IOUT,'(*(G20.10))') XY%YCORN(:,I)
    END DO
    !
  END SUBROUTINE
  !
  !################################################################
  !
END MODULE XY_GRID_COORDINATE_INTERFACE
!