!
! CODE DEVELOPED BY SCOTT E BOYCE
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LISTING:
!
!   TRANSIENT_FILE_READER_INSTRUCTION
!
MODULE TRANSIENT_FILE_READER_INSTRUCTION
  USE CONSTANTS
  USE FILE_IO_INTERFACE,                 ONLY: READ_TO_DATA, COMMENT_INDEX
  USE PARSE_WORD_INTERFACE,              ONLY: PARSE_WORD
  USE STRINGS,                           ONLY: GET_WORD
  USE ERROR_INTERFACE,                   ONLY: STOP_ERROR
  USE GENERIC_INPUT_FILE_INSTRUCTION,    ONLY: GENERIC_INPUT_FILE
  USE ULOAD_AND_SFAC_INTERFACE,          ONLY: SFAC_DATA, ULOAD
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE, INTRINSIC:: ISO_FORTRAN_ENV,      ONLY: REAL32, REAL64, REAL128
  IMPLICIT NONE(TYPE, EXTERNAL)
  PRIVATE
  PUBLIC:: TRANSIENT_FILE_READER
  !
  INTEGER, PARAMETER:: MAX_LINE_LEN=768  !THIS SETS THE LENGTH OF SOME HARD WIRED STRINGS => CHARACTER(MAX_LINE_LEN)::LN
  !
  TYPE, EXTENDS(GENERIC_INPUT_FILE):: TRANSIENT_FILE_READER
    !TYPE(SFAC_DATA):: SFAC, SFAC_OLD
    CHARACTER(:), ALLOCATABLE:: LN
    CHARACTER(:), ALLOCATABLE:: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD, BLOCK_END_KEY
    INTEGER:: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL:: NOID, READ_BY_DIM2
    LOGICAL:: LOAD_NEXT_FILE
    LOGICAL:: NO_BINARY   = FALSE
    LOGICAL:: ENTIRE_LINE = FALSE
    LOGICAL:: BEGIN_END_OPTIONAL = FALSE
    LOGICAL:: TRUNCATED   = FALSE  !IF BLOCK INPUT THEN SET TO TRY WHEN END IS NOT FOUND
    LOGICAL:: REPEAT      = FALSE  !SET TO TRUE IF KEYWORD REPEAT WAS FOUND
    INTEGER:: OLD_IU      = Z
    !REAL(REAL64):: GLOBAL_SCALE = UNO
    !
    CONTAINS
    PROCEDURE,    NOPASS:: LOAD_BLOCK => LOAD_NEXT_FILE_BLOCK
    PROCEDURE, PASS(TFR):: ALLOC_LN   => ALLOC_TFR_LINE
    PROCEDURE, PASS(TFR):: DESTROY    => DEALLOCATE_FILE_READER
    !
    GENERIC:: INIT => INITIALIZE_FILE_READER_LINE,INITIALIZE_FILE_READER_FILE, INITIALIZE_FILE_READER_FID
    GENERIC:: NEXT => LOAD_NEXT_FILE_SCALAR, LOAD_NEXT_FILE_VECTOR, LOAD_NEXT_FILE_ARRAY  !(VAR, SFAC, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2)
    !              => LOAD_NEXT_FILE_SCALAR calls LOAD_NEXT_FILE_BLOCK if BL is passed in
    !
    PROCEDURE, PASS(TFR), PRIVATE :: INITIALIZE_FILE_READER_LINE   ! <= INIT
    PROCEDURE, PASS(TFR), PRIVATE :: INITIALIZE_FILE_READER_FILE   ! <= INIT
    PROCEDURE, PASS(TFR), PRIVATE :: INITIALIZE_FILE_READER_FID    ! <= INIT
    PROCEDURE, PASS(TFR), PRIVATE :: LOAD_NEXT_FILE_SCALAR
    PROCEDURE, PASS(TFR), PRIVATE :: LOAD_NEXT_FILE_VECTOR
    PROCEDURE, PASS(TFR), PRIVATE :: LOAD_NEXT_FILE_ARRAY
    !
    FINAL:: DEALLOCATE_FILE_READER_FINAL
  END TYPE
  !
  CONTAINS
  !
  PURE SUBROUTINE ALLOC_TFR_LINE(TFR, LEN_LN, DIM)
    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    INTEGER,      OPTIONAL,       INTENT(IN   ):: LEN_LN
    INTEGER,      OPTIONAL,       INTENT(IN   ):: DIM
    INTEGER:: N, M
    !
    M = Z
    IF(PRESENT(LEN_LN))                 M = LEN_LN
    IF(PRESENT(DIM   )) THEN; IF(DIM>Z) M = DIM
    END IF
    !    
    IF(ALLOCATED(TFR%LN)) THEN
       N = LEN(TFR%LN)
       IF(M > Z) THEN
                 IF(N.NE.M) THEN
                     DEALLOCATE(TFR%LN)
                       ALLOCATE(CHARACTER(M):: TFR%LN)
                 END IF
       ELSE
                 IF(N.NE.MAX_LINE_LEN) THEN
                     DEALLOCATE(TFR%LN)
                       ALLOCATE(CHARACTER(MAX_LINE_LEN):: TFR%LN)
                 END IF
           
       END IF
    ELSE
                IF(M > Z) THEN
                    ALLOCATE(CHARACTER(M):: TFR%LN)
                ELSE
                    ALLOCATE(CHARACTER(MAX_LINE_LEN):: TFR%LN)
                END IF
    END IF
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_READER_LINE(TFR,LLOC,LINE,IOUT,IN,NOID, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, NO_BINARY,ENTIRE_LINE, BLOCK_END_KEY, BEGIN_END_OPTIONAL, LEN_LN)
    CLASS(TRANSIENT_FILE_READER):: TFR
    INTEGER,                INTENT(INOUT):: LLOC
    CHARACTER(*),           INTENT(IN   ):: LINE
    INTEGER,                INTENT(IN   ):: IOUT, IN
    LOGICAL,                INTENT(IN   ):: NOID
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,      OPTIONAL, INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL, OPTIONAL,      INTENT(IN   ):: READ_BY_DIM2, NO_BINARY
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: BLOCK_END_KEY
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ENTIRE_LINE, BEGIN_END_OPTIONAL
    INTEGER,      OPTIONAL, INTENT(IN   ):: LEN_LN
    INTEGER:: DIM
    CHARACTER(8):: KEY
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
    DIM = Z
    KEY = BLNK
    !
    CALL TFR%OPEN(LINE,LLOC,IOUT,IN,KEY=KEY, DIM=DIM)
    !
    IF(TFR%IU == Z         ) CALL STOP_ERROR(LINE,IN,IOUT,'TRANSIENT FILE READER ERROR: TRANSIENT FILE (THE FILE THAT CONTAINS THE LIST OF FILES) IS SPECIFIED WITH "INTERNAL". THIS IS NOT ALLOWED. INSTEAD SPECIFY THE TRANSIENT FILE (FILE OF FILES) WITH EITHER "OPEN/CLOSE", "EXTERNAL", "DATAUNIT", OR "DATAFILE."')
    IF(KEY    == 'CONSTANT') CALL STOP_ERROR(LINE,IN,IOUT,'TRANSIENT FILE READER ERROR: TRANSIENT FILE (THE FILE THAT CONTAINS THE LIST OF FILES) IS SPECIFIED WITH "CONSTANT". THIS IS NOT ALLOWED. INSTEAD SPECIFY THE TRANSIENT FILE (FILE OF FILES) WITH EITHER "OPEN/CLOSE", "EXTERNAL", "DATAUNIT", OR "DATAFILE."')
    !
    TFR%LOAD_NEXT_FILE = KEY.NE.'DATAFILE' .AND. KEY.NE.'DATAUNIT'  !IF TFR%OPEN SUCESSFUN THEN KEYWORD PLACED TO THE LEFT OF LINE, SO LINE_IN HAS LINE_OUT = "KEYWORD LINE_OUT"
    !
    CALL ALLOC_TFR_LINE(TFR, LEN_LN, DIM)
    !
    TFR%NOID = NOID
    !
    IF(PRESENT(ROW_WORD)) THEN
           TFR%ROW_WORD = ROW_WORD
    ELSE
           TFR%ROW_WORD = 'n'
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
           TFR%COL_WORD = COL_WORD
    ELSE
           TFR%COL_WORD = 'n'
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
           TFR%EX1_WORD = EX1_WORD
           TFR%EX1_DIM  = EX1_DIM
    ELSE
           TFR%EX1_WORD = 'n'
           TFR%EX1_DIM  = Z
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
           TFR%EX2_WORD = EX2_WORD
           TFR%EX2_DIM  = EX2_DIM
    ELSE
           TFR%EX2_WORD = 'n'
           TFR%EX2_DIM  = Z
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
           TFR%EX3_WORD = EX3_WORD
           TFR%EX3_DIM  = EX3_DIM
    ELSE
           TFR%EX3_WORD = 'n'
           TFR%EX3_DIM  = Z
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        TFR%READ_BY_DIM2 = READ_BY_DIM2
    ELSE
        TFR%READ_BY_DIM2 = FALSE
    END IF
    !
    IF(PRESENT(NO_BINARY))    TFR%NO_BINARY = NO_BINARY
    !
    IF(PRESENT(BLOCK_END_KEY)) THEN
        TFR%BLOCK_END_KEY = TRIM(ADJUSTL(BLOCK_END_KEY))
    ELSE
        TFR%BLOCK_END_KEY = 'END'
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        TFR%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        TFR%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        TFR%ENTIRE_LINE = ENTIRE_LINE
    ELSE
        TFR%ENTIRE_LINE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_READER_FID(TFR, FID, IOUT, IN, NOID, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, NO_BINARY, DATAFILE,ENTIRE_LINE, BLOCK_END_KEY, GLOBAL_SCALE, BEGIN_END_OPTIONAL, LEN_LN)
    CLASS(TRANSIENT_FILE_READER):: TFR
    INTEGER,                    INTENT(IN):: FID
    INTEGER,                    INTENT(IN):: IOUT, IN
    LOGICAL,                    INTENT(IN):: NOID
    CHARACTER(*),     OPTIONAL, INTENT(IN):: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,          OPTIONAL, INTENT(IN):: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL,          OPTIONAL, INTENT(IN):: READ_BY_DIM2, NO_BINARY, DATAFILE
    CHARACTER(*),     OPTIONAL, INTENT(IN):: BLOCK_END_KEY
    REAL(REAL64),     OPTIONAL, INTENT(IN):: GLOBAL_SCALE
    LOGICAL,          OPTIONAL, INTENT(IN):: ENTIRE_LINE, BEGIN_END_OPTIONAL
    INTEGER,          OPTIONAL, INTENT(IN):: LEN_LN
    INTEGER:: LLOC
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
    CALL ALLOC_TFR_LINE(TFR, LEN_LN)
    !
    TFR%LN(:)=BLNK
    TFR%NOID = NOID
    !
    LLOC = ONE
    !
    TFR%IU = FID !CALL TFR%OPEN(LLOC,LINE,IOUT,IN,IU=FID)
    TFR%BINARY    = FALSE
    TFR%ERROR     = FALSE
    TFR%OPENCLOSE = FALSE
    TFR%IOUT = IOUT
    !
    IF(PRESENT(DATAFILE)) THEN
        TFR%LOAD_NEXT_FILE =  .NOT. DATAFILE
    ELSE
        TFR%LOAD_NEXT_FILE = TRUE
    END IF
    !
    IF(PRESENT(ROW_WORD)) THEN
           TFR%ROW_WORD = ROW_WORD
    ELSE
           TFR%ROW_WORD = 'n'
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
           TFR%COL_WORD = COL_WORD
    ELSE
           TFR%COL_WORD = 'n'
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
           TFR%EX1_WORD = EX1_WORD
           TFR%EX1_DIM  = EX1_DIM
    ELSE
           TFR%EX1_WORD = 'n'
           TFR%EX1_DIM  = Z
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
           TFR%EX2_WORD = EX2_WORD
           TFR%EX2_DIM  = EX2_DIM
    ELSE
           TFR%EX2_WORD = 'n'
           TFR%EX2_DIM  = Z
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
           TFR%EX3_WORD = EX3_WORD
           TFR%EX3_DIM  = EX3_DIM
    ELSE
           TFR%EX3_WORD = 'n'
           TFR%EX3_DIM  = Z
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        TFR%READ_BY_DIM2 = READ_BY_DIM2
    ELSE
        TFR%READ_BY_DIM2 = FALSE
    END IF
    !
    IF(PRESENT(NO_BINARY))    TFR%NO_BINARY = NO_BINARY
    !
    IF(PRESENT(BLOCK_END_KEY)) THEN
        TFR%BLOCK_END_KEY = TRIM(ADJUSTL(BLOCK_END_KEY))
    ELSE
        TFR%BLOCK_END_KEY = 'END'
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        TFR%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        TFR%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        TFR%ENTIRE_LINE = ENTIRE_LINE
    ELSE
        TFR%ENTIRE_LINE = FALSE
    END IF
    !
    IF(PRESENT(GLOBAL_SCALE)) TFR%SCALE = GLOBAL_SCALE
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_FILE_READER_FILE(TFR, FILE, IOUT, IN, NOID, ROW_WORD, COL_WORD, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, READ_BY_DIM2, NO_BINARY,ENTIRE_LINE, BLOCK_END_KEY, BEGIN_END_OPTIONAL, LEN_LN)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CHARACTER(*),           INTENT(IN   ):: FILE
    INTEGER,                INTENT(IN   ):: IOUT, IN
    LOGICAL,                INTENT(IN   ):: NOID
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: ROW_WORD, COL_WORD, EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER, OPTIONAL,      INTENT(IN   ):: EX1_DIM, EX2_DIM, EX3_DIM
    LOGICAL, OPTIONAL,      INTENT(IN   ):: READ_BY_DIM2, NO_BINARY
    CHARACTER(*), OPTIONAL, INTENT(IN   ):: BLOCK_END_KEY
    LOGICAL,      OPTIONAL, INTENT(IN   ):: ENTIRE_LINE, BEGIN_END_OPTIONAL
    INTEGER,      OPTIONAL, INTENT(IN   ):: LEN_LN
    INTEGER:: LLOC
    INTEGER:: DIM
    CHARACTER(8):: KEY
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
    DIM  = Z
    LLOC = ONE
    KEY  = BLNK
    !
    CALL TFR%OPEN(FILE,LLOC,IOUT,IN,KEY=KEY,DIM=DIM)
    !
    TFR%LOAD_NEXT_FILE =  KEY.NE.'DATAFILE' .AND. KEY.NE.'DATAUNIT'
    !
    CALL ALLOC_TFR_LINE(TFR, LEN_LN, DIM)
    !
    TFR%NOID = NOID
    !
    IF(PRESENT(ROW_WORD)) THEN
           TFR%ROW_WORD = ROW_WORD
    ELSE
           TFR%ROW_WORD = 'n'
    END IF
    !
    IF(PRESENT(COL_WORD)) THEN
           TFR%COL_WORD = COL_WORD
    ELSE
           TFR%COL_WORD = 'n'
    END IF
    !
    IF(PRESENT(EX1_WORD)) THEN
           TFR%EX1_WORD = EX1_WORD
           TFR%EX1_DIM  = EX1_DIM
    ELSE
           TFR%EX1_WORD = 'n'
           TFR%EX1_DIM  = Z
    END IF
    !
    IF(PRESENT(EX2_WORD)) THEN
           TFR%EX2_WORD = EX2_WORD
           TFR%EX2_DIM  = EX2_DIM
    ELSE
           TFR%EX2_WORD = 'n'
           TFR%EX2_DIM  = Z
    END IF
    !
    IF(PRESENT(EX3_WORD)) THEN
           TFR%EX3_WORD = EX3_WORD
           TFR%EX3_DIM  = EX3_DIM
    ELSE
           TFR%EX3_WORD = 'n'
           TFR%EX3_DIM  = Z
    END IF
    !
    IF(PRESENT(READ_BY_DIM2)) THEN
        TFR%READ_BY_DIM2 = READ_BY_DIM2
    ELSE
        TFR%READ_BY_DIM2 = FALSE
    END IF
    !
    IF(PRESENT(NO_BINARY))    TFR%NO_BINARY = NO_BINARY
    !
    IF(PRESENT(BLOCK_END_KEY)) THEN
        TFR%BLOCK_END_KEY = TRIM(ADJUSTL(BLOCK_END_KEY))
    ELSEIF(ALLOCATED(TFR%BLOCK_END_KEY)) THEN
         DEALLOCATE (TFR%BLOCK_END_KEY)
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        TFR%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        TFR%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    IF(PRESENT(ENTIRE_LINE)) THEN
        TFR%ENTIRE_LINE = ENTIRE_LINE
    ELSE
        TFR%ENTIRE_LINE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_TFR_BLOCK(TFR, BL, LLOC, IU, SKIP_END_KEY)  !ONLY CALLED FROM LOAD_NEXT_FILE_SCALAR
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    CLASS(GENERIC_BLOCK_READER),  INTENT(INOUT):: BL
    INTEGER,                      INTENT(INOUT):: LLOC, IU
    CHARACTER(*), DIMENSION(:),   INTENT(IN   ), OPTIONAL:: SKIP_END_KEY
    !
    IF(.NOT. ALLOCATED(TFR%BLOCK_END_KEY)) TFR%BLOCK_END_KEY='END'
    !                                                                                                   !FOUND_BEGIN   ,  FOUND_END
    CALL LOAD_NEXT_FILE_BLOCK(BL, LLOC, IU, TFR%OLD_IU, TFR%LN, TFR%IOUT, TFR%IU, TFR%SKIP, TFR%REPEAT, TFR%ENTIRE_LINE, TFR%TRUNCATED, TFR%BEGIN_END_OPTIONAL, TFR%BLOCK_END_KEY, TFR%NOID, TFR%EX1_WORD, TFR%EX1_DIM, TFR%EX2_WORD, TFR%EX2_DIM, TFR%EX3_WORD, TFR%EX3_DIM, TFR%NO_BINARY, SKIP_END_KEY)
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_BLOCK(BL, LLOC, IU, OLD_IU, LINE, IOUT, IN, SKIP, IS_REPEAT, FOUND_BEGIN, FOUND_END, BEGIN_END_OPTIONAL, BLOCK_END_KEY, NOID, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM, NO_BINARY, SKIP_END_KEY)
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(GENERIC_BLOCK_READER),  INTENT(INOUT):: BL
    INTEGER,       INTENT(INOUT):: LLOC, IU, OLD_IU
    CHARACTER(*),  INTENT(INOUT):: LINE
    INTEGER,       INTENT(IN   ):: IOUT, IN
    LOGICAL,       INTENT(  OUT):: SKIP, FOUND_BEGIN, FOUND_END, IS_REPEAT
    LOGICAL,       INTENT(IN   ):: BEGIN_END_OPTIONAL
    CHARACTER(*),  INTENT(IN   ):: BLOCK_END_KEY
    LOGICAL,       INTENT(IN   ), OPTIONAL:: NOID, NO_BINARY
    CHARACTER(*),  INTENT(IN   ), OPTIONAL:: EX1_WORD, EX2_WORD, EX3_WORD
    INTEGER,       INTENT(IN   ), OPTIONAL:: EX1_DIM,  EX2_DIM,  EX3_DIM
    CHARACTER(*),  INTENT(IN   ), DIMENSION(:),OPTIONAL:: SKIP_END_KEY
    INTEGER:: ISTART,ISTOP, N
    CHARACTER(12):: EXT
    LOGICAL:: ERROR
    !
    TYPE(GENERIC_INPUT_FILE):: FL
    !
    IS_REPEAT = FALSE
    !
    SKIP = FALSE
    N=ONE
    CALL GET_WORD( LINE,N,ISTART,ISTOP,EXT)
    IF(EXT == 'BEGIN') THEN
        LLOC = ONE
        IU = IN
        BACKSPACE(IU)
    ELSEIF (IU == Z) THEN
        !
        N = LLOC
        CALL ULOAD(FL, LLOC, LINE, IOUT, IN, IU, NOID=NOID, NOSTOP=TRUE, EX1_WORD=EX1_WORD, EX1_DIM=EX1_DIM, EX2_WORD=EX2_WORD, EX2_DIM=EX2_DIM, EX3_WORD=EX3_WORD, EX3_DIM=EX3_DIM, NO_BINARY=NO_BINARY, OLD_IU=OLD_IU)
        !
        IF(LINE(1:8) == 'CONSTANT') CALL STOP_ERROR( LINE=LINE, OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  THE KEYWORD "CONSTANT" IS NOT ALLOWED.')
        !
        IF(LLOC < Z) THEN  !FAILED TO INDENTIFY KEYWORD, CHECK IF FILE NAME IS JUST SPECIFIED.
            CALL FL%OPEN(LINE,N,IOUT,IN,NOSTOP=TRUE,REQKEY=FALSE,BINARY=FALSE) !,SFAC=SFAC_FILE
        END IF
        !
        SKIP = FL%SKIP
        IF(SKIP) THEN
            IU = Z
            LLOC = ONE
            RETURN
        END IF
        IF(FL%ERROR) CALL STOP_ERROR( LINE=LINE, OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  UNKNOW FAILURE WHILE PROCESSING LINE (MAYBE THE FILE HAS A BAD PATH???)')
        !
        IF(FL%IU == Z) THEN
            IU = IN
        ELSE
            IU = FL%IU
        END IF
    END IF
    !
    IF(LLOC < Z) LLOC = ONE
    CALL PARSE_WORD( LINE,LLOC,ISTART,ISTOP)
    SELECT CASE(LINE(ISTART:ISTOP))
    !CASE('SKIP');     SKIP = TRUE
    CASE('CONSTANT'); CALL STOP_ERROR( LINE=LINE(LLOC:), OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
    CASE('REPEAT'  )
                      BL%LN = 'REPEAT'
                      IS_REPEAT = TRUE
    CASE DEFAULT
                      CALL BL%LOAD(IU, IOUT, END_KEY=BLOCK_END_KEY, FOUND_BEGIN=FOUND_BEGIN, END_NOT_FOUND=ERROR, BEGIN_OPTIONAL=BEGIN_END_OPTIONAL, SKIP_END_KEY=SKIP_END_KEY)
                      !
                      FOUND_END = .NOT. ERROR
                      !
                      IF(ERROR)  THEN; IF(.NOT. BEGIN_END_OPTIONAL)  CALL STOP_ERROR( LINE,IU,IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK. THE BLOCK THAT WAS BEING LOADED IS "'//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//BLOCK_END_KEY//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
                      END IF

    END SELECT
    !
  END SUBROUTINE
  !
!  SUBROUTINE LOAD_NEXT_FILE_BLOCK(TFR, BL, LLOC, IU)  !ONLY CALLED FROM LOAD_NEXT_FILE_SCALAR
!    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
!    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
!    CLASS(GENERIC_BLOCK_READER),  INTENT(INOUT):: BL
!    INTEGER, INTENT(INOUT):: LLOC, IU
!    INTEGER:: ISTART,ISTOP, N
!    CHARACTER(8):: EXT
!    LOGICAL:: ERROR
!    !
!    TYPE(GENERIC_INPUT_FILE):: FL
!    !
!    N=ONE
!    CALL GET_WORD( TFR%LN,N,ISTART,ISTOP,EXT)
!    IF(EXT == 'BEGIN') THEN
!        LLOC = ONE
!        IU = TFR%IU
!        BACKSPACE(IU)
!    ELSEIF (IU == Z) THEN
!        !
!        CALL ULOAD(FL, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, NOSTOP=TRUE, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, NO_BINARY=TFR%NO_BINARY, OLD_IU=TFR%OLD_IU)
!        !
!        IU = FL%IU
!        IF(IU==Z) IU = TFR%IU
!        IF(LLOC < Z) THEN  !FOUND IMPLIED INTERNAL
!            BACKSPACE(IU)
!            LLOC = ONE
!        ELSEIF(FL%ERROR) THEN
!            CALL STOP_ERROR( LINE=TFR%LN, OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  UNKNOW FAILURE WHILE PROCESSING LINE (MAYBE THE FILE HAS A BAD PATH???)')
!        END IF
!    END IF
!    !
!    IF(.NOT. ALLOCATED(TFR%BLOCK_END_KEY)) TFR%BLOCK_END_KEY='END'
!    !
!    TFR%SKIP = FALSE
!    CALL PARSE_WORD( TFR%LN,LLOC,ISTART,ISTOP)
!    SELECT CASE(TFR%LN(ISTART:ISTOP))
!    CASE('SKIP');     TFR%SKIP = TRUE
!    CASE('CONSTANT'); CALL STOP_ERROR( LINE=TFR%LN(LLOC:), OUTPUT=BL%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR:  THIS INPUT READ UTILITY DOES NOT ALLOW FOR THE KEYWORD "CONSTANT". PLEASE USE A KEYWORD TO INDICATE WHERE DATA IS LOCATED (e.g INTERNAL|EXTERNAL|OPEN/CLOSE)')
!    CASE('REPEAT');   BL%LN = 'REPEAT'
!    CASE DEFAULT
!                      CALL BL%LOAD(IU, TFR%IOUT, TFR%IOUT, END_KEY=TFR%BLOCK_END_KEY, FOUND_BEGIN=TFR%ENTIRE_LINE, END_NOT_FOUND=ERROR)
!                      !
!                      TFR%TRUNCATED = .NOT. ERROR
!                      !
!                      IF(ERROR)  THEN; IF(.NOT. TFR%BEGIN_END_OPTIONAL)  CALL STOP_ERROR( TFR%LN,IU,TFR%IOUT, MSG= 'TRANSIENT FILE READER - BLOCK READER ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK. THE BLOCK THAT WAS BEING LOADED IS "'//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//TFR%BLOCK_END_KEY//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
!                      END IF
!
!    END SELECT
!    !
!  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_SCALAR(TFR, VAR, SFAC, ID, SKIP_END_KEY, MSG)
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CLASS(*),                                INTENT(INOUT):: VAR
    TYPE(SFAC_DATA), OPTIONAL,               INTENT(INOUT):: SFAC
    INTEGER,         OPTIONAL,               INTENT(INOUT):: ID
    CHARACTER(*),    OPTIONAL, DIMENSION(:), INTENT(IN   ):: SKIP_END_KEY
    CHARACTER(*),    OPTIONAL,               INTENT(IN   ):: MSG
    !
    INTEGER:: LLOC, IU
    !TFR%SFAC_OLD = TFR%SFAC
    !
    IF (TFR%LOAD_NEXT_FILE) THEN
        IU = Z
        CALL READ_TO_DATA(TFR%LN,TFR%IU,TFR%IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
        IF(TFR%LN==BLNK) CALL STOP_ERROR(INFILE=TFR%IU,OUTPUT=TFR%IOUT,MSG = 'TRANSIENT FILE READER FAILED TO LOAD NEXT LINE WHICH POINTS TO NEXT FILE TO LOAD.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
    ELSE
        IU = TFR%IU
    END IF
    !
    LLOC = ONE
    !
    SELECT TYPE(VAR)
    CLASS IS (GENERIC_BLOCK_READER)
                 CALL LOAD_NEXT_TFR_BLOCK(TFR, VAR, LLOC, IU, SKIP_END_KEY)
    CLASS DEFAULT
                 CALL ULOAD(VAR, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, ID=ID, SFAC=SFAC, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, NO_BINARY=TFR%NO_BINARY, ENTIRE_LINE=TFR%ENTIRE_LINE, OLD_IU=TFR%OLD_IU, MSG=MSG)
                 IF(TFR%SCALE.NE.UNO) CALL SFAC%SET_ALL(TFR%SCALE)
                 TFR%TRUNCATED = LLOC < Z
                 TFR%REPEAT = 'REPEAT' == TFR%LN(1:8)
    END SELECT
    !
    !IF (TFR%LN(1:8) == 'REPEAT' ) THEN
    !    SFAC = TFR%SFAC / TFR%SFAC_OLD
    !ELSE
    !    SFAC = TFR%SFAC
    !END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_VECTOR(TFR, VAR, SFAC, ID, MSG)
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CLASS(*),                  DIMENSION(:), CONTIGUOUS,  INTENT(INOUT):: VAR
    TYPE(SFAC_DATA), OPTIONAL,                            INTENT(INOUT):: SFAC
    INTEGER,         OPTIONAL, DIMENSION(:), ALLOCATABLE, INTENT(INOUT):: ID
    CHARACTER(*),    OPTIONAL,                            INTENT(IN   ):: MSG
    !
    INTEGER:: LLOC, IU
    !TFR%SFAC_OLD = TFR%SFAC
    !
    IF (TFR%LOAD_NEXT_FILE) THEN
        IU = Z
        CALL READ_TO_DATA(TFR%LN,TFR%IU,TFR%IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
        IF(TFR%LN==BLNK) CALL STOP_ERROR(INFILE=TFR%IU,OUTPUT=TFR%IOUT,MSG = 'TRANSIENT FILE READER FAILED TO LOAD NEXT LINE WHICH POINTS TO NEXT FILE TO LOAD.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
    ELSE
        IU = TFR%IU
    END IF
    !
    LLOC = ONE
    !
    CALL ULOAD(VAR, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, ID=ID, ROW_WORD=TFR%ROW_WORD, SFAC=SFAC, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, NO_BINARY=TFR%NO_BINARY, ENTIRE_LINE=TFR%ENTIRE_LINE, OLD_IU=TFR%OLD_IU, MSG=MSG)
    !
    IF(TFR%SCALE.NE.UNO) CALL SFAC%SET_ALL(TFR%SCALE)
    TFR%TRUNCATED = LLOC < Z
    TFR%REPEAT = 'REPEAT' == TFR%LN(1:8)
    !
    !IF (TFR%LN(1:8) == 'REPEAT' ) THEN
    !    SFAC = TFR%SFAC / TFR%SFAC_OLD
    !ELSE
    !    SFAC = TFR%SFAC
    !END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_FILE_ARRAY(TFR, VAR, SFAC, ID, MSG)
    ! ASSUMES THAT COLUMNS ARE STORED IN FIRST DIMENSION (STFRDARD STRUCTURE FOR MF)
    CLASS(TRANSIENT_FILE_READER):: TFR
    CLASS(*),                  DIMENSION(:,:), CONTIGUOUS, INTENT(INOUT):: VAR
    TYPE(SFAC_DATA), OPTIONAL,                             INTENT(INOUT):: SFAC
    INTEGER,         OPTIONAL, DIMENSION(:), ALLOCATABLE,  INTENT(INOUT):: ID
    CHARACTER(*),    OPTIONAL,                             INTENT(IN   ):: MSG
    !
    INTEGER:: LLOC, IU
    !TFR%SFAC_OLD = TFR%SFAC
    !
    IF (TFR%LOAD_NEXT_FILE) THEN
        IU = Z
        CALL READ_TO_DATA(TFR%LN,TFR%IU,TFR%IOUT)  !UNIT IS BEING PASSED IN SO READ IN LINE FROM IT
        IF(TFR%LN==BLNK) CALL STOP_ERROR(INFILE=TFR%IU,OUTPUT=TFR%IOUT,MSG = 'TRANSIENT FILE READER FAILED TO LOAD NEXT LINE WHICH POINTS TO NEXT FILE TO LOAD.'//NL//'THIS MOST LIKELY OCCURED BECAUSE THE END OF FILE WAS REACHED.'//BLN//'POSSIBLE CAUSES ARE NOT ENOUGH STRESS PERIOD INPUT, AN EMPTY FILE,'//NL//'OR YOU SPECIFIED TRANSIENT WHEN YOU MEANT STATIC FOR A LIST-ARRAY INPUT.', MSG2=MSG)
    ELSE
        IU = TFR%IU
    END IF
    !
    LLOC = ONE
    !
    CALL ULOAD(VAR, LLOC, TFR%LN, TFR%IOUT, TFR%IU, IU, NOID=TFR%NOID, ID=ID, ROW_WORD=TFR%ROW_WORD, COL_WORD=TFR%COL_WORD, SFAC=SFAC, EX1_WORD=TFR%EX1_WORD, EX1_DIM=TFR%EX1_DIM, EX2_WORD=TFR%EX2_WORD, EX2_DIM=TFR%EX2_DIM, EX3_WORD=TFR%EX3_WORD, EX3_DIM=TFR%EX3_DIM, READ_BY_DIM2=TFR%READ_BY_DIM2, NO_BINARY=TFR%NO_BINARY, OLD_IU=TFR%OLD_IU, MSG=MSG)
    !
    IF(TFR%SCALE.NE.UNO) CALL SFAC%SET_ALL(TFR%SCALE)
    TFR%TRUNCATED = LLOC < Z
    TFR%REPEAT = 'REPEAT' == TFR%LN(1:8)
    !
    !IF (TFR%LN(1:8) == 'REPEAT' ) THEN
    !    SFAC = TFR%SFAC / TFR%SFAC_OLD
    !ELSE
    !    SFAC = TFR%SFAC
    !END IF
    !
  END SUBROUTINE
  !
  !PURE SUBROUTINE ALLOC_LN(TFR)
  !  CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
  !  IF(.NOT. ALLOCATED(TFR%LN)) ALLOCATE( CHARACTER(MAX_LINE_LEN):: TFR%LN )
  !END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_FILE_READER(TFR)
    CLASS(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    !
    TFR%NOID               = FALSE
    TFR%READ_BY_DIM2       = FALSE
    TFR%LOAD_NEXT_FILE     = FALSE
    TFR%NO_BINARY          = FALSE
    TFR%ENTIRE_LINE        = FALSE
    TFR%BEGIN_END_OPTIONAL = FALSE
    TFR%TRUNCATED          = FALSE  !IF BLOCK INPUT THEN SET TO TRY WHEN END IS NOT FOUND
    TFR%REPEAT             = FALSE  !SET TO TRUE IF KEYWORD REPEAT WAS FOUND
    TFR%OLD_IU = Z
    !
    IF(ALLOCATED(TFR%LN)      ) DEALLOCATE(TFR%LN)
    IF(ALLOCATED(TFR%ROW_WORD)) DEALLOCATE(TFR%ROW_WORD)
    IF(ALLOCATED(TFR%COL_WORD)) DEALLOCATE(TFR%COL_WORD)
    IF(ALLOCATED(TFR%EX1_WORD)) DEALLOCATE(TFR%EX1_WORD)
    IF(ALLOCATED(TFR%EX2_WORD)) DEALLOCATE(TFR%EX2_WORD)
    IF(ALLOCATED(TFR%EX3_WORD)) DEALLOCATE(TFR%EX3_WORD)
    !
    IF(ALLOCATED(TFR%BLOCK_END_KEY)) DEALLOCATE(TFR%BLOCK_END_KEY)
    !
    !TFR%GLOBAL_SCALE = UNO
    !
    CALL TFR%CLOSE()
    !
    !CALL TFR%SFAC%INIT()
    !CALL TFR%SFAC_OLD%INIT()
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_FILE_READER_FINAL(TFR)
    TYPE(TRANSIENT_FILE_READER), INTENT(INOUT):: TFR
    !
    CALL DEALLOCATE_FILE_READER(TFR)
    !
  END SUBROUTINE
  !
END MODULE
