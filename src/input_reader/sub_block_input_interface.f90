!
! CODE DEVELOPED BY SCOTT E BOYCE
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LISTING:
!
!   SUB_BLOCK_INPUT_INTERFACE
!
MODULE SUB_BLOCK_INPUT_INTERFACE!, ONLY: SUB_BLOCK_INPUT
  !CHECKS FOR FLAGS LIST/ARRAY AND THEN STATIC/TRANSIENT AND THEN LOADS FIRST LIST/ARRAY
  USE CONSTANTS
  USE STRINGS,                           ONLY: GET_WORD
  USE ERROR_INTERFACE,                   ONLY: STOP_ERROR, WARNING_MESSAGE
  USE TRANSIENT_FILE_READER_INSTRUCTION, ONLY: TRANSIENT_FILE_READER
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  IMPLICIT NONE
  !
  PRIVATE
  PUBLIC:: SUB_BLOCK_INPUT
  !
  TYPE SUB_BLOCK_INPUT
        LOGICAL:: INUSE     = FALSE     ! TRUE WHEN OBJECT HAS BE INITIALIZED
        LOGICAL:: TRANSIENT = FALSE     ! TRUE WHEN TRANSIENT KEYWORD FOUND
        LOGICAL:: UPCASE    = FALSE
        LOGICAL:: PULL_PARRENT = TRUE
        LOGICAL:: REPEAT       = FALSE
        LOGICAL:: FOUND_BEGIN  = FALSE
        LOGICAL:: FOUND_END    = FALSE
        LOGICAL:: BEGIN_END_OPTIONAL = FALSE
        LOGICAL:: SKIP               = TRUE
        LOGICAL:: HAS_SKIP_END_KEY   = FALSE
        CHARACTER(:), ALLOCATABLE:: TYP
        CHARACTER(:),DIMENSION(:), ALLOCATABLE:: SKIP_END_KEY
        TYPE(GENERIC_BLOCK_READER):: BL  !HOLDS BLOCK DATA
        !
        TYPE(TRANSIENT_FILE_READER):: TFR
        !
        CONTAINS
        !
        PROCEDURE, PASS(INP):: INIT    => INITIALIZE_SUB_BLOCK_INPUT!(INP, TYP, LLOC, LINE, IOUT, IN, SCRATCH, NO_TRANSIENT, END_KEY, ALLOW_INTERNAL, BEGIN_END_OPTIONAL, SKIP_END_KEY)
        PROCEDURE, PASS(INP):: NEXT    => LOAD_NEXT_INPUT!()
        PROCEDURE, PASS(INP):: DESTROY => DEALLOCATE_SUB_BLOCK_INPUT!()
        !
        FINAL:: DEALLOCATE_SUB_BLOCK_INPUT_FINAL
        !
  END TYPE
  !
  CONTAINS
  !
  SUBROUTINE DEALLOCATE_SUB_BLOCK_INPUT(INP)
    CLASS(SUB_BLOCK_INPUT), INTENT(INOUT):: INP
    !
    INP%INUSE     = FALSE     ! TRUE WHEN OBJECT HAS BE INITIALIZED
    INP%TRANSIENT = FALSE     ! TRUE WHEN TRANSIENT KEYWORD FOUND
    INP%UPCASE    = FALSE
    INP%PULL_PARRENT = TRUE
    INP%REPEAT       = FALSE
    INP%FOUND_BEGIN  = FALSE
    INP%FOUND_END    = FALSE
    INP%BEGIN_END_OPTIONAL = FALSE
    INP%SKIP               = TRUE
    INP%HAS_SKIP_END_KEY   = FALSE
    !
    IF(ALLOCATED(INP%TYP)) DEALLOCATE(INP%TYP)
    IF(ALLOCATED(INP%SKIP_END_KEY)) DEALLOCATE(INP%SKIP_END_KEY)
    !
    CALL INP% BL%DESTROY()
    CALL INP%TFR%DESTROY()
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_SUB_BLOCK_INPUT_FINAL(INP)
    TYPE(SUB_BLOCK_INPUT), INTENT(INOUT):: INP
    !
    CALL DEALLOCATE_SUB_BLOCK_INPUT(INP)
    !
  END SUBROUTINE
  !
  SUBROUTINE INITIALIZE_SUB_BLOCK_INPUT(INP, TYP, LLOC, LINE, IOUT, IN, SCRATCH, NO_TRANSIENT, END_KEY, ALLOW_INTERNAL, BEGIN_END_OPTIONAL, SKIP_END_KEY)
    ! TYP   NAME OF BLOCKS TO BE LOADED
    ! IN    IS FILE TO LOAD INFORMATION FROM OR TO CLAIM OCCURED AT
    !
    ! OPTIONAL ARGUMENTS:
    !                    EX1_DIM, EX1_WORD ARE DIMENSION AND KEYWORD USED FOR SFAC ROUTING  (eg NFARM, 'BYWBS')
    !                    SCARTCH IS THE UNIT NUMBER TO LOAD INFORMATION FROM, WHEN IN IS ONLY MEANT TO BE USED FOR ERROR REPORTING
    CLASS(SUB_BLOCK_INPUT),INTENT(INOUT):: INP
    CHARACTER(*),          INTENT(IN   ):: TYP
    CHARACTER(*),          INTENT(IN   ):: LINE
    INTEGER,               INTENT(INOUT):: LLOC
    INTEGER,               INTENT(IN   ):: IOUT, IN
    INTEGER,     OPTIONAL, INTENT(IN   ):: SCRATCH
    LOGICAL,     OPTIONAL, INTENT(IN   ):: NO_TRANSIENT
    CHARACTER(*),OPTIONAL, INTENT(IN   ):: END_KEY
    LOGICAL,     OPTIONAL, INTENT(IN   ):: ALLOW_INTERNAL, BEGIN_END_OPTIONAL
    CHARACTER(*), DIMENSION(:),OPTIONAL,INTENT(IN):: SKIP_END_KEY
    !
    INTEGER:: IU,N
    LOGICAL::ONLY_STATIC, NO_INTERNAL
    CHARACTER(:), ALLOCATABLE:: KEY
    CHARACTER(9):: LAI_KEY
    !
    IF(INP%INUSE) THEN
        CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY BLOCK INPUT (LAI) PROPERTY "'//TYP//'" IS BEING LOADED A SECOND TIME!!!'//BLN//'¿¿¿MAYBE YOU ACCIDENTALLY SPECIFIED THE SAME KEYWORD TWICE???'//BLN//'THE PREVIOUS LINE THAT THE KEYWORD WAS FOUND WILL BE IGNORED'//NL//'AND THE LINE PRESENTED IN THIS WARNING WILL BE USED INSTEAD.')
        CALL DEALLOCATE_SUB_BLOCK_INPUT(INP)
    END IF
    !
    ONLY_STATIC = FALSE
    IF(PRESENT(NO_TRANSIENT)) ONLY_STATIC = NO_TRANSIENT
    INP%INUSE = TRUE
    ALLOCATE(INP%TYP, SOURCE = TYP)
    !
    INP%TRANSIENT = FALSE
    !
    IF(PRESENT(END_KEY)) THEN
        ALLOCATE(KEY, SOURCE = END_KEY)
    ELSE
        ALLOCATE(KEY, SOURCE = 'END')
    END IF
    !
    IF(PRESENT(ALLOW_INTERNAL)) THEN
        NO_INTERNAL = .NOT. ALLOW_INTERNAL
    ELSE
        NO_INTERNAL = TRUE
    END IF
    !
    IF(PRESENT(BEGIN_END_OPTIONAL)) THEN
        INP%BEGIN_END_OPTIONAL = BEGIN_END_OPTIONAL
    ELSE
        INP%BEGIN_END_OPTIONAL = FALSE
    END IF
    !
    CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
    !
    SELECT CASE (LAI_KEY)
                                   CASE('TRANSIENT'); INP%TRANSIENT = TRUE
                                   CASE('STATIC');    INP%TRANSIENT = FALSE
                                   CASE('PARRENT')
                                                      INP%PULL_PARRENT = TRUE
                                                      INP%TRANSIENT = FALSE
                                                      RETURN
                                   CASE('CONSTANT')
                                                      CALL STOP_ERROR(LINE,IN,IOUT,'FMP BLOCK ERROR FOR PROPERTY "'//TYP//'". FOUND KEYWORD "CONSTANT", WHICH IS NOT ALLOWED FOR SUB-BLOCK LOADING')

                                   CASE('LIST','ARRAY','COMPRESS', 'COMPRESSE','DIM','DIMENSION','AUTO','AUTOCOUNT','AUTO-COUN')
                                                      CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) BLOCK LOADER PROPERTY "'//TYP//'" DOES NOT REQUIRE/USE "'//TRIM(LAI_KEY)//'" KEYWORD.'//BLN//'IT WILL BE IGNORED.'//BLN//'PROGRAM WILL CONTINUE AS IF IT WAS NOT SPECIFIED.', INLINE=TRUE)
                                   CASE DEFAULT
                                                      IF(.NOT. ONLY_STATIC) CALL WARNING_MESSAGE(LINE,IN,IOUT,MSG='LIST-ARRAY INPUT (LAI) BLOCK LOADER PROPERTY "'//TYP//'" DID NOT IDENTIFY THE KEYWORD "STATIC" OR "TRANSIENT".'//BLN//'PROGRAM WILL CONTINUE AS IF THE KEYWORD "STATIC" WAS SPECIFEID.')
                                                      LLOC = N
    END SELECT
    !
    CALL GET_WORD(LAI_KEY,LINE,LLOC,N)
    !
    SELECT CASE (LAI_KEY)
                                   CASE('BLOCK','SUBBLOCK','SUB_BLOCK')
                                                 CONTINUE
                                   CASE('CONSTANT')
                                                   CALL STOP_ERROR(LINE,IN,IOUT,'FMP BLOCK ERROR FOR PROPERTY "'//TYP//'". FOUND KEYWORD "CONSTANT", WHICH IS NOT ALLOWED FOR SUB-BLOCK LOADING')
                                   CASE DEFAULT
                                                 LLOC = N
    END SELECT
    !
    IF(ONLY_STATIC .AND. INP%TRANSIENT .AND. IOUT.NE.Z) WRITE(IOUT, '(A,/A/)') 'WARNING: GENERIC BLOCK LOADER FOR PROPERTY "'//TYP//'" CAN ONLY BE LOADED ONCE, BUT "TRANSIENT" KEYWORD WAS FOUND. PROGRAM WILL CONTINUE AS IF "STATIC" WAS SPECIFIED. THE FOLLOWING LINE CONTAINS THE PROBLEM:',TRIM(LINE)
    IF(ONLY_STATIC) INP%TRANSIENT = FALSE
    !
    !
    IF (.NOT. INP%TRANSIENT ) THEN                 !NOTE INP%REPEAT = FALSE BY DEFAULT
        !
        IU = Z
        INP%TFR%OLD_IU = Z
        !CALL INP%TFR%ALLOC_LN()
        ALLOCATE(INP%TFR%LN, SOURCE=TRIM(LINE))
        !
        CALL INP%TFR%LOAD_BLOCK(INP%BL, LLOC, IU, INP%TFR%OLD_IU, INP%TFR%LN, IOUT, IN, INP%TFR%NULL_FILE, INP%TFR%REPEAT, INP%FOUND_BEGIN, INP%FOUND_END, INP%BEGIN_END_OPTIONAL, KEY, NOID=TRUE, NO_BINARY=TRUE, SKIP_END_KEY=SKIP_END_KEY) !, EX1_WORD, EX1_DIM, EX2_WORD, EX2_DIM, EX3_WORD, EX3_DIM
        !
        DEALLOCATE(INP%TFR%LN)
        !
        INP%SKIP = INP%TFR%NULL_FILE
        !
        IF(INP%SKIP) THEN
                    INP%REPEAT      = FALSE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
        ELSE
                    CALL SUB_BLOCK_ERROR_CHECK(INP)
        END IF

    ELSE
        IF(PRESENT(SKIP_END_KEY)) THEN
                                  ALLOCATE(INP%SKIP_END_KEY, SOURCE=SKIP_END_KEY)
                                  INP%HAS_SKIP_END_KEY = TRUE
        ELSE
            INP%HAS_SKIP_END_KEY = FALSE
        END IF
        !
        CALL INP%TFR%INIT( LLOC, LINE, IOUT, IN, NOID=TRUE, NO_BINARY=TRUE, BLOCK_END_KEY=KEY, BEGIN_END_OPTIONAL=BEGIN_END_OPTIONAL)
        !
        CALL LOAD_NEXT_INPUT(INP)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE SUB_BLOCK_ERROR_CHECK(INP)
    CLASS(SUB_BLOCK_INPUT),INTENT(INOUT):: INP
    !
    IF((.NOT. INP%FOUND_BEGIN .OR. .NOT. INP%FOUND_END) .AND. .NOT. INP%BEGIN_END_OPTIONAL)  THEN
            IF(.NOT. INP%FOUND_BEGIN) THEN
                CALL STOP_ERROR( INFILE=INP%BL%IU, OUTPUT=INP%BL%IOUT, MSG= 'SUB_BLOCK_LOAD ERROR: FAILD TO IDENTIFY THE KEYWORD "BEGIN" TO INTIATE A BLOCK INPUT LOAD. THE BLOCK VARIABLE THAT WAS BEING LOADED IS "'//INP%TYP//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//TRIM(INP%BL%END_KEY)//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY OPENED AND CLOSED.')
            ELSE
                CALL STOP_ERROR( INFILE=INP%BL%IU, OUTPUT=INP%BL%IOUT, MSG= 'SUB_BLOCK_LOAD ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK. THE BLOCK THAT WAS BEING LOADED IS "'//INP%BL%NAME//'" FOR VARIABLE "'//INP%TYP//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK:"'//TRIM(INP%BL%END_KEY)//'". PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
            END IF
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_NEXT_INPUT(INP)
    CLASS(SUB_BLOCK_INPUT), INTENT(INOUT):: INP
    !
    IF(INP%INUSE) THEN
          IF(INP%TRANSIENT) THEN
              !
              IF(INP%HAS_SKIP_END_KEY) THEN
                                       CALL INP%TFR%NEXT(INP%BL, SKIP_END_KEY=INP%SKIP_END_KEY)
              ELSE
                                       CALL INP%TFR%NEXT(INP%BL)
              END IF

              !
              INP%SKIP = INP%TFR%NULL_FILE
              !
              IF(INP%BL%LN == 'REPEAT') THEN
                    INP%REPEAT      = TRUE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
              ELSEIF(INP%SKIP) THEN
                    INP%REPEAT      = FALSE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
              ELSE
                    INP%REPEAT      = FALSE
                    !
                    INP%FOUND_BEGIN = INP%TFR%ENTIRE_LINE  !NOTE THIS VARIABLE IS BEING USED TO DETERMINE IF THE BEING VARIABLE WAS FOUND
                    INP%FOUND_END   = INP%TFR%TRUNCATED    !NOTE THIS VARIABLE IS BEING USED TO DETERMINE IF THE END   VARIABLE WAS FOUND
                    !
                    CALL SUB_BLOCK_ERROR_CHECK(INP)
                    !
              END IF
          ELSE
                    INP%FOUND_BEGIN = TRUE
                    INP%FOUND_END   = TRUE
          END IF
    END IF
    !
  END SUBROUTINE
    !
END MODULE
!