!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
!
!   GENERIC_BLOCK_READER_INSTRUCTION
!                           DATA TYPE
!                                    GENERIC_BLOCK_READER
!                           SUBROUTINES
!                                    BL%LOAD                --LOADS BLOCK INTO A LINKED LIST OF LINES, REMOVES ALL COMMENTS
!                                    BL%MAKE_SCRATCH_FILE   --DUMPS BLOCK TO SCRATCH FILE SO THAT TOOLS THAT REQUIRE FILE INPUT CAN LOAD IT.!
!
!       
!  
MODULE GENERIC_BLOCK_READER_INSTRUCTION!, ONLY: GENERIC_BLOCK_READER
  USE CONSTANTS,                      ONLY: BLNK,BLN,NL,TAB,COM,Z,ONE,TWO,TEN,DZ,UNO,DOS,DIEZ,TRUE,FALSE,lowerCHAR,upperCHAR
  USE LINKED_LIST_INSTRUCTION,        ONLY: CHARACTER_LINKED_LIST
  USE FILE_IO_INTERFACE,              ONLY: READ_TO_DATA, COMMENT_INDEX
  USE PARSE_WORD_INTERFACE,           ONLY: PARSE_WORD, PARSE_WORD_UP
  USE ERROR_INTERFACE,                ONLY: STOP_ERROR
  USE NUM2STR_INTERFACE,              ONLY: NUM2STR
  USE GENERIC_OPEN_INTERFACE,         ONLY: GENERIC_SCRATCH_FILE
  USE GENERIC_INPUT_FILE_INSTRUCTION, ONLY: GENERIC_INPUT_FILE
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: GENERIC_BLOCK_READER
  ! 
  TYPE GENERIC_BLOCK_READER
      INTEGER:: LINE_LEN = 1250                      !SETS SIZE OF INTERNAL LINE
      INTEGER:: IU   = Z
      INTEGER:: IOUT = Z
      INTEGER:: NLINE= Z
      INTEGER:: SCRATCH = Z
      CHARACTER(:),             ALLOCATABLE:: NAME
      CHARACTER(:),             ALLOCATABLE:: EXTRA
      CHARACTER(:),             ALLOCATABLE:: END_KEY
      TYPE(CHARACTER_LINKED_LIST)          :: LIST
      CHARACTER(:),             ALLOCATABLE:: LN   !SCRATCH LINE FOR LOADING
      CHARACTER(:), POINTER:: LINE  => NULL()      !HOLDS LIST LN
      CONTAINS
      PROCEDURE, PASS(BL):: INIT        => INIT_GENERIC_BLOCK      !INIT (IU,[IOUT], [LEN_LEN]) --OPTIONAL, SHOULD USE LOAD
      PROCEDURE, PASS(BL):: LOAD        => LOAD_GENERIC_BLOCK      !LOAD (IU,[IOUT],[LINE], [END_KEY], [END_NOT_FOUND], [FOUND_BEGIN], [SKIP], [BEGIN_OPTIONAL])
      PROCEDURE, PASS(BL):: GET_NAME    => GET_BLOCK_NAME
      PROCEDURE, PASS(BL):: GET_EXTRA   => GET_BLOCK_EXTRA         !GET_EXTRA([POS], [NO_UPPER])
      PROCEDURE, PASS(BL):: INNER       => LOAD_INNER_GENERIC_BLOCK!INNER([END_KEY], [IU], [IOUT], [END_NOT_FOUND], [SKIP_END_KEY])
      PROCEDURE, PASS(BL):: SET_LINE_LEN=> SET_BLOCK_LINE_LEN      !SET_LINE_LEN(LEN_LEN)
      PROCEDURE, PASS(BL):: START       => START_OF_BLOCK 
      PROCEDURE, PASS(BL):: NEXT        => NEXT_BLOCK_LINE
      PROCEDURE, PASS(BL):: BACK        => MOVE_BACK_BLOCK_LINE
      PROCEDURE, PASS(BL):: ADD_LINE    => INSERT_LINE_INTO_BLOCK!(LINE,[POS])
      PROCEDURE, PASS(BL):: DELETE_LINE => DELETE_CURRENT_LINE
      PROCEDURE, PASS(BL):: DEL_LINE    => DELETE_CURRENT_LINE
      PROCEDURE, PASS(BL):: POP_LINE    => REMOVE_LINE_AT !([POS])
      PROCEDURE, PASS(BL):: LINE_NUM    => GET_LINE_POS   !RESULT(POS) 
      PROCEDURE, PASS(BL):: GOTO_LINE   => GOTO_LINE_POS  !(POS)
      PROCEDURE, PASS(BL):: GOTO_END    => GOTO_BLOCK_END !()
      PROCEDURE, PASS(BL):: AT_END      => BLOCK_AT_END
      PROCEDURE, PASS(BL):: NOT_AT_END  => BLOCK_NOT_AT_END
      PROCEDURE, PASS(BL):: SET_LINE    => SET_BLOCK_LINE
      PROCEDURE, PASS(BL):: SET_END_KEY => SET_BLOCK_END_KEY!(END_KEY)
      PROCEDURE, PASS(BL):: READ_AND_SET_LINE!(IU, [EOL], [EOF]) --LOADS ONE LINE FROM IU TO BL%LN
      PROCEDURE, PASS(BL):: READ_SCRATCH=> READ_SCRATCH_LINE!([LINE], [ERROR])
      PROCEDURE, PASS(BL):: UPDATE_NLINE=> UPDATE_BLOCK_NLINE
      PROCEDURE, PASS(BL):: CLOSE_SCRATCH=>CLOSE_SCRATCH_GENERIC_BLOCK
      GENERIC            :: MAKE_SCRATCH      => MAKE_SCRATCH_FILE_START, MAKE_SCRATCH_FILE_SUBFILE, MAKE_SCRATCH_FILE_RELATIVE
      GENERIC            :: MAKE_SCRATCH_FILE => MAKE_SCRATCH_FILE_START, MAKE_SCRATCH_FILE_SUBFILE, MAKE_SCRATCH_FILE_RELATIVE
      PROCEDURE, PASS(BL):: MAKE_SCRATCH_FILE_START    !(FROM_START)
      PROCEDURE, PASS(BL):: MAKE_SCRATCH_FILE_SUBFILE  !(ISTART,ISTOP) --starting line and ending line
      PROCEDURE, PASS(BL):: MAKE_SCRATCH_FILE_RELATIVE !(NLINE)
      PROCEDURE, PASS(BL):: ALLOC_LN
      PROCEDURE, PASS(BL):: DESTROY=> DEALLOCATE_GENERIC_BLOCK
      FINAL::                       FINAL_DEALLOCATE_GENERIC_BLOCK
  END TYPE
  !
  CONTAINS
  !
  ! -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ! 
  PURE SUBROUTINE UPPER(LN)
    CHARACTER(*), INTENT(INOUT):: LN
    INTEGER:: I, N
    !
    DO I=1, LEN(LN)
        N = INDEX( lowerCHAR, LN(I:I))
        !
        IF(N > 0) LN(I:I) = upperCHAR(N:N)
    END DO
  END SUBROUTINE
  !
  ! -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  !
  SUBROUTINE LOAD_GENERIC_BLOCK(BL, IU, IOUT, LINE, END_KEY, END_NOT_FOUND, FOUND_BEGIN, BEGIN_OPTIONAL, NO_BACKSPACE, SKIP, NO_LOAD, ONLY_LOAD, SKIP_END_KEY )
    CLASS(GENERIC_BLOCK_READER),          INTENT(INOUT):: BL             ! DATA_TYPE THAT HOLDS BLOCK LINKED LIST
    INTEGER,                              INTENT(IN   ):: IU             ! UNIT NUMBER THAT BLOCK ORIGINATED FROM AND LOADED FROM. IF "LINE" IS NOT PROVDED OR "INTERNAL" KEYWORD IS FOUND, THEN BLOCK LOADS ON IU
    INTEGER,                    OPTIONAL, INTENT(IN   ):: IOUT           ! FILE TO WRITE ERROR INFORMATION TOO. SET TO ZERO TO NOT USE
    CHARACTER(*),               OPTIONAL, INTENT(INOUT):: LINE           ! LINE THAT HOLDS STARTING PART OF BLOCK, VIZ. "BEGIN BLOCKNAME". IF BEGIN IS FOUND, THEN BLOCK IS LOADED ON IU.
    CHARACTER(*),               OPTIONAL, INTENT(IN   ):: END_KEY        ! BLOCK TERMINATOR WORKD. IF NOT PROVIVED, THEN SET TO "END"
    LOGICAL,                    OPTIONAL, INTENT(  OUT):: END_NOT_FOUND  ! RETURNS TRUE ON ERROR WITH FINDING "END_KEY" (viz. reached end of file), IF NOT PRESENT THEN ERROR IS RAISED WHEN INPUT FINDS "BEGIN" BUT BLOCK FAILES TO FIND "END_KEY"
    LOGICAL,                    OPTIONAL, INTENT(  OUT):: FOUND_BEGIN    ! RETURNS TRUE IF THE KEYWORD BEGIN WAS FOUND. USED IN CASE THERE IS NO BL%NAME FOUND.
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: BEGIN_OPTIONAL ! IF TRUE THEN BLOCK WILL LOAD IRRELEVANT OF BEGIN BEING FOUND
    LOGICAL,                    OPTIONAL, INTENT(IN   ):: NO_BACKSPACE   ! IF PRESENT AND SET TRUE, A FAILED LOAD OF BLOCK DOES NOT BACKSPACE FILE UNIT. DEFAULT IS FALSE, WHEN NOT SPECIFIED
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: SKIP           ! ARRAY OF BLOCK NAMES TO NOT LOAD...IF FOUND, WILL AUTOMATICALLY SKIP TO END STATEMENT WITHOUT LOADING
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: NO_LOAD        ! ARRAY OF BLOCK NAMES TO NOT LOAD...IF FOUND, INPUT LINE STOPS AND MOVES BACK ONE LINE
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: ONLY_LOAD      ! ARRAY OF BLOCK NAMES THAT CAN BE LOADED, OTEHRWISE STOP LOAD
    CHARACTER(*), DIMENSION(:), OPTIONAL, INTENT(IN   ):: SKIP_END_KEY   ! ARRAY OF NAMES THAT IF PRESENT AFTER "END" RESULT IN "END" BEING IGNORED
    !CHARACTER(256):: FLAG
    INTEGER:: N,LLOC,ISTART,ISTOP!,EOL
    LOGICAL:: LOAD,EOF, ALLOW_BACK
    !
    IF(ALLOCATED(BL%NAME))    DEALLOCATE(BL%NAME)
    IF(ALLOCATED(BL%EXTRA))   DEALLOCATE(BL%EXTRA)
    !IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)  --DEALLOCATED IN SET_BLOCK_END_KEY
    !
    IF(PRESENT(IOUT)) THEN
        BL%IOUT=IOUT
    ELSE
        BL%IOUT=Z
    END IF
    !
    BL%IU=IU
    !
    IF(PRESENT(NO_BACKSPACE)) THEN
        ALLOW_BACK= .NOT. NO_BACKSPACE
    ELSE
        ALLOW_BACK = TRUE
    END IF
    !
    IF(PRESENT(LINE)) THEN
        IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
        BL%LN = ADJUSTL(LINE)
        N = COMMENT_INDEX(BL%LN)
        EOF=FALSE
    ELSE
        CALL READ_AND_SET_LINE(BL, IU, EOL=N, EOF=EOF)
    END IF
    !
    IF(PRESENT(BEGIN_OPTIONAL)) THEN
        LOAD = BEGIN_OPTIONAL
    ELSE
        LOAD = FALSE
    END IF
    !
    CALL SET_BLOCK_END_KEY(BL, END_KEY)
    !
    LLOC=ONE
    CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
    !
    IF(BL%LN(ISTART:ISTOP) == 'BEGIN') THEN
        CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
        BL%NAME = BL%LN(ISTART:ISTOP)
        !
        LOAD=TRUE
        IF(PRESENT(SKIP)) THEN
            IF(ANY(BL%NAME == SKIP)) THEN
                DO WHILE (LOAD)
                      CALL READ_AND_SET_LINE(BL, BL%IU, EOF=EOF)
                      IF(EOF.AND. .NOT.PRESENT(END_NOT_FOUND)) CALL STOP_ERROR(INFILE=BL%IU,OUTPUT=BL%IOUT,MSG='GENERIC BLOCK LOADER ERROR: REACHED THE END OF THE FILE BEFORE LOCATING THE KEYWORD TO CLOSE THE BLOCK.'//BLN//'THE BLOCK THAT WAS BEING LOADED IS "'//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO CLOSE/END THE BLOCK: "'//TRIM(BL%END_KEY)//'"'//BLN//'PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY CLOSED WITH THAT KEYWORD.')
                      LLOC=ONE
                      CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP,TRUE)
                      IF( BL%LN(ISTART:ISTOP)==BL%END_KEY) THEN
                                                               LOAD = FALSE
                                                               EOF  = FALSE
                      ELSEIF(EOF) THEN
                                                               LOAD = FALSE
                      END IF
                END DO
            END IF
        END IF
        IF(PRESENT(NO_LOAD)) THEN
            IF(ANY(BL%NAME == NO_LOAD)) THEN
                  BL%NAME = BLNK
                  IF(EOF) THEN; BL%EXTRA = 'NO_LOAD'
                  ELSE;         BL%EXTRA = 'NO_LOAD' !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
                  END IF
                  BL%NLINE = Z
                  IF(.NOT. PRESENT(LINE) .AND. ALLOW_BACK) BACKSPACE(IU)
                  IF(PRESENT(FOUND_BEGIN  )) FOUND_BEGIN   = FALSE
                  IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
                  RETURN
            END IF
        END IF
        IF(PRESENT(ONLY_LOAD)) THEN
            IF(.NOT. ANY(BL%NAME == ONLY_LOAD)) THEN
                  BL%NAME = BLNK
                  IF(EOF) THEN; BL%EXTRA = 'NO_LOAD'
                  ELSE;         BL%EXTRA = 'NO_LOAD' !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
                  END IF
                  BL%NLINE = Z
                  IF(.NOT. PRESENT(LINE) .AND. ALLOW_BACK) BACKSPACE(IU)
                  IF(PRESENT(FOUND_BEGIN  )) FOUND_BEGIN   = FALSE
                  IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
                  RETURN
            END IF
        END IF
        !
        IF(LOAD) THEN  !ONLY FALSE IF SKIP IS TRUE
           !
           !N =  COMMENT_INDEX(FLAG)                           !N = LEN_TRIM or INDEX(#)-1
           CALL PARSE_WORD(BL%LN,LLOC,ISTART,ISTOP)
           !
           IF(N - ISTART >= Z) THEN
               BL%EXTRA=BL%LN(ISTART:N)
           ELSE
               BL%EXTRA=BLNK
           END IF
           !
           CALL LOAD_INNER_GENERIC_BLOCK(BL, END_NOT_FOUND=END_NOT_FOUND, SKIP_END_KEY=SKIP_END_KEY)
           !
        ELSE !BLOCK WAS SKIPPED
           IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = BL%LN(ISTART:ISTOP).NE.BL%END_KEY
           IF(EOF) THEN;                   BL%EXTRA = 'EOF'
           ELSE;                           BL%EXTRA = BLNK !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
           END IF
        END IF
        !
        IF(PRESENT(FOUND_BEGIN)) FOUND_BEGIN = TRUE
        IF(PRESENT(LINE)       ) CALL READ_TO_DATA(LINE,IU,BL%IOUT)
        !
    ELSEIF(LOAD.AND. .NOT. PRESENT(LINE) ) THEN
        !
        BL%NAME = 'NO_BEGIN'
        BL%EXTRA=BLNK
        !
        BACKSPACE(IU)
        !
        CALL LOAD_INNER_GENERIC_BLOCK(BL, END_NOT_FOUND=END_NOT_FOUND, SKIP_END_KEY=SKIP_END_KEY)
        !
        IF(PRESENT(FOUND_BEGIN)) FOUND_BEGIN = FALSE
        IF(PRESENT(LINE)       ) CALL READ_TO_DATA(LINE,IU,BL%IOUT)
    ELSE
        IF(EOF) THEN
            BL%NAME  = BLNK
            BL%EXTRA = 'EOF'
        ELSE
            BL%NAME  = BL%LN(ISTART:ISTOP)
            BL%EXTRA = BLNK !TRIM(FLAG) --COULD DO THIS IF NECESSARY TO RETURN LINE LOADED
        END IF
        BL%NLINE = Z
        IF(.NOT. PRESENT(LINE) .AND. ALLOW_BACK) BACKSPACE(IU)
        IF(PRESENT(FOUND_BEGIN  )) FOUND_BEGIN   = FALSE
        IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
    END IF
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE LOAD_INNER_GENERIC_BLOCK(BL, END_KEY, IU, IOUT, END_NOT_FOUND, SKIP_END_KEY)
    CLASS(GENERIC_BLOCK_READER),         INTENT(INOUT):: BL
    CHARACTER(*),              OPTIONAL, INTENT(IN   ):: END_KEY
    INTEGER,                   OPTIONAL, INTENT(IN   ):: IU
    INTEGER,                   OPTIONAL, INTENT(IN   ):: IOUT
    LOGICAL,                   OPTIONAL, INTENT(OUT  ):: END_NOT_FOUND
    CHARACTER(*), DIMENSION(:),OPTIONAL, INTENT(IN   ):: SKIP_END_KEY ! ARRAY OF NAMES THAT IF PRESENT AFTER "END" RESULT IN "END" BEING IGNORED
    INTEGER:: N, EOL, LLOC, ISTART, ISTOP
    LOGICAL:: EOF_CHK
    CHARACTER(:), ALLOCATABLE:: END_CHECK, END_WORD
    CHARACTER(14):: TXT
    !
    IF(PRESENT(IU))   BL%IU  = IU
    IF(PRESENT(IOUT)) BL%IOUT= IOUT
    IF(PRESENT(END_NOT_FOUND)) END_NOT_FOUND = FALSE
    !
    IF(PRESENT(END_KEY)) THEN
                                       N = LEN_TRIM( ADJUSTL(END_KEY) ) + ONE
                                       ALLOCATE(CHARACTER(N):: END_WORD)
                                       END_WORD(:) = ADJUSTL(END_KEY)
                                       CALL UPPER(END_WORD)
    ELSEIF(ALLOCATED(BL%END_KEY)) THEN
                                       ALLOCATE(END_WORD, SOURCE=BL%END_KEY)
    ELSE
                                       ALLOCATE(END_WORD, SOURCE='END ')
    END IF
    !
    ALLOCATE(END_CHECK, SOURCE=END_WORD)  !PREALLOCATE TO GET CORRECT SIZE
    !
    CALL BL%LIST%INIT()
    !
    DO 
        CALL READ_AND_SET_LINE(BL, BL%IU, EOL, EOF_CHK)
        !
        END_CHECK(:) = BL%LN(:EOL)  !WITHOUT EOL COULD CAUSE END_CHECK='END#', BECAUSE ALLOCATABLE, HAVE TO INCLUDE (:)
        CALL UPPER(END_CHECK)
        !
        IF ( EOF_CHK .OR. (END_CHECK == END_WORD .AND. .NOT. PRESENT(SKIP_END_KEY))) EXIT    !BL%LN IS SET TO '' AT END OF FILE => EOF=TRUE
        !
        IF ( END_CHECK == END_WORD ) THEN  !SKIP_END_KEY must be present for this to be true
            !
            LLOC = LEN_TRIM(END_WORD) + ONE
            !
            CALL PARSE_WORD_UP(BL%LN(:EOL),LLOC,ISTART,ISTOP)
            !
            IF    (ISTOP < ISTART) THEN;                               EXIT
            ELSEIF( ALL(BL%LN(ISTART:ISTOP) .NE. SKIP_END_KEY) ) THEN; EXIT   !IF NOT TRUE THEN SECOND KEY FAILED. eg SKIP_END_KEY=[DO, WHERE, IF] would not exit if END IF, END DO, and END WHERE is found
            END IF
            !
        ENDIF
        !
        IF(LEN_TRIM(BL%LN(:EOL)) > TEN) THEN  !CHECK IF INCLUDE STATEMENT IS FOUND TO LOAD EXTERNAL FILE
                       TXT = BL%LN(:EOL)
                       CALL UPPER(TXT)
                       IF (TXT == 'BLOCK_INCLUDE ') THEN !FOUND BLOCK FILE KEYWORD, ADD SEPARATE FILE TO BLOCK
                           CALL BLOCK_INCLUDE_STATEMENT(BL, TXT, LLOC, EOL, N)
                       ELSE
                           CALL ADD_BLOCK_LINE(BL,EOL,N)
                       END IF
        ELSE
            CALL ADD_BLOCK_LINE(BL,EOL,N)
        END IF
        !
    END DO
    !
    IF(END_CHECK .NE. END_WORD) THEN
        IF(PRESENT(END_NOT_FOUND)) THEN
            END_NOT_FOUND = TRUE
            IF(EOF_CHK) BL%EXTRA = 'EOF'
        ELSE
            CALL STOP_ERROR(INFILE=BL%IU,OUTPUT=BL%IOUT,MSG='GENERIC BLOCK LOADER ERROR: THIS ROUTINE ATTEMPTED TO LOAD A "BEGIN BLOCK_NAME FOLLOWED BY INPUT AND THEN THE BLOCK IS ENDED WITH THE KEYWORD"'//TRIM(END_WORD)//'".'//NL//'HOWEVER THE BLOCK INPUT FAILED TO FIND THE ENDING KEYWORD AFTER THE BEGIN KEYWORD AND REACHED THE END OF THE FILE INSTEAD.'//BLN//'THE BLOCK THAT WAS BEING LOADED IS "BEGIN '//BL%NAME//'" AND WAS EXPECTING THE FOLLOWING KEYWORD TO END THE BLOCK: "'//TRIM(END_WORD)//'"'//BLN//'PLEASE CHECK INPUT TO ENSURE THAT THE BLOCK WAS PROPERLY ENDED WITH THAT KEYWORD.')
        END IF
    END IF
    !
    BL%NLINE = BL%LIST%LEN()
    !
  END SUBROUTINE
  !
  RECURSIVE SUBROUTINE BLOCK_INCLUDE_STATEMENT(BL, TXT, LLOC, EOL, N)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    CHARACTER(14),               INTENT(INOUT):: TXT
    INTEGER,                     INTENT(INOUT):: LLOC, EOL, N  ! TEMP VARIABLES
    LOGICAL:: EOF_CHK
    TYPE(GENERIC_INPUT_FILE):: FL
    !
    LLOC = 15
    CALL FL%OPEN(BL%LN, LLOC, BL%IOUT, BL%IU, NO_INTERNAL=TRUE, NO_CONSTANT=TRUE, NO_BINARY=TRUE)
    CALL READ_AND_SET_LINE(BL, FL%IU, EOL, EOF_CHK)
    !
    DO WHILE (.NOT. EOF_CHK)
        !
        IF(LEN_TRIM(BL%LN(:EOL)) > TEN) THEN  !CHECK IF INCLUDE STATEMENT IS FOUND TO LOAD EXTERNAL FILE
                       TXT = BL%LN(:EOL)
                       CALL UPPER(TXT)
                       IF (TXT == 'BLOCK_INCLUDE ') THEN
                           CALL BLOCK_INCLUDE_STATEMENT(BL, TXT, LLOC, EOL, N)
                       ELSE
                           CALL ADD_BLOCK_LINE(BL,EOL,N)
                       END IF
        ELSE
            CALL ADD_BLOCK_LINE(BL,EOL,N)
        END IF
        !
        CALL READ_AND_SET_LINE(BL, FL%IU, EOL, EOF_CHK)
    END DO
    !
    CALL FL%CLOSE()
    !
  END SUBROUTINE
  !
  SUBROUTINE ADD_BLOCK_LINE(BL,EOL,N)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,                     INTENT(IN   ):: EOL
    INTEGER,                     INTENT(OUT  ):: N
    !
    N = LEN_TRIM( BL%LN(1:EOL) ) + ONE      !ADD AN EXTRA SPACE FOR URWORD
    !
    IF(N <= BL%LINE_LEN) BL%LN(N:N) = ' '   !CLEAR OUT EXTRA SPACE FOR URWORD, OVER WRITES # IF LOCATED THERE
    !
    IF(N > BL%LINE_LEN) CALL STOP_ERROR(LINE=BL%LN,INFILE=BL%IU,OUTPUT=BL%IOUT,MSG='MODULE GENERIC_BLOCK_READER_INSTRUCTION ERROR: LINE SIZE OVERFLOW, MAX LINE SIZE IS SET TO '//NUM2STR(BL%LINE_LEN)//' CHARACTERS. PLEASE ENSURE THAT YOU COMMENT DATA THAT IS NOT LOADED INTO OneWater WITH A # SO IT IS NOT LOADED INTO MEMORY. OTHERWISE YOU MAY HAVE TO RECOMPILE CODE WITH A LARGER BLOCK INPUT "LINE_LEN" VALUE.')
    !
    CALL BL%LIST%ADD( BL%LN(1:N) )
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_BLOCK_END_KEY(BL, END_KEY)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    CHARACTER(*),      OPTIONAL, INTENT(IN   ):: END_KEY
    INTEGER:: N
    !
    IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)
    !
    IF(PRESENT(END_KEY)) THEN
                             N = LEN_TRIM( ADJUSTL(END_KEY) ) + ONE
                             ALLOCATE(CHARACTER(N):: BL%END_KEY)
                             BL%END_KEY(:) = ADJUSTL(END_KEY)
                             CALL UPPER(BL%END_KEY)
    ELSE
                             ALLOCATE(BL%END_KEY, SOURCE='END ')
    END IF
  END SUBROUTINE
  !
  PURE FUNCTION GET_BLOCK_NAME(BL) RESULT(NAME)
    CLASS(GENERIC_BLOCK_READER), INTENT(IN):: BL
    CHARACTER(:), ALLOCATABLE :: NAME
    !
    IF(ALLOCATED(BL%NAME)) THEN
        NAME = BL%NAME
    ELSE
        NAME = BLNK
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION GET_BLOCK_EXTRA(BL, POS, NO_UPPER) RESULT(EXTRA)
    CLASS(GENERIC_BLOCK_READER), INTENT(IN):: BL
    INTEGER,           OPTIONAL, INTENT(IN):: POS
    LOGICAL,           OPTIONAL, INTENT(IN):: NO_UPPER
    CHARACTER(:), ALLOCATABLE :: EXTRA
    INTEGER:: I, LLOC, ISTART, ISTOP
    !
    IF(ALLOCATED(BL%EXTRA)) THEN
        IF(PRESENT(POS)) THEN
            LLOC=ONE
            DO I=1, POS
                CALL PARSE_WORD(BL%EXTRA,LLOC,ISTART,ISTOP)
            END DO
            IF (ISTOP >= ISTART) THEN
                EXTRA = BL%EXTRA(ISTART:ISTOP)
            ELSE
                EXTRA = BLNK
            END IF
        ELSE
            EXTRA = BL%EXTRA
        END IF
    ELSE
        EXTRA = BLNK
    END IF
    !
    IF(PRESENT(NO_UPPER)) THEN
       IF(NO_UPPER) RETURN
    END IF
    !
    CALL UPPER(EXTRA)
    !
  END FUNCTION
  !
  PURE SUBROUTINE SET_BLOCK_LINE_LEN(BL,N)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,                     INTENT(IN   ):: N
    !
    IF(N > Z) THEN
        BL%LINE_LEN = N
    ELSE
        BL%LINE_LEN = 1250
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE UPDATE_BLOCK_NLINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    BL%NLINE = BL%LIST%LEN()
    !
  END SUBROUTINE
  !
  SUBROUTINE START_OF_BLOCK(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%START()
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE NEXT_BLOCK_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%NEXT()
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE MOVE_BACK_BLOCK_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%BACK()
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE SET_BLOCK_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  FUNCTION BLOCK_AT_END(BL) RESULT(IS_ASSOCIATED)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL:: IS_ASSOCIATED
    !
    IS_ASSOCIATED = .NOT. BL%LIST%IS_ASSOCIATED()
    !
  END FUNCTION
  !
  FUNCTION BLOCK_NOT_AT_END(BL) RESULT(IS_ASSOCIATED)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL:: IS_ASSOCIATED
    !
    IS_ASSOCIATED = BL%LIST%IS_ASSOCIATED()
    !
  END FUNCTION
  !
  SUBROUTINE INSERT_LINE_INTO_BLOCK(BL,LINE,POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    CHARACTER(*),    INTENT(IN):: LINE
    INTEGER,OPTIONAL,INTENT(IN):: POS
    !
    IF(PRESENT(POS)) THEN
                         CALL BL%LIST%ADD(LINE, POS)
    ELSE
                         CALL BL%LIST%ADD(LINE)
    END IF
    !
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    BL%NLINE = BL%LIST%LEN()
  END SUBROUTINE
  !
  SUBROUTINE DELETE_CURRENT_LINE(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%POP(Z)
    BL%NLINE = BL%NLINE - ONE
    !
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE REMOVE_LINE_AT(BL,POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER, OPTIONAL, INTENT(IN):: POS
    INTEGER:: N
    !
    N=BL%LIST%GETPOS()
    IF(PRESENT(POS)) THEN ; IF(POS<N) N=N-1
    ENDIF
    CALL BL%LIST%POP(POS)
    BL%NLINE = BL%LIST%LEN()
    CALL BL%LIST%POS(N)
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  !
  FUNCTION GET_LINE_POS(BL) RESULT(POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(IN):: BL
    INTEGER:: POS
    !
    POS=BL%LIST%GETPOS()
    !
  END FUNCTION
  !
  SUBROUTINE GOTO_LINE_POS(BL, POS)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER, INTENT(IN):: POS
    !
    CALL BL%LIST%POS(POS)
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE GOTO_BLOCK_END(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%POS(-1)  !Move to last line in block
    CALL BL%LIST%SET_LN()
    BL%LINE => BL%LIST%LN
    !
  END SUBROUTINE
  !
  SUBROUTINE MAKE_SCRATCH_FILE_START(BL, FROM_START)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL, OPTIONAL, INTENT(IN):: FROM_START
    INTEGER:: I, ORIG_POS
    LOGICAL:: START
    !
    ORIG_POS = BL%LIST%GETPOS()
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH, IOSTAT=I)
       BL%SCRATCH = Z
    !
    START = TRUE
    IF(PRESENT(FROM_START)) START = FROM_START
    !
    IF(START) CALL BL%LIST%START()
    !
    CALL BL%LIST%SET_LN()
    CALL GENERIC_SCRATCH_FILE(BL%SCRATCH, BL%IOUT, BUFFER_BLOCKSIZE=32768, LINE=BL%LIST%LN, INFILE=BL%IU)  !BUFF=1MB, block should not ever be bigger than this...so scartch file will remain in RAM for faster reading.
    DO I=BL%LIST%GETPOS(), BL%NLINE
          !
          WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
          IF(  BL%LIST%LN=='ERROR' ) EXIT
          CALL BL%LIST%NEXT()
          CALL BL%LIST%SET_LN()
    END DO
    !
    REWIND(BL%SCRATCH)
    !
    CALL GOTO_LINE_POS(BL, ORIG_POS)
    !
  END SUBROUTINE
  !
  ! ISTART is the starting line; set to 0 to use current line
  ! ISTOP is the ending    line; set to 0 to use last line
  SUBROUTINE MAKE_SCRATCH_FILE_SUBFILE(BL, ISTART, ISTOP)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,           INTENT(IN):: ISTART
    INTEGER,           INTENT(IN):: ISTOP
    INTEGER:: I, ORIG_POS, ISTR, ISTP
    !
    ORIG_POS = BL%LIST%GETPOS()
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH, IOSTAT=I)
       BL%SCRATCH = Z
    !
    CALL GOTO_LINE_POS(BL, ISTART)
    ISTR = BL%LIST%GETPOS()
    !
    IF(ISTOP .NE. Z .AND. ISTOP < BL%NLINE) THEN
        CALL GOTO_LINE_POS(BL, ISTOP)
        ISTP = BL%LIST%GETPOS()
        CALL GOTO_LINE_POS(BL, ISTR)
    ELSE
        ISTP = BL%NLINE
    END IF
    !
    CALL GENERIC_SCRATCH_FILE(BL%SCRATCH, BL%IOUT, BUFFER_BLOCKSIZE=32768, LINE=BL%LIST%LN, INFILE=BL%IU)  !BUFF=1MB, block should not ever be bigger than this...so scartch file will remain in RAM for faster reading.
    !
    DO I=ISTR, ISTP
          !
          WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
          IF(  BL%LIST%LN=='ERROR' ) EXIT
          CALL BL%LIST%NEXT()
          CALL BL%LIST%SET_LN()
    END DO
    !
    REWIND(BL%SCRATCH)
    !
    CALL GOTO_LINE_POS(BL, ORIG_POS)
    !
  END SUBROUTINE
  !
  SUBROUTINE MAKE_SCRATCH_FILE_RELATIVE(BL, NLINE_PRINT, KEEP_POSITION)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,                     INTENT(IN):: NLINE_PRINT
    LOGICAL,           OPTIONAL, INTENT(IN):: KEEP_POSITION
    INTEGER:: I, ORIG_POS
    LOGICAL:: KEEP_POS
    !
    ORIG_POS = BL%LIST%GETPOS()
    !
    KEEP_POS=FALSE
    IF(PRESENT(KEEP_POSITION)) KEEP_POS=KEEP_POSITION
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH, IOSTAT=I)
       BL%SCRATCH = Z
    !
    CALL GENERIC_SCRATCH_FILE(BL%SCRATCH, BL%IOUT, BUFFER_BLOCKSIZE=32768, LINE=BL%LIST%LN, INFILE=BL%IU)  !BUFF=1MB, block should not ever be bigger than this...so scartch file will remain in RAM for faster reading.
    !
    CALL BL%LIST%SET_LN()
    WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
    DO I=ONE, NLINE_PRINT-ONE
          CALL BL%LIST%NEXT()
          CALL BL%LIST%SET_LN()
          IF(  BL%LIST%LN=='ERROR' ) EXIT
          !
          WRITE(BL%SCRATCH, '(A)') BL%LIST%LN
    END DO
    !
    REWIND(BL%SCRATCH)
    !
    IF(KEEP_POS) CALL GOTO_LINE_POS(BL, ORIG_POS)
    !
  END SUBROUTINE
  !
  SUBROUTINE READ_SCRATCH_LINE(BL, ERROR, LINE)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL,      OPTIONAL,      INTENT(OUT  ):: ERROR
    CHARACTER(*), OPTIONAL,      INTENT(OUT  ):: LINE
    INTEGER:: IERR
    !
    IERR = Z
    !
    IF(PRESENT(LINE)) THEN
                          IF(BL%SCRATCH.NE.Z) THEN
                              READ(BL%SCRATCH, '(A)' , IOSTAT=IERR) LINE
                              IF(IERR .NE. Z) LINE = BLNK
                          ELSE
                              LINE = BLNK
                          END IF
    ELSE
                          IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
                          !
                          IF(BL%SCRATCH.NE.Z) THEN
                              READ(BL%SCRATCH, '(A)' , IOSTAT=IERR) BL%LN
                          ELSE
                              BL%LN = BLNK
                          END IF
    END IF
    !
    IF(PRESENT(ERROR)) ERROR = IERR .NE. Z
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_LN(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
  END SUBROUTINE
  !
  SUBROUTINE READ_AND_SET_LINE(BL, IU, EOL, EOF)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,           INTENT(IN ):: IU
    INTEGER, OPTIONAL, INTENT(OUT):: EOL
    LOGICAL, OPTIONAL, INTENT(OUT):: EOF
    !
    IF(.NOT. ALLOCATED(BL%LN)) ALLOCATE( CHARACTER(BL%LINE_LEN):: BL%LN )
    !
    CALL READ_TO_DATA(BL%LN,IU,BL%IOUT,EOL=EOL,EOF=EOF)
    !
  END SUBROUTINE
  !
  SUBROUTINE INIT_GENERIC_BLOCK(BL, IU, IOUT, LINE_LEN)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    INTEGER,           OPTIONAL, INTENT(IN   ):: IU, IOUT, LINE_LEN
    !
    CALL BL%LIST%INIT()
    BL%LINE_LEN = 1250
    BL%NLINE = Z
    BL%IOUT  = Z
    BL%IU    = Z
    BL%LINE => NULL()
    !
    IF(PRESENT(IU))       BL%IU       = IU 
    IF(PRESENT(IOUT))     BL%IOUT     = IOUT
    IF(PRESENT(LINE_LEN)) BL%LINE_LEN = LINE_LEN
    !
    IF(ALLOCATED(BL%NAME))    DEALLOCATE(BL%NAME)
    IF(ALLOCATED(BL%EXTRA))   DEALLOCATE(BL%EXTRA)
    IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH)
       BL%SCRATCH = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE CLOSE_SCRATCH_GENERIC_BLOCK(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH)
       BL%SCRATCH = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE DEALLOCATE_GENERIC_BLOCK(BL)
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL BL%LIST%DESTROY()
    BL%NLINE = Z
    BL%IOUT  = Z
    BL%IU    = Z
    BL%LINE => NULL()
    !
    IF(ALLOCATED(BL%LN))      DEALLOCATE(BL%LN)
    IF(ALLOCATED(BL%NAME))    DEALLOCATE(BL%NAME)
    IF(ALLOCATED(BL%EXTRA))   DEALLOCATE(BL%EXTRA)
    IF(ALLOCATED(BL%END_KEY)) DEALLOCATE(BL%END_KEY)
    !
    IF(BL%SCRATCH.NE.Z) CLOSE(BL%SCRATCH)
       BL%SCRATCH = Z
    !
  END SUBROUTINE
  !
  SUBROUTINE FINAL_DEALLOCATE_GENERIC_BLOCK(BL)
    TYPE(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    !
    CALL DEALLOCATE_GENERIC_BLOCK(BL)
    !
    BL%LINE_LEN = 1250
    !
    IF(ALLOCATED(BL%LN))  DEALLOCATE(BL%LN)
    !
  END SUBROUTINE
  !
END MODULE
!
!