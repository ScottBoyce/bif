
!
MODULE NAME_ID_INTERFACE
  !SE CONSTANTS
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  IMPLICIT NONE
  !
  PRIVATE
  PUBLIC:: NAME_ID, ID_TYPE_BASE
  ! 
  ! Constants used internally to module ----------------------------------------------------
  ! 
  INTEGER,  PARAMETER:: inf_I = HUGE(0)
  ! 
  ! ----------------------------------------------------------------------------------------
  ! 
  TYPE ID_TYPE_BASE
      INTEGER,                          ALLOCATABLE:: IVAL
      INTEGER, DIMENSION(:),            ALLOCATABLE:: IVEC
      INTEGER, DIMENSION(:,:),          ALLOCATABLE:: IARR
      DOUBLE PRECISION,                 ALLOCATABLE:: DVAL
      DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE:: DVEC
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: DARR
  END TYPE
  !
  TYPE NAME_ID
      INTEGER:: N = 0
      CHARACTER(20),     DIMENSION(:), ALLOCATABLE:: NAM
      TYPE(ID_TYPE_BASE),DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      PROCEDURE, PASS(TYP):: INIT         =>         ALLOC_NAME_ID_TYPE  !(DIM)
      PROCEDURE, PASS(TYP):: SET_NAM      =>       SET_NAM_NAME_ID_TYPE  !(POS, NAM)
      PROCEDURE, PASS(TYP):: SET_ID_ALLOC =>  SET_ID_ALLOC_NAME_ID_TYPE  !(POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
      PROCEDURE, PASS(TYP):: ALLOC_ID     =>      ALLOC_ID_NAME_ID_TYPE  !DEFINE DIM instead => (POS, IVAL, IVEC, IARR1, IARR2, DVAL, DVEC, DARR1, DARR2)
      GENERIC             :: SET_ID       => SET_ID_BY_POS_NAME_ID_TYPE, & !(NAM, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
                                             SET_ID_BY_NAM_NAME_ID_TYPE    !(POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
      PROCEDURE, PASS(TYP):: NAM_POS => GET_NAM_POS_NAME_ID_TYPE           !(NAM) 
      PROCEDURE, PASS(TYP):: GET_ID  => GET_ID_BY_NAM_NAME_ID_TYPE         !(NAM, ERR_IVAL, ERR_DVAL, IVAL, IVEC, IARR, DVAL, DVEC, DARR)
      PROCEDURE, PASS(TYP):: DESTROY => DESTROY_NAME_ID_TYPE         
      
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_BY_POS_NAME_ID_TYPE 
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_BY_NAM_NAME_ID_TYPE
      !
      FINAL:: FINAL_NAME_ID_TYPE
  END TYPE
  !
  CONTAINS
  !
  ELEMENTAL PURE SUBROUTINE FINAL_NAME_ID_TYPE(TYP)   
    TYPE(NAME_ID), INTENT(INOUT):: TYP
    CALL DESTROY_NAME_ID_TYPE(TYP)   
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE DESTROY_NAME_ID_TYPE(TYP)   
    CLASS(NAME_ID), INTENT(INOUT):: TYP
    TYP%N = 0
    IF(ALLOCATED(TYP%NAM)) DEALLOCATE(TYP%NAM)
    IF(ALLOCATED(TYP%PT )) DEALLOCATE(TYP%PT )
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_NAME_ID_TYPE(TYP, DIM) !Allocate %NAM and %PT    
    CLASS(NAME_ID), INTENT(INOUT):: TYP
    INTEGER,        INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%NAM)) DEALLOCATE(TYP%NAM)
    IF(ALLOCATED(TYP%PT )) DEALLOCATE(TYP%PT )
    !
    IF(DIM > 0) THEN
                  ALLOCATE(TYP%NAM(DIM))
                  ALLOCATE(TYP%PT (DIM))
                  TYP%N = DIM
    ELSE
                  TYP%N = 0
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_NAM_NAME_ID_TYPE(TYP, POS, NAM)  !SET %NAM 
    CLASS(NAME_ID), INTENT(INOUT):: TYP
    INTEGER,        INTENT(IN   ):: POS
    CHARACTER(*),   INTENT(IN   ):: NAM
    !
    TYP%NAM(POS) = NAM
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_NAM_POS_NAME_ID_TYPE(TYP, NAM) RESULT(POS)  !RETURN NAME POSITION
    CLASS(NAME_ID), INTENT(IN):: TYP
    CHARACTER(*),   INTENT(IN):: NAM
    INTEGER:: POS
    INTEGER:: I
    !
    POS = 0
    DO I=1, TYP%N
                   IF(NAM == TYP%NAM(POS)) THEN
                                                  POS = I
                                                  EXIT
                   END IF
    END DO
    !
  END FUNCTION
  !
  PURE SUBROUTINE SET_ID_ALLOC_NAME_ID_TYPE(TYP, POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR) !ALLOC and SET %PT 
    CLASS(NAME_ID),                             INTENT(INOUT):: TYP
    INTEGER,                                    INTENT(IN):: POS
    INTEGER,                          OPTIONAL, INTENT(IN):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(IN):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(IN):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(IN):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(IN):: DARR
    !
    ASSOCIATE(PT => TYP%PT(POS))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) DEALLOCATE(PT%IVAL); ALLOCATE(PT%IVAL, SOURCE=IVAL); END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) DEALLOCATE(PT%IVEC); ALLOCATE(PT%IVEC, SOURCE=IVEC); END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) DEALLOCATE(PT%IARR); ALLOCATE(PT%IARR, SOURCE=IARR); END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) DEALLOCATE(PT%DVAL); ALLOCATE(PT%DVAL, SOURCE=DVAL); END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) DEALLOCATE(PT%DVEC); ALLOCATE(PT%DVEC, SOURCE=DVEC); END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) DEALLOCATE(PT%DARR); ALLOCATE(PT%DARR, SOURCE=DARR); END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_NAME_ID_TYPE(TYP, POS, IVAL, IVEC, IARR1, IARR2, DVAL, DVEC, DARR1, DARR2) ! ALLOC %PT
    CLASS(NAME_ID),      INTENT(INOUT):: TYP
    INTEGER,             INTENT(IN):: POS
    INTEGER, OPTIONAL,   INTENT(IN):: IVAL
    INTEGER, OPTIONAL,   INTENT(IN):: IVEC
    INTEGER, OPTIONAL,   INTENT(IN):: IARR1, IARR2
    INTEGER, OPTIONAL,   INTENT(IN):: DVAL
    INTEGER, OPTIONAL,   INTENT(IN):: DVEC
    INTEGER, OPTIONAL,   INTENT(IN):: DARR1, DARR2
    !
    ASSOCIATE(PT => TYP%PT(POS))
       !
       IF(PRESENT(IVAL )) THEN; IF(.NOT. ALLOCATED(PT%IVAL))                ALLOCATE(PT%IVAL);              END IF
       IF(PRESENT(IVEC )) THEN; IF(ALLOCATED(PT%IVEC)) DEALLOCATE(PT%IVEC); ALLOCATE(PT%IVEC(IVEC));        END IF
       IF(PRESENT(IARR1)) THEN; IF(ALLOCATED(PT%IARR)) DEALLOCATE(PT%IARR); ALLOCATE(PT%IARR(IARR1,IARR2)); END IF
       IF(PRESENT(DVAL )) THEN; IF(.NOT. ALLOCATED(PT%DVAL))                ALLOCATE(PT%DVAL);              END IF
       IF(PRESENT(DVEC )) THEN; IF(ALLOCATED(PT%DVEC)) DEALLOCATE(PT%DVEC); ALLOCATE(PT%DVEC(DVEC));        END IF
       IF(PRESENT(DARR1)) THEN; IF(ALLOCATED(PT%DARR)) DEALLOCATE(PT%DARR); ALLOCATE(PT%DARR(DARR1,DARR2)); END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ID_BY_POS_NAME_ID_TYPE(TYP, POS, IVAL, IVEC, IARR, DVAL, DVEC, DARR)  ! SET %PT 
    CLASS(NAME_ID),                             INTENT(INOUT)::TYP
    INTEGER,                                    INTENT(IN):: POS
    INTEGER,                          OPTIONAL, INTENT(IN):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(IN):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(IN):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(IN):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(IN):: DARR
    !
    ASSOCIATE(PT => TYP%PT(POS))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) PT%IVAL = IVAL; END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) PT%IVEC = IVEC; END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) PT%IARR = IARR; END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) PT%DVAL = DVAL; END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) PT%DVEC = DVEC; END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) PT%DARR = DARR; END IF
    END ASSOCIATE
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ID_BY_NAM_NAME_ID_TYPE(TYP, NAM, IVAL, IVEC, IARR, DVAL, DVEC, DARR)  ! SET %PT 
    CLASS(NAME_ID),                             INTENT(INOUT)::TYP
    CHARACTER(*),                               INTENT(IN):: NAM
    INTEGER,                          OPTIONAL, INTENT(IN):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(IN):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(IN):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(IN):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(IN):: DARR
    INTEGER:: I
    !
    DO I=1, TYP%N
    IF(NAM == TYP%NAM(I)) THEN
    ASSOCIATE(PT => TYP%PT(I))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) PT%IVAL = IVAL; END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) PT%IVEC = IVEC; END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) PT%IARR = IARR; END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) PT%DVAL = DVAL; END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) PT%DVEC = DVEC; END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) PT%DARR = DARR; END IF
    END ASSOCIATE
    EXIT
    END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE GET_ID_BY_NAM_NAME_ID_TYPE(TYP, NAM, ERR_IVAL, ERR_DVAL, IVAL, IVEC, IARR, DVAL, DVEC, DARR)  ! GET %PT 
    CLASS(NAME_ID),                             INTENT(IN):: TYP
    CHARACTER(*),                               INTENT(IN):: NAM
    INTEGER,                          OPTIONAL, INTENT(IN):: ERR_IVAL
    DOUBLE PRECISION,                 OPTIONAL, INTENT(IN):: ERR_DVAL
    INTEGER,                          OPTIONAL, INTENT(INOUT):: IVAL
    INTEGER, DIMENSION(:),            OPTIONAL, INTENT(INOUT):: IVEC
    INTEGER, DIMENSION(:,:),          OPTIONAL, INTENT(INOUT):: IARR
    DOUBLE PRECISION,                 OPTIONAL, INTENT(INOUT):: DVAL
    DOUBLE PRECISION, DIMENSION(:),   OPTIONAL, INTENT(INOUT):: DVEC
    DOUBLE PRECISION, DIMENSION(:,:), OPTIONAL, INTENT(INOUT):: DARR
    INTEGER:: I
    DOUBLE PRECISION:: NaN
    !
    IF(PRESENT(ERR_IVAL)) THEN
                          IF(PRESENT(IVAL)) IVAL = ERR_IVAL
                          IF(PRESENT(IVEC)) IVEC = ERR_IVAL
                          IF(PRESENT(IARR)) IARR = ERR_IVAL
    ELSE                  
                          IF(PRESENT(IVAL)) IVAL = inf_I
                          IF(PRESENT(IVEC)) IVEC = inf_I
                          IF(PRESENT(IARR)) IARR = inf_I
    END IF
    !
    IF(PRESENT(ERR_DVAL)) THEN
                          IF(PRESENT(DVAL)) DVAL = ERR_DVAL
                          IF(PRESENT(DVEC)) DVEC = ERR_DVAL
                          IF(PRESENT(DARR)) DARR = ERR_DVAL
    ELSE     
                          NaN = IEEE_VALUE(NaN, IEEE_QUIET_NAN)
                          !           
                          IF(PRESENT(DVAL)) DVAL = NaN
                          IF(PRESENT(DVEC)) DVEC = NaN
                          IF(PRESENT(DARR)) DARR = NaN
    END IF
    !
    DO I=1, TYP%N
    IF(NAM == TYP%NAM(I)) THEN
    ASSOCIATE(PT => TYP%PT(I))
       !
       IF(PRESENT(IVAL)) THEN; IF(ALLOCATED(PT%IVAL)) IVAL = PT%IVAL; END IF
       IF(PRESENT(IVEC)) THEN; IF(ALLOCATED(PT%IVEC)) IVEC = PT%IVEC; END IF
       IF(PRESENT(IARR)) THEN; IF(ALLOCATED(PT%IARR)) IARR = PT%IARR; END IF
       IF(PRESENT(DVAL)) THEN; IF(ALLOCATED(PT%DVAL)) DVAL = PT%DVAL; END IF
       IF(PRESENT(DVEC)) THEN; IF(ALLOCATED(PT%DVEC)) DVEC = PT%DVEC; END IF
       IF(PRESENT(DARR)) THEN; IF(ALLOCATED(PT%DARR)) DARR = PT%DARR; END IF
    END ASSOCIATE
    EXIT
    END IF
    END DO
    !
  END SUBROUTINE
  !
  !!!!PURE SUBROUTINE EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
  !!!!  CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
  !!!!  INTEGER,            INTENT(IN   ):: ID
  !!!!  DOUBLE PRECISION,   INTENT(IN   ):: VAL
  !!!!  TYPE (ID_VAL_TYPE):: EXT
  !!!!  !
  !!!!  TYP%INUSE = TRUE
  !!!!  !
  !!!!  IF(TYP%N == 0) THEN
  !!!!                TYP%N = 1
  !!!!                !
  !!!!                ALLOCATE( TYP%PT(TYP%N) )
  !!!!                TYP%PT(TYP%N)%ID = ID;   TYP%PT(TYP%N)%VAL = VAL
  !!!!  ELSE
  !!!!                EXT%N = TYP%N + 1
  !!!!                !
  !!!!                ALLOCATE( EXT%PT (EXT%N) )
  !!!!                EXT%PT(:TYP%N)  = TYP%PT
  !!!!                !
  !!!!                EXT%PT(EXT%N)%ID = ID;   EXT%PT(EXT%N)%VAL = VAL
  !!!!                !
  !!!!                CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
  !!!!                TYP%N = EXT%N
  !!!!  END IF
  !!!!END SUBROUTINE
  !

END MODULE
!
!