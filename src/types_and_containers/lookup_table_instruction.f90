!
!   LOOKUP_TABLE_INSTRUCTION
!                           DATA TYPE
!                                    LOOKUP_TABLE_TYPE
!                           SUBROUTINES
!                                    LOOKUP_BY_NAME      
!                                    TB%LOAD
!                                    TB%LOOKUP
! 
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! MODULE LOOKUP_TABLE_INSTRUCTION   ==>  USE LOOKUP_TABLE_INSTRUCTION, ONLY: LOOKUP_TABLE_TYPE, LOOKUP_BY_NAME
!
!  LOOKUP_TABLE_TYPE IS DATA TYPE THAT HOLDS LOOKUP TABLE AND LOOKUP FUNCTIONS
!  LOOKUP_BY_NAME IS A FUNCTION PROVIDED TO ASSIST IN MULTIPLE TABLE LOOKUPS.
!      DESIGNED FOR TYPE(LOOKUP_TABLE_TYPE), DIMENSION(:):: TABLES 
!      AND EACH TABLE HAS A UNIQUE NAME, TABLENAM, SO FOR A GIVEN X:
!                 Y = LOOKUP_BY_NAME(TABLES, TABLENAM, X) 
!
!  LOOKUP_TABLE_TYPE PROVIDES BASE DATA TYPE FOR TWO COLUMN LOOK UP TABLES.
!  COLUMN 1 CALLED X
!  COLUMN 2 CALLED Y
!
!  TABLE INPUT IS LOADED WITH LOAD SUBROUTINE
!  TYPE(LOOKUP_TABLE_TYPE):: TAB
!  CALL TAB%LOAD(LLOC,ISTART,ISTOP,LINE,IU,IOUT)
!  WHERE LINE WOULD CONTAIN:  
!       TABNAM  [INTERPOLATE|STEP_FUNCTION|NEAREST] COUNT  GENERIC_INPUT
! OR    TABNAM  [INTERP     |STEP         |NEAR   ] COUNT  GENERIC_INPUT
!
!  LOOKUP IS BASED ON REQUESTED X VALUE AND RETURNS Y. 
!  Y IS SET TO NaN IF THERE IS ANY PROBLEM WITH LOOKUP.
!
!  VALUE OF Y CAN BE EITHER AN INTERPOLATED VALUE, NEAREST VALUE, OR STEP FUNCTION (BASED ON INPUT KEYWORD IN [])
!
!  VERSION 1.0 [6/23/2017] ORIGINAL VERSION 
!
!  MODULE DEPENDENCIES:
!                      CONSTANTS
!                      UTIL_INTERFACE 
!                      GENERIC_INPUT_FILE_INSTRUCTION
!                      GENERIC_BLOCK_READER_INSTRUCTION   ==> ONLY REQUIRED IF USING BLOCKS TO LOAD TABLEFILE...CAN COMMENT OUT
!
MODULE LOOKUP_TABLE_INSTRUCTION
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE CONSTANTS
  USE POST_KEY_SUB,                      ONLY: CHECK_FOR_POST_KEY
  USE FILE_IO_INTERFACE,                 ONLY: READ_TO_DATA
  USE PARSE_WORD_INTERFACE,              ONLY: PARSE_WORD_UP
  USE STRINGS,                           ONLY: GET_INTEGER, GET_NUMBER, GET_DOUBLE_DATE
  USE ERROR_INTERFACE,                   ONLY: STOP_ERROR
  USE NUM2STR_INTERFACE,                 ONLY: NUM2STR
  USE GENERIC_INPUT_FILE_INSTRUCTION,    ONLY: GENERIC_INPUT_FILE
  USE GENERIC_BLOCK_READER_INSTRUCTION,  ONLY: GENERIC_BLOCK_READER
  USE DATE_OPERATOR_INSTRUCTION,         ONLY: DATE_OPERATOR
  USE SORT_INTERFACE ! SORT(DIM1,ARR) or SORT(DIM1,DIM2,ARR,COL)
  IMPLICIT NONE
  PRIVATE
  PUBLIC:: LOOKUP_TABLE_TYPE, LOOKUP_BY_NAME
  !
  INTERFACE LOOKUP_BY_NAME ! (TAB,TABNAM,X,[OPTION]) RESULT(Y)
     !
     MODULE PROCEDURE GET_LOOKUP_TABLE_BY_NAME       
     MODULE PROCEDURE GET_LOOKUP_TABLE_BY_NAME_SINGLE
     !
  END INTERFACE
  !
  TYPE MID_CHECK
      DOUBLE PRECISION:: XMID
      INTEGER::          IMID
  END TYPE
  !
  TYPE LOOKUP_TABLE_TYPE
      INTEGER:: N  = Z    ! SIZE OF X, Y
      INTEGER:: OPT= Z    ! OPT => 0=INTERP; 1=STEP, 2=NEAR
      CHARACTER(:), ALLOCATABLE:: NAM
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: X,Y
      !
      TYPE(MID_CHECK),ALLOCATABLE:: MD
      !
      CONTAINS
      !
      GENERIC::                       LOAD   => LOAD_LOOKUP_TABLE_BLOCK, LOAD_LOOKUP_TABLE_FILE, LOAD_LOOKUP_TABLE_VALUE
      !
      PROCEDURE, PASS(TAB)::          LOOKUP => GET_LOOKUP_TABLE_VALUE_SUB        ! (X,Y,[OPTION])
      GENERIC::                       GET    => GET_LOOKUP_TABLE_VALUE,         & ! (X,[OPTION]) RESULT(Y)
                                                GET_LOOKUP_TABLE_BY_NAME_SINGLE   ! (TABNAM,X,[OPTION]) RESULT(Y)
      PROCEDURE, PASS(TAB)::          MOVE   => MOVE_LOOKUP_TABLE!(TAB,TAB2)
      PROCEDURE, PASS(TAB)::          COPY   => COPY_LOOKUP_TABLE!(TAB,TAB2)
      PROCEDURE, PASS(TAB), PRIVATE:: LOAD_LOOKUP_TABLE_BLOCK ! (LLOC,ISTART,ISTOP,BL,LOAD_NAME,[NO_INTERNAL])  
      PROCEDURE, PASS(TAB), PRIVATE:: LOAD_LOOKUP_TABLE_FILE  ! (LLOC,ISTART,ISTOP,LINE,IU,IOUT,LOAD_NAME,[NO_INTERNAL],[SKIP_VAL])
      PROCEDURE, PASS(TAB), PRIVATE:: LOAD_LOOKUP_TABLE_VALUE ! (VAL, [NAM])
      PROCEDURE, PASS(TAB), PRIVATE:: GET_LOOKUP_TABLE_VALUE
      PROCEDURE, PASS(TAB), PRIVATE:: GET_LOOKUP_TABLE_VALUE_SUB
      PROCEDURE, PASS(TAB), PRIVATE:: GET_LOOKUP_TABLE_BY_NAME_SINGLE ! (TAB,TABNAM,X,[OPTION]) RESULT(Y)
      PROCEDURE, PASS(TAB)::          DESTROY => DEALLOCATE_LOOKUP_TABLE
      FINAL:: FINAL_DEALLOCATE_LOOKUP_TABLE
  END TYPE
  !
  CONTAINS
  !
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_LOOKUP_TABLE(TAB)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
    IF(ALLOCATED(TAB%NAM)) DEALLOCATE(TAB%NAM)
    IF(ALLOCATED(TAB%X  )) DEALLOCATE(TAB%X  )
    IF(ALLOCATED(TAB%Y  )) DEALLOCATE(TAB%Y  )
    IF(ALLOCATED(TAB%MD )) DEALLOCATE(TAB%MD )
    TAB%N   = Z
    TAB%OPT = Z
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_LOOKUP_TABLE(TAB,TAB2)  !COULD ADD SPEED OPTIMIZERS for TAB2%N==TAB%N
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB,TAB2
    !
    CALL DEALLOCATE_LOOKUP_TABLE(TAB2)
    !
    TAB2%N   = TAB%N
    TAB2%OPT = TAB%OPT
    IF(ALLOCATED(TAB%NAM)) ALLOCATE(TAB2%NAM, SOURCE = TAB%NAM)
    IF(ALLOCATED(TAB%X  )) CALL MOVE_ALLOC(TAB%X,  TAB2%X )
    IF(ALLOCATED(TAB%Y  )) CALL MOVE_ALLOC(TAB%Y,  TAB2%Y )
    IF(ALLOCATED(TAB%MD )) CALL MOVE_ALLOC(TAB%MD, TAB2%MD)
    !
    CALL DEALLOCATE_LOOKUP_TABLE(TAB)
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_LOOKUP_TABLE(TAB,TAB2)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(IN   ):: TAB
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB2
    !
    CALL DEALLOCATE_LOOKUP_TABLE(TAB2)
    !
    TAB2%N   = TAB%N
    TAB2%OPT = TAB%OPT
    IF(ALLOCATED(TAB%NAM)) ALLOCATE(TAB2%NAM, SOURCE = TAB%NAM)
    IF(ALLOCATED(TAB%X  )) ALLOCATE( TAB2%X , SOURCE = TAB%X  )
    IF(ALLOCATED(TAB%Y  )) ALLOCATE( TAB2%Y , SOURCE = TAB%Y  )
    IF(ALLOCATED(TAB%MD )) ALLOCATE( TAB2%MD, SOURCE = TAB%MD )
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_LOOKUP_TABLE(TAB)
    TYPE(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
    CALL DEALLOCATE_LOOKUP_TABLE(TAB)
  END SUBROUTINE
  !
  FUNCTION GET_LOOKUP_TABLE_VALUE(TAB,X,OPTION) RESULT(Y)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(IN):: TAB
    DOUBLE PRECISION,         INTENT(IN):: X
    INTEGER, OPTIONAL,        INTENT(IN):: OPTION
    DOUBLE PRECISION:: Y
    !
    ! OPTION = 0 INTERPOLATE
    ! OPTION = 1 STEP_FUNCTION
    ! OPTION = 2 NEAREST VALUE
    !
    CALL GET_LOOKUP_TABLE_VALUE_SUB(TAB,X,Y,OPTION)
    !
    !!!SELECT CASE (OPT)
    !!!CASE(Z);     Y = TAB%Y(N) + (X - TAB%X(N)) * (TAB%Y(N+1)-TAB%Y(N)) / (TAB%X(N+1)-TAB%X(N))
    !!!CASE(ONE);   Y = TAB%Y(N)
    !!!CASE(TWO)
    !!!         IF( X - TAB%X(N) > TAB%X(N+1) - X) THEN
    !!!             Y = TAB%Y(N+1)
    !!!         ELSE
    !!!             Y = TAB%Y(N)
    !!!         END IF
    !!!END SELECT
  END FUNCTION
  !
  PURE SUBROUTINE GET_LOOKUP_TABLE_VALUE_SUB(TAB,X,Y,OPTION)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(IN   ):: TAB
    DOUBLE PRECISION,         INTENT(IN   ):: X
    DOUBLE PRECISION,         INTENT(  OUT):: Y
    INTEGER, OPTIONAL,        INTENT(IN   ):: OPTION
    INTEGER:: N, OPT, P
    !
    ! OPTION = 0 INTERPOLATE
    ! OPTION = 1 STEP_FUNCTION
    ! OPTION = 2 NEAREST VALUE
    !
    OPT = TAB%OPT
    IF(PRESENT(OPTION)) OPT = OPTION
    !
    IF(TAB%N == Z) THEN
            !
            Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)  ! NO VALUES IN LOOKUP TABLE!!!
            !
    ELSEIF(X <= TAB%X(ONE) .OR. TAB%N == ONE) THEN
        !
        IF(TAB%N > ONE .AND. OPT==Z) THEN
            Y = TAB%Y(ONE) + (X - TAB%X(ONE)) * (TAB%Y(TWO)-TAB%Y(ONE)) / (TAB%X(TWO)-TAB%X(ONE))
        ELSE
            Y = TAB%Y(ONE)
        END IF
    ELSEIF( X >= TAB%X(TAB%N) ) THEN
        !
        N = TAB%N
        IF(OPT==Z) THEN
            Y = TAB%Y(N-1) + (X - TAB%X(N-1)) * (TAB%Y(N)-TAB%Y(N-1)) / (TAB%X(N)-TAB%X(N-1))
        ELSE
            Y = TAB%Y(N)
        END IF
    ELSE
        !
        P = TWO
        !
        IF(TAB%N > 39) THEN;  IF (X > TAB%MD%XMID) P = TAB%MD%IMID  !HALF CHECK SPEED UP
        END IF
        !
        DO N=P, TAB%N
            IF(X < TAB%X(N)) THEN
                                 P = N - ONE
                                 EXIT
            END IF
        END DO
        !
        IF    (OPT == Z  ) THEN;  Y = TAB%Y(P) + (X - TAB%X(P)) * (TAB%Y(P+1)-TAB%Y(P)) / (TAB%X(P+1)-TAB%X(P))
        ELSEIF(OPT == ONE) THEN;  Y = TAB%Y(P)
        ELSEIF(OPT == TWO) THEN 
                              IF( X - TAB%X(P) >= TAB%X(P+1) - X) THEN !True if closer to next point
                                  Y = TAB%Y(P+1)
                              ELSE
                                  Y = TAB%Y(P)
                              END IF
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !!!PURE SUBROUTINE GET_LOOKUP_TABLE_VALUE_SUB(TAB,X,Y,OPTION)
  !!!  CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
  !!!  DOUBLE PRECISION,         INTENT(IN   ):: X
  !!!  DOUBLE PRECISION,         INTENT(  OUT):: Y
  !!!  INTEGER, OPTIONAL,        INTENT(IN   ):: OPTION
  !!!  INTEGER:: N, OPT, P
  !!!  !
  !!!  ! OPTION = 0 INTERPOLATE
  !!!  ! OPTION = 1 STEP_FUNCTION
  !!!  ! OPTION = 2 NEAREST VALUE
  !!!  !
  !!!  OPT = TAB%OPT
  !!!  IF(PRESENT(OPTION)) OPT = OPTION
  !!!  !
  !!!  IF(TAB%N == Z) THEN
  !!!          !
  !!!          Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)  ! NO VALUES IN LOOKUP TABLE!!!
  !!!          !
  !!!  ELSEIF(X <= TAB%X(ONE) .OR. TAB%N == ONE) THEN
  !!!      !
  !!!      IF(TAB%N > ONE .AND. OPT==Z) THEN
  !!!          Y = TAB%Y(ONE) + (X - TAB%X(ONE)) * (TAB%Y(TWO)-TAB%Y(ONE)) / (TAB%X(TWO)-TAB%X(ONE))
  !!!      ELSE
  !!!          Y = TAB%Y(ONE)
  !!!      END IF
  !!!  ELSEIF( X >= TAB%X(TAB%N) ) THEN
  !!!      !
  !!!      N = TAB%N
  !!!      IF(OPT==Z) THEN
  !!!          Y = TAB%Y(N-1) + (X - TAB%X(N-1)) * (TAB%Y(N)-TAB%Y(N-1)) / (TAB%X(N)-TAB%X(N-1))
  !!!      ELSE
  !!!          Y = TAB%Y(N)
  !!!      END IF
  !!!  ELSE
  !!!      !
  !!!      IF(TAB%P >= 50) THEN   ! SPEED UP IF PREVIOUS SEARCH IS >50 INDEX AND NEW SEARCH WITHIN 10 LEVELS OF IT
  !!!          P = TAB%P - TEN
  !!!          IF (X < TAB%X(P)) P = TWO
  !!!      ELSE
  !!!          P = TWO
  !!!      END IF
  !!!      !
  !!!      DO N=P, TAB%N
  !!!          IF(X < TAB%X(N)) THEN
  !!!                               TAB%P = N - ONE
  !!!                               EXIT
  !!!          END IF
  !!!      END DO
  !!!      !
  !!!      N = TAB%P
  !!!      !
  !!!      IF    (OPT == Z  ) THEN;  Y = TAB%Y(N) + (X - TAB%X(N)) * (TAB%Y(N+1)-TAB%Y(N)) / (TAB%X(N+1)-TAB%X(N))
  !!!      ELSEIF(OPT == ONE) THEN;  Y = TAB%Y(N)
  !!!      ELSEIF(OPT == TWO) THEN 
  !!!                            IF( X - TAB%X(N) >= TAB%X(N+1) - X) THEN !True if closer to next point
  !!!                                Y = TAB%Y(N+1)
  !!!                            ELSE
  !!!                                Y = TAB%Y(N)
  !!!                            END IF
  !!!      END IF
  !!!  END IF
  !!!  !
  !!!END SUBROUTINE
  !
  SUBROUTINE LOAD_LOOKUP_TABLE_BLOCK(TAB,LLOC,ISTART,ISTOP,BL,LOAD_NAME,NO_INTERNAL,SKIP_VAL)  !ASSUMES THAT LLOC IS SET AND RAN "CALL BL%LIST%SET_LN()"  -- THAT IS BL IS LOCATED AT CORRECT LINE
    CLASS(LOOKUP_TABLE_TYPE),    INTENT(INOUT):: TAB
    INTEGER,                     INTENT(INOUT):: LLOC,ISTART,ISTOP
    CLASS(GENERIC_BLOCK_READER), INTENT(INOUT):: BL
    LOGICAL,                     INTENT(IN   ):: LOAD_NAME
    LOGICAL, OPTIONAL,           INTENT(IN   ):: NO_INTERNAL
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN   ):: SKIP_VAL
    TYPE(GENERIC_INPUT_FILE):: FL
    TYPE(DATE_OPERATOR):: DATE
    DOUBLE PRECISION:: X, Y, SFAC
    INTEGER:: I, N, OPT
    LOGICAL:: EOF
    !
    SFAC    = UNO
    !
    IF(LOAD_NAME) THEN
       CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
       !
       ALLOCATE(TAB%NAM, SOURCE = BL%LINE(ISTART:ISTOP))
    ELSE
       ALLOCATE(TAB%NAM, SOURCE = 'Null')
    END IF
    !
    CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
    !
    SELECT CASE(BL%LINE(ISTART:ISTOP))
    CASE('CONSTANT');                OPT = NEG
    CASE('INTERP','INTERPOLATE'   ); OPT = Z
    CASE('STEP','STEP_FUNCTION'   ); OPT = ONE
    CASE('NEAR','NEAREST'         ); OPT = TWO
    CASE('SKIP','NULL','NUL','NAN'); OPT = NEG2
    CASE DEFAULT;                    CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: YOU MUST SPECIFY KEYWORD "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", "CONSTANT", OR "SKIP" AFTER THE TABLE NAME.') 
    END SELECT 
    !
    IF(OPT==NEG2) THEN
        !
        IF(.NOT. PRESENT(SKIP_VAL))  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "'//BL%LINE(ISTART:ISTOP)//'" BUT THIS LOOKUP TABLE DOES NOT SUPPORT THAT OPTION. PLEASE CHANGE TO "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", OR "CONSTANT".') 
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, SKIP_VAL, TAB%NAM)
        !
        RETURN
        !
    ELSEIF(OPT==NEG) THEN
        !
        CALL GET_DOUBLE_DATE(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,X,DATE,MSG='LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "CONSTANT", BUT FAILED TO LOAD THE CONSTANT VALUE', ONLY_DYEAR=TRUE)
        !
        CALL CHECK_FOR_POST_KEY(LLOC, BL%LINE, BL%IU, BL%IOUT, I, N, SCALE=Y)
        X = X*Y
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, X, TAB%NAM)
        !
        RETURN
    END IF
    !
    TAB%OPT = OPT
    !
    CALL GET_INTEGER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,N,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD COUNT OF LOOK UP TABLE (NUMBER OF ROWS). A VALUE LESS THAN ONE, WILL TRIGGER AN AUTO-COUNT, BUT YOU STILL MUST SPECIFIY AN INTEGER AS A PLACE HOLDER.')
    IF (N<Z) N=Z
    !
    CALL FL%OPEN(BL%LINE,LLOC,BL%IOUT,BL%IU)
    !
    IF(FL%NULL_FILE) THEN
        !
        IF(.NOT. PRESENT(SKIP_VAL))  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "'//BL%LINE(ISTART:ISTOP)//'" BUT THIS LOOKUP TABLE DOES NOT SUPPORT THAT OPTION. PLEASE CHANGE TO "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", OR "CONSTANT".') 
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, SKIP_VAL, TAB%NAM)
        !
        RETURN
        !
    ELSEIF(FL%IS_CONSTANT) THEN
        !
        FL%CONST = FL%CONST*FL%SCALE
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, FL%CONST, TAB%NAM)
        !
        RETURN
    END IF
    !
    IF(FL%BINARY .AND. N < ONE)  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE READ FROM A BINARY FILE, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH ASCII/UNICODE/TEXT (viz. human readible) FILES.')
    !
    IF(PRESENT(NO_INTERNAL)) THEN
            IF(NO_INTERNAL .AND. FL%IS_INTERNAL)  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE ERROR: THIS INPUT LOCATION FOR A LOOK UP TABLE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE INSTEAD USE "OPEN/CLOSE" OR "EXTERNAL".')
    END IF
    !
    IF(FL%IS_INTERNAL) THEN
         !
         IF(N < ONE)  CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE KEYWORD INTERNAL, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH "OPEN/CLOSE" OR "EXTERNAL", NOT "INTERNAL".')
         !
         DO I=ONE, N
             CALL BL%NEXT()
             LLOC = ONE
             CALL PARSE_WORD_UP(BL%LINE,LLOC,ISTART,ISTOP)
             IF( BL%LINE(ISTART:ISTOP) == 'SFAC' ) THEN
                 !
                 CALL GET_NUMBER(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                 !
                 IF(X.NE.UNO) SFAC = SFAC*X
             ELSE
                 EXIT
             END IF
         END DO
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(BL%LINE,LLOC,ISTART,ISTOP,BL%IOUT,BL%IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=BL%LINE, INFILE=BL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL BL%NEXT()
         END DO
    ELSE
         IF(N==Z .AND. .NOT. FL%BINARY) THEN
             CALL FL%REWIND()
             DO
                   CALL READ_TO_DATA(BL%LN, FL%IU, BL%IOUT, EOF=EOF)
                   IF(EOF) EXIT
                   LLOC=ONE
                   CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
                   !
                   IF( BL%LN(ISTART:ISTOP) .NE. 'SFAC' ) THEN
                       LLOC = ISTART
                       CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,X,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                       CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,Y,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                       IF(X.NE.X .OR. Y.NE.Y) THEN
                           EXIT
                       ELSE
                           N=N+ONE
                       END IF
                   END IF
             END DO
             CALL FL%REWIND()
         END IF
         !
         IF(N==Z)  CALL STOP_ERROR(INFILE=FL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FILE THAT CONTAINED LOOKUP TABLE TTHAT WAS EMPTY OR THERE WAS A FAILURE TO LOAD ANY OF THE INFORMATION WITHIN THE LOOKUP TABLE (eg BAD DATA).')
         !
         IF(.NOT. FL%BINARY) THEN
           DO I=ONE, N
               CALL READ_TO_DATA(BL%LN, FL%IU, BL%IOUT)
               LLOC = ONE
               CALL PARSE_WORD_UP(BL%LN,LLOC,ISTART,ISTOP)
               IF( BL%LN(ISTART:ISTOP) == 'SFAC' ) THEN
                   !
                   CALL GET_NUMBER(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                   !
                   IF(X.NE.UNO) SFAC = SFAC*X
               ELSE
                   EXIT
               END IF
           END DO
         END IF
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         !
         IF(FL%BINARY) THEN
             DO N=ONE, TAB%N
                 READ(FL%IU) TAB%X(N), TAB%Y(N)
             END DO
         ELSE
             DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(BL%LN,LLOC,ISTART,ISTOP,BL%IOUT,FL%IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD BLOCK ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=BL%LN, INFILE=FL%IU, OUTPUT=BL%IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL READ_TO_DATA(BL%LN, FL%IU, BL%IOUT)
             END DO
         END IF
    END IF
    !
    IF(FL%SCALE.NE.UNO) TAB%Y = TAB%Y * FL%SCALE
    IF(SFAC    .NE.UNO) TAB%Y = TAB%Y * SFAC
    !
    CALL CHECK_ASCENDING_ORDER(TAB)
    !
    IF(TAB%N > 39) THEN
        ALLOCATE(TAB%MD)
        TAB%MD%IMID = TAB%N/2
        TAB%MD%XMID = TAB%X(TAB%MD%IMID-ONE)
    END IF
    !
  END SUBROUTINE
  !
  SUBROUTINE LOAD_LOOKUP_TABLE_FILE(TAB,LLOC,ISTART,ISTOP,LINE,IU,IOUT,LOAD_NAME,NO_INTERNAL,SKIP_VAL)
    CLASS(LOOKUP_TABLE_TYPE),    INTENT(INOUT):: TAB
    INTEGER,                     INTENT(INOUT):: LLOC,ISTART,ISTOP
    CHARACTER(*),                INTENT(INOUT):: LINE
    INTEGER,                     INTENT(IN   ):: IU, IOUT
    LOGICAL,                     INTENT(IN   ):: LOAD_NAME
    LOGICAL,          OPTIONAL,  INTENT(IN   ):: NO_INTERNAL
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN   ):: SKIP_VAL
    TYPE(GENERIC_INPUT_FILE):: FL
    TYPE(DATE_OPERATOR):: DATE
    DOUBLE PRECISION:: X, Y, SFAC
    INTEGER:: I, N, OPT
    LOGICAL:: EOF
    !
    SFAC    = UNO
    !
    IF(LOAD_NAME) THEN
       CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
       !
       ALLOCATE(TAB%NAM, SOURCE = LINE(ISTART:ISTOP))
    ELSE
       ALLOCATE(TAB%NAM, SOURCE = 'Null')
    END IF
    !
    CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
    !
    SELECT CASE(LINE(ISTART:ISTOP))
    CASE('CONSTANT');                OPT = NEG
    CASE('INTERP','INTERPOLATE'   ); OPT = Z
    CASE('STEP','STEP_FUNCTION'   ); OPT = ONE
    CASE('NEAR','NEAREST'         ); OPT = TWO
    CASE('SKIP','NULL','NUL','NAN'); OPT = NEG2
    CASE DEFAULT;                    CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: YOU MUST SPECIFY KEYWORD "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", "CONSTANT", OR "SKIP" AFTER THE TABLE NAME.') 
    END SELECT
    !
    IF(OPT==NEG2) THEN
        !
        IF(.NOT. PRESENT(SKIP_VAL))  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "'//LINE(ISTART:ISTOP)//'" BUT THIS LOOKUP TABLE DOES NOT SUPPORT THAT OPTION. PLEASE CHANGE TO "INTERPOLATE", OR "STEP_FUNCTION", "NEAREST", OR "CONSTANT".') 
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, SKIP_VAL, TAB%NAM)
        !
        RETURN
        !
    ELSEIF(OPT==NEG) THEN
        !
        CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,IU,X,DATE,MSG='LOOKUP TABLE LOAD ERROR: FOUND KEYWORD "CONSTANT", BUT FAILED TO LOAD THE CONSTANT VALUE', ONLY_DYEAR=TRUE)
        !
        CALL LOAD_LOOKUP_TABLE_VALUE(TAB, X, TAB%NAM)
        !
        RETURN
    END IF
    !
    TAB%OPT = OPT
    !
    CALL GET_INTEGER(LINE,LLOC,ISTART,ISTOP,IOUT,IU,N,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD COUNT OF LOOK UP TABLE (NUMBER OF ROWS). A VALUE LESS THAN ONE, WILL TRIGGER AN AUTO-COUNT, BUT YOU STILL MUST SPECIFIY AN INTEGER AS A PLACE HOLDER.')
    IF (N<Z) N=Z
    !
    CALL FL%OPEN(LINE,LLOC,IOUT,IU)
    !
    IF(FL%BINARY .AND. N < ONE)  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE READ FROM A BINARY FILE, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH ASCII/UNICODE/TEXT (viz. human readible) FILES.')
    !
    IF(PRESENT(NO_INTERNAL)) THEN
            IF(NO_INTERNAL .AND. FL%IS_INTERNAL)  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE ERROR: THIS INPUT LOCATION FOR A LOOK UP TABLE DOES NOT ALLOW FOR THE "INTERNAL" KEYWORD. PLEASE INSTEAD USE "OPEN/CLOSE" OR "EXTERNAL".')
    END IF
    !
    IF(FL%IS_INTERNAL) THEN
         !
         IF(N < ONE)  CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE ERROR: IF YOU USE KEYWORD INTERNAL, YOU MUST PROVIDE THE NUMBER OF ENTRIES IN TABLE (COUNT). SETTING THE NUMBER TO LESS THAN ONE WILL AUTO-COUNT, BUT THIS ONLY WORKS WITH "OPEN/CLOSE" OR "EXTERNAL", NOT "INTERNAL".')
         !
         DO I=ONE, N
             CALL READ_TO_DATA(LINE, IU, IOUT)
             LLOC = ONE
             CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
             IF( LINE(ISTART:ISTOP) == 'SFAC' ) THEN
                 !
                 CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,IOUT,IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                 !
                 IF(X.NE.UNO) SFAC = SFAC*X
             ELSE
                 EXIT
             END IF
         END DO
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=LINE, INFILE=IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL READ_TO_DATA(LINE, IU, IOUT)
         END DO
    ELSE
         IF(N==Z .AND. .NOT. FL%BINARY) THEN
             CALL FL%REWIND()
             DO
                   CALL READ_TO_DATA(LINE, FL%IU, IOUT, EOF=EOF)
                   IF(EOF) EXIT
                   LLOC=ONE
                   CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
                   !
                   IF( LINE(ISTART:ISTOP) .NE. 'SFAC' ) THEN
                         LLOC = ISTART
                         CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,X,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                         CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,Y,DATE,MSG='NOSTOP', ONLY_DYEAR=TRUE)
                         IF(X.NE.X .OR. Y.NE.Y) THEN
                             EXIT
                         ELSE
                             N=N+ONE
                         END IF
                   END IF
             END DO
             CALL FL%REWIND()
         END IF
         !
         IF(N==Z)  CALL STOP_ERROR(INFILE=FL%IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: FILE THAT CONTAINED LOOKUP TABLE TTHAT WAS EMPTY OR THERE WAS A FAILURE TO LOAD ANY OF THE INFORMATION WITHIN THE LOOKUP TABLE (eg BAD DATA).')
         !
         IF(.NOT. FL%BINARY) THEN
           DO I=ONE, N
               CALL READ_TO_DATA(LINE, FL%IU, IOUT)
               LLOC = ONE
               CALL PARSE_WORD_UP(LINE,LLOC,ISTART,ISTOP)
               IF( LINE(ISTART:ISTOP) == 'SFAC' ) THEN
                   !
                   CALL GET_NUMBER(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,X,MSG='FAILED TO SCALE FACTOR AFTER READING "SFAC" KEYWORD.')
                   !
                   IF(X.NE.UNO) SFAC = SFAC*X
               ELSE
                   EXIT
               END IF
           END DO
         END IF
         !
         TAB%N = N
         ALLOCATE(TAB%X(N), TAB%Y(N))
         !
         IF(FL%BINARY) THEN
             DO I=ONE, TAB%N
                 READ(FL%IU) TAB%X(I), TAB%Y(I)
             END DO
             !
             DO I=TWO, TAB%N
                   IF(TAB%X(I-ONE) > TAB%X(I)) THEN
                                               CALL STOP_ERROR( INFILE=FL%IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                   END IF
             END DO
         ELSE
             DO I=ONE, N
                    LLOC=ONE
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,TAB%X(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD FIRST  VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    CALL GET_DOUBLE_DATE(LINE,LLOC,ISTART,ISTOP,IOUT,FL%IU,TAB%Y(I),DATE,MSG='LOOKUP TABLE LOAD ERROR: FAILED TO LOAD SECOND VALUE ON LINE IN TABLE', ONLY_DYEAR=TRUE)
                    !
                    IF(I>ONE) THEN
                         IF(TAB%X(I-ONE) > TAB%X(I)) CALL STOP_ERROR( LINE=LINE, INFILE=FL%IU, OUTPUT=IOUT, MSG= 'LOOKUP TABLE LOAD ERROR: THE LOOKUP COLUMN MUST BE IN ASCENDING ORDER.') 
                    END IF
                    !
                    IF(I < N) CALL READ_TO_DATA(LINE, FL%IU, IOUT)
             END DO
         END IF
    END IF
    !
    IF(FL%SCALE.NE.UNO) TAB%Y = TAB%Y * FL%SCALE
    IF(SFAC    .NE.UNO) TAB%Y = TAB%Y * SFAC
    !
    !CALL CHECK_ASCENDING_ORDER(TAB)
    !
    IF(TAB%N > 39) THEN
        ALLOCATE(TAB%MD)
        TAB%MD%IMID = TAB%N/2
        TAB%MD%XMID = TAB%X(TAB%MD%IMID-ONE)
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE LOAD_LOOKUP_TABLE_VALUE(TAB, VAL, NAM)  !SET TO SINGLE VALUE
    CLASS(LOOKUP_TABLE_TYPE),    INTENT(INOUT):: TAB
    DOUBLE PRECISION,            INTENT(IN   ):: VAL
    CHARACTER(*),    OPTIONAL,   INTENT(IN   ):: NAM
    !
    IF(PRESENT(NAM)) THEN
        IF(ALLOCATED(TAB%NAM)) THEN
                               IF(TAB%NAM.NE.NAM) TAB%NAM=NAM
        ELSE
            TAB%NAM = NAM  
        END IF
    ELSE
            TAB%NAM = NUM2STR(VAL)
    END IF
    !
    TAB%N   = ONE
    TAB%OPT = ONE
    ALLOCATE(TAB%X(ONE), TAB%Y(ONE), SOURCE=VAL)
    !
  END SUBROUTINE
  !
  SUBROUTINE CHECK_ASCENDING_ORDER(TAB)
     CLASS(LOOKUP_TABLE_TYPE),      INTENT(INOUT):: TAB
     INTEGER:: I
     !
     IF(TAB%N>ONE) THEN
           DO I=ONE, TAB%N-ONE
                 IF(TAB%X(I) > TAB%X(I+ONE)) THEN
                                             CALL SORT(TAB%X,TAB%Y)
                                             EXIT
                 END IF
           END DO
     END IF
     !
  END SUBROUTINE
  !
  FUNCTION GET_LOOKUP_TABLE_BY_NAME(TAB,TABNAM,X,OPTION) RESULT(Y)
    CLASS(LOOKUP_TABLE_TYPE), DIMENSION(:), CONTIGUOUS, INTENT(INOUT):: TAB
    CHARACTER(*),                                       INTENT(IN   ):: TABNAM
    DOUBLE PRECISION,                                   INTENT(IN   ):: X
    INTEGER, OPTIONAL,                                  INTENT(IN   ):: OPTION
    DOUBLE PRECISION:: Y
    INTEGER:: I, NTAB
    !
    NTAB = SIZE(TAB)
    DO I=ONE, NTAB
        IF(TABNAM == TAB(I)%NAM) EXIT
        IF(I==NTAB)  NTAB = Z
    END DO
    !
    IF (NTAB > Z ) THEN
                       Y = GET_LOOKUP_TABLE_VALUE(TAB(I),X,OPTION)
    ELSE
                       Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  FUNCTION GET_LOOKUP_TABLE_BY_NAME_SINGLE(TAB,TABNAM,X,OPTION) RESULT(Y)
    CLASS(LOOKUP_TABLE_TYPE), INTENT(INOUT):: TAB
    CHARACTER(*),             INTENT(IN   ):: TABNAM
    DOUBLE PRECISION,         INTENT(IN   ):: X
    INTEGER, OPTIONAL,        INTENT(IN   ):: OPTION
    DOUBLE PRECISION:: Y
    !
    IF ( TABNAM == TAB%NAM ) THEN
                       Y = GET_LOOKUP_TABLE_VALUE(TAB,X,OPTION)
    ELSE
                       Y = IEEE_VALUE(Y, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
END MODULE
!
!