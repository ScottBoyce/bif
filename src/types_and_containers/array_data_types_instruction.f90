!
! CODE DEVELOPED BY SCOTT E BOYCE 
!                   CONTACT <seboyce@usgs.gov> or <Boyce@engineer.com>
!
! Types:
!       CHARACTER_TYPE
!       CHARACTER_TYPE_ARRAY
!
!       CHARACTER_ARRAY  
!
!        DOUBLE_VECTOR
!       INTEGER_VECTOR
!       LOGICAL_VECTOR
!
!        DOUBLE_MATRIX  
!       INTEGER_MATRIX
!
!       COMPRESSED_VALUE_STORAGE
!       COMPRESSED_LOCATION_STORAGE
!
!       ID_VAL_TYPE    
!
!               RAT_VOL_BASE
!               RAT_VOL_TYPE     
!            ID_RAT_VOL_TYPE     
!       ID1_ID2_RAT_VOL_TYPE
!
MODULE ARRAY_DATA_TYPES!, ONLY: INTEGER_VECTOR, DOUBLE_VECTOR, INTEGER_MATRIX, DOUBLE_MATRIX, LOGICAL_VECTOR, CHARACTER_TYPE, CHARACTER_TYPE_ARRAY, CHARACTER_ARRAY, COMPRESSED_VALUE_STORAGE
  USE, INTRINSIC:: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
  USE, INTRINSIC:: ISO_FORTRAN_ENV, ONLY: INT32, INT64, SNG => REAL32, DBL => REAL64
  !USE CONSTANTS
  IMPLICIT NONE(TYPE, EXTERNAL)
  !
  PUBLIC:: JOIN_CHAR
  PUBLIC:: LEN, LEN_TRIM, SIZE
  PUBLIC:: CHARACTER_TYPE, CHARACTER_TYPE_ARRAY
  PUBLIC:: CHARACTER_BUF_TYPE
  PUBLIC:: CHARACTER_ARRAY
  PUBLIC:: INTEGER_VECTOR, DOUBLE_VECTOR, LOGICAL_VECTOR
  PUBLIC:: INTEGER_MATRIX, DOUBLE_MATRIX
  PUBLIC:: COMPRESSED_VALUE_STORAGE
  PUBLIC:: COMPRESSED_LOCATION_STORAGE
  PUBLIC:: RAT_VOL_TYPE, RAT_VOL_BASE
  PUBLIC:: ID_VAL_TYPE            ! ADD, SET_, GET_
  PUBLIC:: ID_RAT_VOL_TYPE        ! ADD, SET_, GET_, CALC_
  PUBLIC:: ID1_ID2_RAT_VOL_TYPE   ! ADD, SET_, GET_, CALC_
  !
  PRIVATE
  !
  ! Constants used internally to module ----------------------------------------------------
  ! 
  CHARACTER, PARAMETER :: BLNK  = ' '
  CHARACTER, PARAMETER :: NL    = NEW_LINE(BLNK)
  LOGICAL,   PARAMETER :: TRUE  = .TRUE.
  LOGICAL,   PARAMETER :: FALSE = .FALSE.
  INTEGER,   PARAMETER :: NINER = -999
  INTEGER,   PARAMETER :: NEG   = -1
  INTEGER,   PARAMETER :: Z     = 0
  INTEGER,   PARAMETER :: ONE   = 1
  INTEGER,   PARAMETER :: TWO   = 2
  INTEGER,   PARAMETER :: inf_I = HUGE(Z)
  CHARACTER(*), PARAMETER:: lowerCHAR="abcdefghijklmnopqrstuvwxyz"
  CHARACTER(*), PARAMETER:: upperCHAR="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  !
  ! ----------------------------------------------------------------------------------------
  ! 
  INTERFACE JOIN_CHAR
     MODULE PROCEDURE  JOIN_TXT_CHAR     ! JOIN_CHAR(TXT,JOIN,[ENDING])
     MODULE PROCEDURE  JOIN_TXT_CHAR_TYP
     MODULE PROCEDURE  JOIN_TXT_CHAR_ARR
  END INTERFACE
  !
  ! ----------------------------------------------------------------------------------------
  ! 
  INTERFACE LEN
     MODULE PROCEDURE LEN_CHARACTER_TYPE
  END INTERFACE
  !
  INTERFACE LEN_TRIM
     MODULE PROCEDURE LEN_TRIM_CHARACTER_TYPE
  END INTERFACE
  !
  INTERFACE SIZE
     MODULE PROCEDURE SIZE_CHARACTER_TYPE_ARRAY
  END INTERFACE
  !
  ! ----------------------------------------------------------------------------------------
  !
  TYPE CHARACTER_TYPE
      CHARACTER(:), ALLOCATABLE::STR
      !
      CONTAINS
      !
      PROCEDURE, PASS(CH) :: SET       => ALLOCATE_CHARACTER_TYPE           ! CALL CH%SET      (LINE)
      PROCEDURE, PASS(CH) :: LENGTH    => LEN_CHARACTER_TYPE                ! CH%LENGTH()
      PROCEDURE, PASS(CH) :: GET       => GET_CHARACTER_TYPE                ! CALL CH%GET      ()
      PROCEDURE, PASS(CH) :: ADD       => ADD_TO_ENDING_CHARACTER_TYPE      ! CALL CH%ADD      (LINE)
      PROCEDURE, PASS(CH) :: ADD_TRIM  => TRIM_ADD_TO_ENDING_CHARACTER_TYPE ! CALL CH%ADD_TRIM (LINE)
      PROCEDURE, PASS(CH) :: ADD_BEGIN => ADD_TO_BEGIN_CHARACTER_TYPE       ! CALL CH%ADD_BEGIN(LINE)
      GENERIC ::             POP       => REMOVE_LAST_CHARACTER,           &! CALL CH%POP()
                                          REMOVE_SPECIFIED_CHARACTER,      &! CALL CH%POP(P)
                                          REMOVE_SPECIFIED_RANGE_CHARACTER  ! CALL CH%POP(P1,P2)
                                          !                   
      PROCEDURE, PASS(CH) :: WRITE     => WRITE_CHARACTER_TYPE              ! CALL CH%WRITE  (IU, FMT)
      PROCEDURE, PASS(CH) :: MOVE      => MOVE_CHARACTER_TYPE               ! CALL CH%MOVE   (CH_OUT)
      PROCEDURE, PASS(CH) :: DESTROY   => DESTROY_CHARACTER_TYPE            ! CALL CH%DESTROY(CH_OUT)
      !                   
      GENERIC             :: ASSIGNMENT(=) => COPY_CHARACTER_TYPE_OPERATOR, SET_CHARACTER_TYPE_OPERATOR
      GENERIC             :: OPERATOR(==)  => COMPARE_CHARACTER_TYPE, COMPARE_CHARACTER_TYPE_STR
      GENERIC             :: OPERATOR(/=)  => NOT_EQUAL_CHARACTER_TYPE, NOT_EQUAL_CHARACTER_TYPE_STR
      GENERIC             :: OPERATOR(+)   =>    ADD_CHARACTER_TYPE,    ADD_CHARACTER_TYPE_STR,    ADD_STR_CHARACTER_TYPE
      GENERIC             :: OPERATOR(//)  => CONCAT_CHARACTER_TYPE, CONCAT_CHARACTER_TYPE_STR, CONCAT_STR_CHARACTER_TYPE
      !                   
      PROCEDURE,           PRIVATE :: COPY_CHARACTER_TYPE_OPERATOR
      PROCEDURE,           PRIVATE :: SET_CHARACTER_TYPE_OPERATOR
      PROCEDURE,           PRIVATE :: COMPARE_CHARACTER_TYPE
      PROCEDURE,           PRIVATE :: COMPARE_CHARACTER_TYPE_STR
      PROCEDURE,           PRIVATE :: NOT_EQUAL_CHARACTER_TYPE
      PROCEDURE,           PRIVATE :: NOT_EQUAL_CHARACTER_TYPE_STR
      PROCEDURE,           PRIVATE :: CONCAT_CHARACTER_TYPE
      PROCEDURE,           PRIVATE :: CONCAT_CHARACTER_TYPE_STR
      PROCEDURE, PASS(CH), PRIVATE :: CONCAT_STR_CHARACTER_TYPE
      PROCEDURE,           PRIVATE :: ADD_CHARACTER_TYPE
      PROCEDURE,           PRIVATE :: ADD_CHARACTER_TYPE_STR
      PROCEDURE, PASS(CH), PRIVATE :: ADD_STR_CHARACTER_TYPE
      PROCEDURE, PASS(CH), PRIVATE :: REMOVE_SPECIFIED_CHARACTER
      PROCEDURE, PASS(CH), PRIVATE :: REMOVE_SPECIFIED_RANGE_CHARACTER
      PROCEDURE, PASS(CH), PRIVATE :: REMOVE_LAST_CHARACTER
  END TYPE
  !
  !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ! 
  TYPE CHARACTER_TYPE_ARRAY
      INTEGER, PRIVATE:: N   = Z
      INTEGER, PRIVATE:: DIM = Z
      TYPE(CHARACTER_TYPE), DIMENSION(:), ALLOCATABLE:: VEC
      !
      CONTAINS
      !
      PROCEDURE, PASS(CH) :: INIT    => INITIALIZE_CHARACTER_TYPE_ARRAY      ! %INIT([DIM])
      PROCEDURE, PASS(CH) :: GET     => GET_CHARACTER_TYPE_ARRAY             ! %GET(POS)
      GENERIC ::             POP     => REMOVE_LAST_POSITION,     &          ! %POP([LINE])      -> LINE holds popped string
                                        REMOVE_SPECIFIED_POSITION            ! %POP(POS, [LINE])
      PROCEDURE, PASS(CH) :: RESET   => RESET_CHARACTER_TYPE_ARRAY           ! %RESET()
      GENERIC ::             ADD     => ADD_CHARACTER_TYPE_ARRAY,     &      ! %ADD(LINE)
                                        ADD_DBL_CHARACTER_TYPE_ARRAY, &      ! %ADD(DVAL, PAD)  
                                        ADD_INT_CHARACTER_TYPE_ARRAY         ! %ADD(IVAL, PAD, ZPAD)
      GENERIC ::          ADD_UNIQUE => ADD_UNIQUE_CHARACTER_TYPE_ARRAY,    &! %ADD_UNIQUE(STR, IGNORE_CASE)
                                        ADD_UNIQUE_INT_CHARACTER_TYPE_ARRAY,&! %ADD_UNIQUE(VAL, PAD, ZPAD)
                                        ADD_UNIQUE_DBL_CHARACTER_TYPE_ARRAY  ! %ADD_UNIQUE(VAL, PAD)
      GENERIC ::              INSERT => INSERT_CHARACTER_TYPE_ARRAY,    &    ! %INSERT(POS, STR) 
                                        INSERT_INT_CHARACTER_TYPE_ARRAY,&    ! %INSERT(POS, VAL, PAD, ZPAD) 
                                        INSERT_DBL_CHARACTER_TYPE_ARRAY      ! %INSERT(POS, VAL, PAD)
      PROCEDURE, PASS(CH) :: SIZE    => SIZE_CHARACTER_TYPE_ARRAY            ! %SIZE()
      PROCEDURE, PASS(CH) :: MAX_LEN => MAX_LEN_CHARACTER_TYPE_ARRAY         ! %MAX_LEN()
      PROCEDURE, PASS(CH) :: FIND    => FIND_CHARACTER_TYPE_ARRAY            ! %FIND(STR)
      GENERIC ::             COUNT   => COUNT_CHARACTER_TYPE_ARRAY, &        ! %COUNT(STR)
                                        COUNT_NOCASE_CHARACTER_TYPE_ARRAY    ! %COUNT(STR,IGNORE_CASE)
      PROCEDURE, PASS(CH) :: DESTROY => DEALLOCATE_CHARACTER_TYPE_ARRAY
      !
      PROCEDURE, PASS(CH), PRIVATE :: REMOVE_SPECIFIED_POSITION
      PROCEDURE, PASS(CH), PRIVATE :: REMOVE_LAST_POSITION
      PROCEDURE, PASS(CH), PRIVATE :: ADD_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: ADD_DBL_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: ADD_INT_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: COUNT_NOCASE_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: COUNT_CHARACTER_TYPE_ARRAY   
      PROCEDURE, PASS(CH), PRIVATE :: ADD_UNIQUE_CHARACTER_TYPE_ARRAY    ! (STR, IGNORE_CASE)
      PROCEDURE, PASS(CH), PRIVATE :: ADD_UNIQUE_INT_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: ADD_UNIQUE_DBL_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: INSERT_CHARACTER_TYPE_ARRAY 
      PROCEDURE, PASS(CH), PRIVATE :: INSERT_INT_CHARACTER_TYPE_ARRAY
      PROCEDURE, PASS(CH), PRIVATE :: INSERT_DBL_CHARACTER_TYPE_ARRAY
      !
      FINAL:: FINAL_DEALLOCATE_CHARACTER_TYPE_ARRAY
      !
  END TYPE
  !
  TYPE CHARACTER_BUF_TYPE
      INTEGER:: N   = Z
      INTEGER:: DIM = Z
      CHARACTER(:), ALLOCATABLE:: STR
      !
      CONTAINS
      !
      PROCEDURE, PASS(CH):: GROW    => GROW_SIZE_CHAR_BUF_TYPE         !(SIZ)
      PROCEDURE, PASS(CH):: SET_SIZE=> SET_SIZE_CHAR_BUF_TYPE          !(SIZ)
      PROCEDURE, PASS(CH):: SET     => SET_CHAR_BUF_TYPE_OPERATOR      !(LINE)
      PROCEDURE, PASS(CH):: GET     => GET_CHAR_BUF_TYPE               !()
      PROCEDURE, PASS(CH):: ADD     => ADD_TO_ENDING_CHAR_BUF_TYPE     !(LINE,[TRIM_IT])
      PROCEDURE, PASS(CH):: ADD_NL  => ADD_NL_ENDING_CHAR_BUF_TYPE     !(LINE,[TRIM_IT])
      PROCEDURE, PASS(CH):: ADD_TRIM=> TRIM_ADD_TO_ENDING_CHAR_BUF_TYPE!(LINE)
      PROCEDURE, PASS(CH):: ADD_BEGIN=> ADD_TO_BEGIN_CHAR_BUF_TYPE     !(LINE)
      PROCEDURE, PASS(CH):: NL      => NL_ENDING_CHAR_BUF_TYPE         !()
      PROCEDURE, PASS(CH):: SPACE   => ADD_BLANKS_CHAR_BUF_TYPE        !(NSPACE)
      
      PROCEDURE, PASS(CH):: MOVE    => MOVE_CHAR_BUF_TYPE!(CH_OUT)
      PROCEDURE, PASS(CH):: DESTROY => DEALLOCATE_CHAR_BUF_TYPE!(CH_OUT)
      GENERIC            :: ASSIGNMENT(=) => COPY_CHAR_BUF_TYPE_OPERATOR, SET_CHAR_BUF_TYPE_OPERATOR
      GENERIC            :: OPERATOR(==)  => COMPARE_CHAR_BUF_TYPE, COMPARE_CHAR_BUF_TYPE_STR
      !
      PROCEDURE,           PRIVATE:: COPY_CHAR_BUF_TYPE_OPERATOR
      PROCEDURE,           PRIVATE:: SET_CHAR_BUF_TYPE_OPERATOR
      PROCEDURE,           PRIVATE:: COMPARE_CHAR_BUF_TYPE
      PROCEDURE,           PRIVATE:: COMPARE_CHAR_BUF_TYPE_STR
      FINAL:: FINAL_DEALLOCATE_CHAR_BUF_TYPE
  END TYPE
  !
  TYPE CHARACTER_ARRAY
      INTEGER:: N=Z
      CHARACTER(:),DIMENSION(:), ALLOCATABLE::STR
      !
      CONTAINS
      !                                   (MAX_LEN,DIM) or (STR,[MAX_LEN],[DIM])
      GENERIC::             INIT       => ALLOCATE_CHARACTER_ARRAY, ALLOCATE_CHARACTER_ARRAY_STR
      PROCEDURE, PASS(CH):: ADD        => ADD_ROW_CHARACTER_ARRAY!(STR)
      PROCEDURE, PASS(CH):: ADD_UNIQUE => ADD_UNIQUE_ROW_CHARACTER_ARRAY !(STR,[POS])
      PROCEDURE, PASS(CH):: POS        => GET_CHARACTER_POSITION!(STR)
      PROCEDURE, PASS(CH):: GET        => GET_CHARACTER_ROW!(POS)
      PROCEDURE, PASS(CH):: MOVE       => MOVE_CHARACTER_ARRAY!(CH_OUT)
      PROCEDURE, PASS(CH):: DESTROY    => DEALLOCATE_CHARACTER_ARRAY
      GENERIC::          ASSIGNMENT(=) => COPY_CHARACTER_ARRAY_OPERATOR
      PROCEDURE,           PRIVATE:: COPY_CHARACTER_ARRAY_OPERATOR
      PROCEDURE, PASS(CH), PRIVATE:: ALLOCATE_CHARACTER_ARRAY
      PROCEDURE, PASS(CH), PRIVATE:: ALLOCATE_CHARACTER_ARRAY_STR
      FINAL::FINAL_DEALLOCATE_CHARACTER_ARRAY
  END TYPE
  !
  TYPE INTEGER_VECTOR
      INTEGER:: N=Z
      INTEGER, DIMENSION(:),ALLOCATABLE:: VEC
      !
      CONTAINS
      !
      GENERIC::             INIT         =>INIT_INTEGER_VECTOR, DEALLOCATE_INTEGER_VECTOR !([VEC])
      PROCEDURE, PASS(IT):: ALLOC        =>ALLOCATE_INTEGER_VECTOR         !(DIM [IVAL])  --IVAL IS A SCALER THAT WHEN PRESENT IS WHAT THE VECTOR IS SET TOO
      PROCEDURE, PASS(IT):: SET          =>SET_INTEGER_VECTOR_VALUE        !(POS,VAL)
      PROCEDURE, PASS(IT):: ADD          =>ADD_VAL_INTEGER_VECTOR          !(IVAL,POS)
      PROCEDURE, PASS(IT):: ADD_UNIQUE   =>ADD_UNIQUE_VAL_INTEGER_VECTOR   !(IVAL)
      PROCEDURE, PASS(IT):: IS_UNIQUE    =>  IS_UNIQUE_INTEGER_VECTOR      !(I)
      PROCEDURE, PASS(IT):: NOT_UNIQUE   => NOT_UNIQUE_INTEGER_VECTOR      !(I)
      PROCEDURE, PASS(IT):: POP          => REMOVE_LOCATION_INTEGER_VECTOR !(POS)
      PROCEDURE, PASS(IT):: COPY         =>TRANSFER_INTEGER_VECTOR         !(DB_OUT)
      PROCEDURE, PASS(IT):: MOVE         =>MOVE_INTEGER_VECTOR             !(DB_OUT)
      PROCEDURE, PASS(IT):: GET          =>GET_INTEGER_BY_INDEX            !(DB_OUT)
      PROCEDURE, PASS(IT):: FIND         =>FIND_INT_POS_INTEGER_VECTOR     !(IVAL)
      GENERIC::             DESTROY      => DEALLOCATE_INTEGER_VECTOR
      GENERIC::             ASSIGNMENT(=) => COPY_INTEGER_VECTOR_OPERATOR, SET_INTEGER_VECTOR_OPERATOR
      PROCEDURE,           PRIVATE:: COPY_INTEGER_VECTOR_OPERATOR
      PROCEDURE,           PRIVATE:: SET_INTEGER_VECTOR_OPERATOR
      PROCEDURE, PASS(IT), PRIVATE:: INIT_INTEGER_VECTOR
      PROCEDURE, PASS(IT), PRIVATE:: DEALLOCATE_INTEGER_VECTOR
      FINAL::FINAL_DEALLOCATE_INTEGER_VECTOR
  END TYPE
  !
  TYPE INTEGER_MATRIX
      INTEGER:: N=Z, M=Z
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: MAT
      !
      CONTAINS
      !
      PROCEDURE, PASS(IT):: INIT => INIT_INTEGER_MATRIX_OPERATOR!(MAT)
      GENERIC::             ALLOC=> ALLOCATE_INTEGER_MATRIX, ALLOCATE_INTEGER_MATRIX_SRC !(DIM1,DIM2,SRC)
      PROCEDURE, PASS(IT):: MOVE => MOVE_INTEGER_MATRIX!(DB_OUT)
      PROCEDURE, PASS(IT):: GET  => GET_INTEGER_MAT_BY_INDEX!(POS1,POS2)
      PROCEDURE, PASS(IT):: SET  => SET_INTEGER_MAT_BY_2_INDEX, SET_INTEGER_MAT_BY_1_INDEX, INIT_INTEGER_MATRIX_OPERATOR!(POS1,POS2,IVAL) or (POS,VEC,[DIMSET])
      PROCEDURE, PASS(IT):: DESTROY => DEALLOCATE_INTEGER_MATRIX
      GENERIC            :: ASSIGNMENT(=) => COPY_INTEGER_MATRIX_OPERATOR, SET_INTEGER_MATRIX_OPERATOR
      PROCEDURE,           PRIVATE:: COPY_INTEGER_MATRIX_OPERATOR
      PROCEDURE,           PRIVATE:: SET_INTEGER_MATRIX_OPERATOR
      PROCEDURE, PASS(IT), PRIVATE:: ALLOCATE_INTEGER_MATRIX
      PROCEDURE, PASS(IT), PRIVATE:: ALLOCATE_INTEGER_MATRIX_SRC
      FINAL::FINAL_DEALLOCATE_INTEGER_MATRIX
  END TYPE
  !
  TYPE DOUBLE_VECTOR
      INTEGER:: N=Z
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: VEC
      !
      CONTAINS
      !
      PROCEDURE, PASS(DB):: ALLOC=>ALLOCATE_DOUBLE_VECTOR!(DIM,[VAL])
      PROCEDURE, PASS(DB):: MOVE =>MOVE_DOUBLE_VECTOR!(DB_OUT)
      PROCEDURE, PASS(DB):: GET  =>GET_DOUBLE_VEC_BY_INDEX!(DB_OUT)
      PROCEDURE, PASS(DB):: DESTROY =>DEALLOCATE_DOUBLE_VECTOR
      GENERIC            :: ASSIGNMENT(=) => COPY_DOUBLE_VECTOR_OPERATOR, SET_DOUBLE_VECTOR_OPERATOR
      PROCEDURE, PRIVATE :: COPY_DOUBLE_VECTOR_OPERATOR
      PROCEDURE, PRIVATE :: SET_DOUBLE_VECTOR_OPERATOR
      FINAL::FINAL_DEALLOCATE_DOUBLE_VECTOR
  END TYPE
  !
  TYPE DOUBLE_MATRIX
      INTEGER:: N=Z, M=Z
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: MAT
      !
      CONTAINS
      ! 
      PROCEDURE, PASS(DB):: INIT => INIT_DOUBLE_MATRIX_OPERATOR
      GENERIC::             ALLOC=> ALLOCATE_DOUBLE_MATRIX, ALLOCATE_DOUBLE_MATRIX_SRC !(DIM1,DIM2,SRC)
      PROCEDURE, PASS(DB):: MOVE => MOVE_DOUBLE_MATRIX!(DB_OUT)
      PROCEDURE, PASS(DB):: GET  => GET_DOUBLE_MAT_BY_INDEX!(DB_OUT)
      GENERIC::             SET  => SET_DOUBLE_MAT_BY_2_INDEX, SET_DOUBLE_MAT_BY_1_INDEX, INIT_DOUBLE_MATRIX_OPERATOR !(POS1,POS2,VAL) or (POS,VEC,[DIMSET])
      PROCEDURE, PASS(DB):: DESTROY => DEALLOCATE_DOUBLE_MATRIX
      GENERIC::       ASSIGNMENT(=) => COPY_DOUBLE_MATRIX_OPERATOR, SET_DOUBLE_MATRIX_OPERATOR
      PROCEDURE,           PRIVATE:: COPY_DOUBLE_MATRIX_OPERATOR
      PROCEDURE,           PRIVATE:: SET_DOUBLE_MATRIX_OPERATOR
      PROCEDURE, PASS(DB), PRIVATE:: SET_DOUBLE_MAT_BY_2_INDEX
      PROCEDURE, PASS(DB), PRIVATE:: SET_DOUBLE_MAT_BY_1_INDEX
      PROCEDURE, PASS(DB), PRIVATE:: INIT_DOUBLE_MATRIX_OPERATOR
      PROCEDURE, PASS(DB), PRIVATE:: ALLOCATE_DOUBLE_MATRIX
      PROCEDURE, PASS(DB), PRIVATE:: ALLOCATE_DOUBLE_MATRIX_SRC
      FINAL::FINAL_DEALLOCATE_DOUBLE_MATRIX
  END TYPE
  !
  TYPE LOGICAL_VECTOR
      INTEGER:: N=Z
      LOGICAL, DIMENSION(:),ALLOCATABLE:: VEC
      !
      CONTAINS
      !
      PROCEDURE, PASS(TF):: ALLOC=>ALLOCATE_LOGICAL_VECTOR
      PROCEDURE, PASS(TF):: ADD  =>ADD_VAL_LOGICAL_VECTOR
      PROCEDURE, PASS(TF):: MOVE =>MOVE_LOGICAL_VECTOR!(DB_OUT)
      PROCEDURE, PASS(TF):: GET  =>GET_LOGICAL_BY_INDEX!(DB_OUT)
      PROCEDURE, PASS(TF):: DESTROY =>DEALLOCATE_LOGICAL_VECTOR
      GENERIC            :: ASSIGNMENT(=) => COPY_LOGICAL_VECTOR_OPERATOR
      PROCEDURE, PRIVATE :: COPY_LOGICAL_VECTOR_OPERATOR
      FINAL::FINAL_DEALLOCATE_LOGICAL_VECTOR
  END TYPE
  !
  TYPE COMPRESSED_VALUE_STORAGE
      INTEGER:: N = Z      !Size of VAL and DIM(2)
      INTEGER:: M = Z      !Size of DIM(1)
      INTEGER:: CAP = Z    ! Allocated size of VAL AND DIM
      LOGICAL:: IS_CONSTANT = FALSE                      !If true then N = ONE and all entries hold the same value
      INTEGER,          DIMENSION(:,:), ALLOCATABLE:: DIM
      DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE:: VAL
      CONTAINS
      PROCEDURE, PASS(CVS):: ALLOC         => ALLOCATE_CVS      !ALLOC(N, NDIM, [NEW_ALLOC])
      PROCEDURE, PASS(CVS):: BUILD_NONZERO => BUILD_NONZERO_CVS
      PROCEDURE, PASS(CVS):: SET_CONSTANT  => SET_CONSTANT_CVS
      GENERIC             :: DECOMPRESS    => SET_TO_ARRAY_DBL, SET_TO_ARRAY_SNG
      PROCEDURE, PASS(CVS):: DESTROY       => DEALLCOATE_COMPRESSED_VALUE_STORAGE
      !
      PROCEDURE, PASS(CVS), PRIVATE:: SET_TO_ARRAY_DBL
      PROCEDURE, PASS(CVS), PRIVATE:: SET_TO_ARRAY_SNG
      !
      FINAL:: DEALLCOATE_COMPRESSED_VALUE_STORAGE_FINAL
  END TYPE
  !
  TYPE COMPRESSED_LOCATION_STORAGE
      INTEGER:: N = Z    !Size in use of DIM(2); N <= SIZ
      INTEGER:: M = Z    !Size of DIM(1)
      INTEGER:: SIZ = Z  !Size of DIM(2)
      INTEGER:: ID=NEG   !ID whose locations are stored in DIM(1)
      LOGICAL:: IS_CONSTANT = FALSE  ! If true then DIM is meaningless and ID is entire array
      INTEGER, DIMENSION(:,:), ALLOCATABLE:: DIM
      CONTAINS
      PROCEDURE, PASS(LAC):: ALLOC   => ALLOCATE_LAC                              !(N, NDIM, NEW_ALLOC)  -- Should use BUILD instead
      GENERIC             :: BUILD   => BUILD_COMPRESSED_LOCATION_STORAGE_DIM2, & !(ID, ARR)  ARR is DIM(:,:)
                                        BUILD_COMPRESSED_LOCATION_STORAGE_DIM3    !(ID, ARR)  ARR is DIM(:,:,:)
      PROCEDURE, PASS(LAC):: DESTROY => DEALLCOATE_COMPRESSED_LOCATION_STORAGE
      !
      PROCEDURE, PASS(LAC), PRIVATE:: BUILD_COMPRESSED_LOCATION_STORAGE_DIM2  !(ID, ARR)  ARR is DIM(:,:)
      PROCEDURE, PASS(LAC), PRIVATE:: BUILD_COMPRESSED_LOCATION_STORAGE_DIM3  !(ID, ARR)  ARR is DIM(:,:,:)
      !
      FINAL:: DEALLCOATE_COMPRESSED_LOCATION_STORAGE_FINAL
  END TYPE
  !
  !!!INTERFACE COMPRESSED_LOCATION_STORAGE
  !!!            MODULE PROCEDURE BUILD_COMPRESSED_LOCATION_STORAGE_ALOC
  !!!END INTERFACE
  !
  TYPE ID1_ID2_RAT_VOL_BASE
      INTEGER:: ID1, ID2
      DOUBLE PRECISION:: RAT
      DOUBLE PRECISION:: VOL
      !
      CONTAINS
      !
      GENERIC:: ASSIGNMENT(=) => COPY_ID1_ID2_RAT_VOL_BASE
      PROCEDURE, PRIVATE:: COPY_ID1_ID2_RAT_VOL_BASE
  END TYPE
  !
  TYPE ID_RAT_VOL_BASE
      INTEGER:: ID
      DOUBLE PRECISION:: RAT
      DOUBLE PRECISION:: VOL
      !
      CONTAINS
      !
      GENERIC:: ASSIGNMENT(=) => COPY_ID_RAT_VOL_BASE
      PROCEDURE, PRIVATE:: COPY_ID_RAT_VOL_BASE
  END TYPE
  !
  TYPE ID_VAL_BASE
      INTEGER:: ID
      DOUBLE PRECISION:: VAL
      !
      CONTAINS
      !
      GENERIC:: ASSIGNMENT(=) => COPY_ID_VAL_BASE
      PROCEDURE, PRIVATE:: COPY_ID_VAL_BASE
  END TYPE
  !
  TYPE RAT_VOL_BASE
      DOUBLE PRECISION:: RAT
      DOUBLE PRECISION:: VOL
      !
      CONTAINS
      !
      PROCEDURE, PASS(TYP):: SET_RAT  =>  SET_RAT_RAT_VOL_BASE  !(POS, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  =>  SET_VOL_RAT_VOL_BASE  !(POS, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT => CALC_RAT_RAT_VOL_BASE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL => CALC_VOL_RAT_VOL_BASE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  =>  GET_RAT_RAT_VOL_BASE  !(POS, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  =>  GET_VOL_RAT_VOL_BASE  !(POS, [EVAL])
      GENERIC:: ASSIGNMENT(=) => COPY_RAT_VOL_BASE
      PROCEDURE, PRIVATE:: COPY_RAT_VOL_BASE
  END TYPE
  !
  TYPE RAT_VOL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(RAT_VOL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      GENERIC             :: ALLOC   =>    ALLOC_RAT_VOL_TYPE,          & !(DIM,[INIT])
                                           ALLOC_RAT_VOL_TYPE_INIT_SCA, & 
                                           ALLOC_RAT_VOL_TYPE_INIT_VEC   
      PROCEDURE, PASS(TYP):: ADD      =>      EXTEND_RAT_VOL_TYPE  !(RAT, VOL)
      PROCEDURE, PASS(TYP):: SET_RAT  => SET_RAT_POS_RAT_VOL_TYPE  !(POS, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  => SET_VOL_POS_RAT_VOL_TYPE  !(POS, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT =>    CALC_RAT_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL =>    CALC_VOL_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  => GET_RAT_POS_RAT_VOL_TYPE  !(POS, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  => GET_VOL_POS_RAT_VOL_TYPE  !(POS, [EVAL])
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_RAT_VOL_TYPE
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_RAT_VOL_TYPE_INIT_SCA
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_RAT_VOL_TYPE_INIT_VEC
  END TYPE
  !
  TYPE ID1_ID2_RAT_VOL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(ID1_ID2_RAT_VOL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      PROCEDURE, PASS(TYP):: ALLOC   =>     ALLOC_ID1_ID2_RAT_VOL_TYPE  !(DIM)
      PROCEDURE, PASS(TYP):: ADD      =>   EXTEND_ID1_ID2_RAT_VOL_TYPE  !(ID1, ID2, RAT, VOL)
      PROCEDURE, PASS(TYP):: SET_RAT  =>  SET_RAT_ID1_ID2_RAT_VOL_TYPE  !(ID1, ID2, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  =>  SET_VOL_ID1_ID2_RAT_VOL_TYPE  !(ID1, ID2, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT => CALC_RAT_ID1_ID2_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL => CALC_VOL_ID1_ID2_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  =>  GET_RAT_ID1_ID2_RAT_VOL_TYPE  !(ID, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  =>  GET_VOL_ID1_ID2_RAT_VOL_TYPE  !(ID, [EVAL])
  END TYPE
  !
  TYPE ID_RAT_VOL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(ID_RAT_VOL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      GENERIC             :: ALLOC   =>     ALLOC_ID_RAT_VOL_TYPE,          & !(DIM,[INIT])
                                            ALLOC_ID_RAT_VOL_TYPE_INIT_SCA, & 
                                            ALLOC_ID_RAT_VOL_TYPE_INIT_VEC   
      PROCEDURE, PASS(TYP):: ADD      =>   EXTEND_ID_RAT_VOL_TYPE  !(ID, RAT, VOL)
      PROCEDURE, PASS(TYP):: SET_RAT  =>  SET_RAT_ID_RAT_VOL_TYPE  !(ID, RAT)
      PROCEDURE, PASS(TYP):: SET_VOL  =>  SET_VOL_ID_RAT_VOL_TYPE  !(ID, VOL)
      PROCEDURE, PASS(TYP):: CALC_RAT => CALC_RAT_ID_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: CALC_VOL => CALC_VOL_ID_RAT_VOL_TYPE  !(DELT)
      PROCEDURE, PASS(TYP):: GET_RAT  =>  GET_RAT_ID_RAT_VOL_TYPE  !(ID, [EVAL])
      PROCEDURE, PASS(TYP):: GET_VOL  =>  GET_VOL_ID_RAT_VOL_TYPE  !(ID, [EVAL])
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_RAT_VOL_TYPE
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_RAT_VOL_TYPE_INIT_SCA
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_RAT_VOL_TYPE_INIT_VEC
  END TYPE
  !
  TYPE ID_VAL_TYPE
      LOGICAL:: INUSE = FALSE
      INTEGER:: N = Z
      TYPE(ID_VAL_BASE), DIMENSION(:), ALLOCATABLE:: PT
      !
      CONTAINS
      !
      GENERIC             :: ALLOC   =>   ALLOC_ID_VAL_TYPE,          & !(DIM,[INIT])
                                          ALLOC_ID_VAL_TYPE_INIT_SCA, & 
                                          ALLOC_ID_VAL_TYPE_INIT_VEC  
      PROCEDURE, PASS(TYP):: ADD     =>  EXTEND_ID_VAL_TYPE  !(ID, VAL)
      PROCEDURE, PASS(TYP):: SET_VAL => SET_VAL_ID_VAL_TYPE  !(ID, VAL)
      PROCEDURE, PASS(TYP):: GET_VAL => GET_VAL_ID_VAL_TYPE  !(ID, [EVAL])
      GENERIC             :: SET     => SET_ID_VAL_TYPE_ALL, SET_ID_VAL_TYPE_POS  !(ID, VAL) or (POS, ID, VAL, [INUL], [NUL])
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_VAL_TYPE_ALL
      PROCEDURE, PASS(TYP), PRIVATE:: SET_ID_VAL_TYPE_POS
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_VAL_TYPE      
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_VAL_TYPE_INIT_SCA
      PROCEDURE, PASS(TYP), PRIVATE:: ALLOC_ID_VAL_TYPE_INIT_VEC
  END TYPE
  !
  CONTAINS
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  ! Stand alone functions
  ! 
  PURE FUNCTION JOIN_TXT_CHAR(TXT,JOIN,ENDING) RESULT(LN)
    CHARACTER(*),DIMENSION(:),CONTIGUOUS,INTENT(IN):: TXT
    CHARACTER(*),                        INTENT(IN):: JOIN
    CHARACTER(*), OPTIONAL,              INTENT(IN):: ENDING
    CHARACTER(:),                       ALLOCATABLE:: LN
    INTEGER::I
    !
    LN=TRIM(ADJUSTL(TXT(ONE)))
    DO I=TWO, SIZE(TXT)
                      LN=LN//JOIN//TRIM(ADJUSTL(TXT(I)))
    END DO
    !
    IF(PRESENT(ENDING)) LN=LN//ENDING
    !
  END FUNCTION
  !
  PURE FUNCTION JOIN_TXT_CHAR_TYP(TXT,JOIN,ENDING) RESULT(LN)
    TYPE(CHARACTER_TYPE), DIMENSION(:),  CONTIGUOUS, INTENT(IN):: TXT
    CHARACTER(*),                                    INTENT(IN):: JOIN
    CHARACTER(*), OPTIONAL,                          INTENT(IN):: ENDING
    CHARACTER(:), ALLOCATABLE:: LN
    INTEGER:: I
    !
    LN=TXT(ONE)%STR
    DO I=TWO, SIZE(TXT)
                      LN=LN//JOIN//TXT(I)%STR
    END DO
    !
    IF(PRESENT(ENDING)) LN=LN//ENDING
    !
  END FUNCTION
  !
  PURE FUNCTION JOIN_TXT_CHAR_ARR(TXT,JOIN,ENDING) RESULT(LN)
    TYPE(CHARACTER_ARRAY),  INTENT(IN):: TXT
    CHARACTER(*),           INTENT(IN):: JOIN
    CHARACTER(*), OPTIONAL, INTENT(IN):: ENDING
    CHARACTER(:), ALLOCATABLE:: LN
    INTEGER:: I
    !
    IF(TXT%N == Z) THEN
        LN=""
        RETURN
    END IF
    !
    LN=TRIM(ADJUSTL(TXT%STR(ONE)))
    DO I=TWO, TXT%N
                      LN=LN//JOIN//TRIM(ADJUSTL(TXT%STR(I)))
    END DO
    !
    IF(PRESENT(ENDING)) LN=LN//ENDING
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  ! CHARACTER_TYPE Routines
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),         INTENT(IN   ):: LINE
     !
     CH%STR=LINE
     !
  END SUBROUTINE
  !
  PURE FUNCTION LEN_CHARACTER_TYPE(CH) RESULT(DIM)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     INTEGER:: DIM
     !
     IF(ALLOCATED(CH%STR)) THEN
        DIM = LEN(CH%STR)
    ELSE
        DIM = Z
    END IF
     !
  END FUNCTION
  !
  PURE FUNCTION LEN_TRIM_CHARACTER_TYPE(CH) RESULT(DIM)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     INTEGER:: DIM
     !
     IF(ALLOCATED(CH%STR)) THEN
        DIM = LEN_TRIM(CH%STR)
    ELSE
        DIM = Z
    END IF
     !
  END FUNCTION
  !
  PURE FUNCTION GET_CHARACTER_TYPE(CH) RESULT(LINE)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CHARACTER(:),ALLOCATABLE:: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
         ALLOCATE(LINE, SOURCE=CH%STR)
     ELSE
         ALLOCATE(LINE, SOURCE=BLNK)
     END IF
     !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE ADD_TO_ENDING_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
                                CH%STR = CH%STR//LINE
     ELSE
                       ALLOCATE(CH%STR, SOURCE=LINE)
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_TO_BEGIN_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
                                CH%STR = LINE//CH%STR
     ELSE
                       ALLOCATE(CH%STR, SOURCE=LINE)
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE TRIM_ADD_TO_ENDING_CHARACTER_TYPE(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     IF(ALLOCATED(CH%STR)) THEN
                                CH%STR = CH%STR//TRIM(LINE)
     ELSE
                       ALLOCATE(CH%STR, SOURCE=TRIM(LINE))
     END IF
     !
  END SUBROUTINE
  !
!  PURE ELEMENTAL SUBROUTINE ADD_TO_ENDING_CHARACTER_TYPE(CH,LINE,TRIM_LINE)
!     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
!     CHARACTER(*),          INTENT(IN   ):: LINE
!     LOGICAL,     OPTIONAL, INTENT(IN   ):: TRIM_LINE
!     LOGICAL:: TL
!     !
!     TL = FALSE
!     IF(PRESENT(TRIM_LINE)) TL = TRIM_LINE
!     IF(ALLOCATED(CH%STR)) THEN
!         IF(TL) THEN
!                    CH%STR = CH%STR//TRIM(LINE)
!         ELSE
!                    CH%STR = CH%STR//LINE
!         END IF
!     ELSE
!         IF(TL) THEN
!                    ALLOCATE(CH%STR, SOURCE=TRIM(LINE))
!         ELSE
!                    ALLOCATE(CH%STR, SOURCE=LINE)
!         END IF
!     END IF
!     !
!  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE REMOVE_SPECIFIED_CHARACTER(CH,POS) 
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     INTEGER,               INTENT(IN   ):: POS
     CHARACTER(:), ALLOCATABLE:: LINE
     INTEGER:: Pp1, Pm1, Nm1, P, DIM
     !
     IF(ALLOCATED(CH%STR)) THEN
         DIM = LEN(CH%STR)
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = DIM + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
         !
         IF    (P == ONE .AND. DIM == ONE) THEN
                 CALL DESTROY_CHARACTER_TYPE(CH)
         ELSEIF(Z < P .AND. P <= DIM) THEN
             IF    (P == ONE) THEN
                                   ALLOCATE(LINE, SOURCE=CH%STR(TWO:))
                                   CALL MOVE_ALLOC(LINE, CH%STR)
             ELSEIF(P==DIM) THEN
                                   ALLOCATE(LINE, SOURCE=CH%STR(ONE:DIM-ONE))
                                   CALL MOVE_ALLOC(LINE, CH%STR)
             ELSE
                                   Pp1 = P + ONE
                                   Pm1 = P - ONE
                                   Nm1 = DIM- ONE
                                   ALLOCATE(CHARACTER(Nm1)::LINE)
                                   !
                                   LINE(ONE:Pm1) = CH%STR(ONE:Pm1)
                                   LINE(P:Nm1) = CH%STR(Pp1:DIM)
                                   !
                                   CALL MOVE_ALLOC(LINE, CH%STR)
             END IF
             !
         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE REMOVE_SPECIFIED_RANGE_CHARACTER(CH,P1,P2)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     INTEGER,               INTENT(IN   ):: P1,P2
     CHARACTER(:), ALLOCATABLE:: LINE
     INTEGER:: Pp1, Pm1, DIM
     !
     DIM = LEN(CH)
     IF( P2 < P1 .OR. (P1 < TWO .AND. P2 >= DIM) ) THEN
                 CALL DESTROY_CHARACTER_TYPE(CH)
     ELSEIF(DIM > Z) THEN
         !
         IF    (P1 == P2) THEN
                 CALL REMOVE_SPECIFIED_CHARACTER(CH,P1)
         ELSE
             Pp1 = P2 + ONE
             Pm1 = P1 - ONE
             !
             IF(Pp1 >= DIM) THEN
                 ALLOCATE(LINE, SOURCE= CH%STR(ONE:Pm1) )
             ELSEIF(Pm1 < ONE) THEN
                 ALLOCATE(LINE, SOURCE= CH%STR(Pp1:DIM) )
             ELSE
                 ALLOCATE(LINE, SOURCE= CH%STR(ONE:Pm1)//CH%STR(Pp1:DIM) )
             END IF
             !
             CALL MOVE_ALLOC(LINE, CH%STR)
         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE REMOVE_LAST_CHARACTER(CH) 
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     !
     CALL REMOVE_SPECIFIED_CHARACTER(CH,NEG) 
     !
  END SUBROUTINE
  !
  IMPURE ELEMENTAL SUBROUTINE WRITE_CHARACTER_TYPE(CH,IU,FMT)
     CLASS(CHARACTER_TYPE),  INTENT(INOUT):: CH
     INTEGER,                INTENT(IN   ):: IU
     CHARACTER(*), OPTIONAL, INTENT(IN   ):: FMT
     !
     IF(IU /= Z .AND. LEN(CH) > Z) THEN
         IF(PRESENT(FMT)) THEN
             WRITE(IU,FMT) CH%STR
         ELSE
             WRITE(IU,'(A)') CH%STR
         END IF
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_CHARACTER_TYPE(CH,CH_OUT)
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH_OUT
     IF    (ALLOCATED(CH%STR)    ) THEN
                                   CALL MOVE_ALLOC(CH%STR,CH_OUT%STR)
     ELSEIF(ALLOCATED(CH_OUT%STR)) THEN
                                   DEALLOCATE(CH_OUT%STR)
     END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE COPY_CHARACTER_TYPE_OPERATOR(CH_OUT,CH_IN)
     CLASS(CHARACTER_TYPE),INTENT(IN   ):: CH_IN
     CLASS(CHARACTER_TYPE),INTENT(INOUT):: CH_OUT
     !
     IF (ALLOCATED(CH_IN%STR)) THEN
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
         ALLOCATE(CH_OUT%STR, SOURCE=CH_IN%STR)
     ELSE
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
     END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE SET_CHARACTER_TYPE_OPERATOR(CH,LINE)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     CH%STR = LINE
     !
  END SUBROUTINE
  !
  ELEMENTAL PURE FUNCTION COMPARE_CHARACTER_TYPE_STR(CH, STR) RESULT(CMP)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CHARACTER(*),          INTENT(IN):: STR
     LOGICAL:: CMP
     !
     IF(ALLOCATED(CH%STR)) THEN
            CMP = CH%STR == STR
     ELSE
            CMP = .FALSE.
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION COMPARE_CHARACTER_TYPE(CH, CH_CMP) RESULT(CMP)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH_CMP
     LOGICAL:: CMP
     !
     IF(ALLOCATED(CH%STR) .AND. ALLOCATED(CH_CMP%STR)) THEN
                                                       CMP = CH%STR == CH_CMP%STR
     ELSE
         CMP = .FALSE.
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION NOT_EQUAL_CHARACTER_TYPE_STR(CH, STR) RESULT(CMP)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CHARACTER(*),          INTENT(IN):: STR
     LOGICAL:: CMP
     !
     IF(ALLOCATED(CH%STR)) THEN
                           CMP = CH%STR /= STR
     ELSE
         CMP = .TRUE.
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION NOT_EQUAL_CHARACTER_TYPE(CH, CH_CMP) RESULT(CMP)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH_CMP
     LOGICAL:: CMP
     !
     IF(ALLOCATED(CH%STR) .AND. ALLOCATED(CH_CMP%STR)) THEN
                                                       CMP = CH%STR /= CH_CMP%STR
     ELSE
         CMP = .TRUE.
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION CONCAT_STR_CHARACTER_TYPE(STR, CH) RESULT(STR_OUT)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CHARACTER(*),          INTENT(IN):: STR
     CHARACTER( MAX(LEN(STR)+LEN(CH), 1) ):: STR_OUT
     !
     IF(ALLOCATED(CH%STR)) THEN
                  STR_OUT = STR // CH%STR
     ELSE
                  STR_OUT = STR
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION CONCAT_CHARACTER_TYPE_STR(CH, STR) RESULT(STR_OUT)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH
     CHARACTER(*),          INTENT(IN):: STR
     CHARACTER( MAX(LEN(STR)+LEN(CH), 1) ):: STR_OUT
     !
     IF(ALLOCATED(CH%STR)) THEN
                  STR_OUT = CH%STR // STR
     ELSE
                  STR_OUT = STR
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION CONCAT_CHARACTER_TYPE(CH1, CH2) RESULT(STR)
     CLASS(CHARACTER_TYPE), INTENT(IN):: CH1, CH2
     CHARACTER(MAX(LEN(CH1) + LEN(CH2), 1)):: STR
     LOGICAL:: ALLOC1, ALLOC2
     !
     ALLOC1 = ALLOCATED(CH1%STR)
     ALLOC2 = ALLOCATED(CH2%STR)
     IF    (ALLOC1 .AND. ALLOC2) THEN
                                 STR = CH1%STR // CH2%STR
     ELSEIF(ALLOC1             ) THEN
                                 STR = CH1%STR
     ELSEIF(             ALLOC2) THEN
                                 STR = CH2%STR
     ELSE
         STR = BLNK
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION ADD_STR_CHARACTER_TYPE(STR, CH) RESULT(CH_OUT)
     CLASS(CHARACTER_TYPE),INTENT(IN):: CH
     CHARACTER(*),         INTENT(IN):: STR
     TYPE(CHARACTER_TYPE):: CH_OUT
     LOGICAL:: HAS_STR, ALLOC
     !
     ALLOC   = ALLOCATED(CH%STR)
     HAS_STR = LEN(STR) > Z
     !
     IF    (ALLOC .AND. HAS_STR) THEN
                        CH_OUT%STR = STR // CH%STR
     ELSEIF(ALLOC  ) THEN
                        CH_OUT%STR = CH%STR
     ELSEIF(HAS_STR) THEN
                        CH_OUT%STR = STR
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION ADD_CHARACTER_TYPE_STR(CH, STR) RESULT(CH_OUT)
     CLASS(CHARACTER_TYPE),INTENT(IN):: CH
     CHARACTER(*),         INTENT(IN):: STR
     TYPE(CHARACTER_TYPE):: CH_OUT
     LOGICAL:: HAS_STR, ALLOC
     !
     ALLOC   = ALLOCATED(CH%STR)
     HAS_STR = LEN(STR) > Z
     !
     IF    (ALLOC .AND. HAS_STR) THEN
                        CH_OUT%STR = CH%STR // STR
     ELSEIF(ALLOC  ) THEN
                        CH_OUT%STR = CH%STR
     ELSEIF(HAS_STR) THEN
                        CH_OUT%STR = STR
     END IF
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION ADD_CHARACTER_TYPE(CH1, CH2) RESULT(CH_OUT)
     CLASS(CHARACTER_TYPE),INTENT(IN):: CH1,CH2
     TYPE(CHARACTER_TYPE):: CH_OUT
     LOGICAL:: ALLOC1, ALLOC2
     !
     ALLOC1 = ALLOCATED(CH1%STR)
     ALLOC2 = ALLOCATED(CH2%STR)
     !
     IF    (ALLOC1 .AND. ALLOC2) THEN
                                 CH_OUT%STR = CH1%STR // CH2%STR
     ELSEIF(ALLOC1             ) THEN
                                 CH_OUT%STR = CH1%STR
     ELSEIF(             ALLOC2) THEN
                                 CH_OUT%STR = CH2%STR
     END IF
     !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE DESTROY_CHARACTER_TYPE(CH)
     CLASS(CHARACTER_TYPE), INTENT(INOUT):: CH
     !
     CH%STR=""          ! Ensure that LEN(CH%STR) == 0
     DEALLOCATE(CH%STR)
     !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  ! CHARACTER_TYPE_ARRAY Routines
  !
  PURE SUBROUTINE INITIALIZE_CHARACTER_TYPE_ARRAY(CH,DIM)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     INTEGER,     OPTIONAL, INTENT(IN   ):: DIM
     !
     CH%N = Z
     IF(ALLOCATED(CH%VEC)) DEALLOCATE(CH%VEC)
     !
     IF(PRESENT(DIM)) THEN
                      IF(DIM > Z) THEN
                                  CH%DIM = 16*(DIM/16) + 16   ! Ensure it is a multiple of 16
                                  ALLOCATE(CH%VEC(CH%DIM))
                      ELSE
                                  CH%DIM = Z
                      END IF
     ELSE
         CH%DIM = 16
         ALLOCATE(CH%VEC(CH%DIM))
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE RESET_CHARACTER_TYPE_ARRAY(CH)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     CH%N   = Z
  END SUBROUTINE
  !
  PURE SUBROUTINE EXTEND_CHARACTER_TYPE_ARRAY(CH)
     TYPE(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     TYPE(CHARACTER_TYPE), DIMENSION(:), ALLOCATABLE:: TMP
     INTEGER:: I
     !
     IF  (CH%DIM < ONE) THEN
                        CALL CH%INIT()
     ELSEIF(CH%N < ONE) THEN
                        CH%N   = Z
                        CH%DIM = NEW_DIM_SIZE(CH%DIM)
                        !
                        DEALLOCATE(CH%VEC)
                        ALLOCATE(CH%VEC(CH%DIM))
     ELSE
         ALLOCATE( TMP(CH%N) )
         DO I=ONE, CH%N
                   CALL MOVE_ALLOC(CH%VEC(I)%STR, TMP(I)%STR) 
         END DO
         !
         CH%DIM = NEW_DIM_SIZE(CH%DIM)
         !
         DEALLOCATE(CH%VEC)
         ALLOCATE(CH%VEC(CH%DIM))
         !
         DO I=ONE, CH%N
                   CALL MOVE_ALLOC(TMP(I)%STR, CH%VEC(I)%STR) 
         END DO
     END IF
     !
  END SUBROUTINE
  !    
  PURE FUNCTION NEW_DIM_SIZE(DIM) RESULT(DIM_NEW)
     INTEGER, INTENT(IN):: DIM
     INTEGER:: DIM_NEW
     !
     IF    (DIM <  64) THEN
                        DIM_NEW = 64
     ELSEIF(DIM < 512) THEN
                        DIM_NEW = TWO * DIM
     ELSEIF(DIM < 4096) THEN
                        DIM_NEW =  512*(DIM/512)  + 512
     ELSE
                        DIM_NEW = 1024*(DIM/1024) + 1024
     END IF
     !
  END FUNCTION
  !    
  PURE FUNCTION SIZE_CHARACTER_TYPE_ARRAY(CH) RESULT(N)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(IN):: CH
     INTEGER:: N
     !
     N = CH%N
     !
  END FUNCTION
  !    
  PURE FUNCTION MAX_LEN_CHARACTER_TYPE_ARRAY(CH) RESULT(N)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(IN):: CH
     INTEGER:: N
     INTEGER:: I
     !
     N = Z
     DO I=ONE, CH%N
         IF(LEN(CH%VEC(I)%STR) > N) N = LEN(CH%VEC(I)%STR)
     END DO
     !
  END FUNCTION
  !
  PURE SUBROUTINE INSERT_CHARACTER_TYPE_ARRAY(CH, POS, STR) 
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     INTEGER,                     INTENT(IN   ):: POS
     CHARACTER(*),                INTENT(IN   ):: STR
     INTEGER:: P, I
     !
     IF    (POS > 0) THEN
                     P = POS
     ELSEIF(POS < 0) THEN
                     P = CH%N + POS + TWO  !-1 IS THE END OF THE LIST
     ELSE
                     P = ONE
     END IF
     !
     IF(CH%N + ONE > CH%DIM) CALL EXTEND_CHARACTER_TYPE_ARRAY(CH)
     !
     CH%N = CH%N + ONE
     IF(P > CH%N) P = CH%N
     !
     DO I=CH%N, P+1, NEG
             CALL MOVE_ALLOC(CH%VEC(I-1)%STR, CH%VEC(I)%STR)
     END DO
     !
     CH%VEC(P)%STR = STR
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE INSERT_INT_CHARACTER_TYPE_ARRAY(CH, POS, VAL, PAD, ZPAD) 
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     INTEGER,                     INTENT(IN   ):: POS
     INTEGER(INT32),              INTENT(IN   ):: VAL
     INTEGER,           OPTIONAL, INTENT(IN   ):: PAD
     LOGICAL,           OPTIONAL, INTENT(IN   ):: ZPAD
     CHARACTER(:), ALLOCATABLE:: TMP
     INTEGER:: P, I
     !
     CALL ADD_INT_CHARACTER_TYPE_ARRAY(CH, VAL, PAD, ZPAD)
     !
     IF    (POS > 0) THEN
                     P = POS
     ELSEIF(POS < 0) THEN
                     P = CH%N + POS + TWO  !-1 IS THE END OF THE LIST
     ELSE
                     P = ONE
     END IF
     !
     IF(P < CH%N) THEN
            CALL MOVE_ALLOC(CH%VEC(CH%N)%STR, TMP)
            !
            DO I=CH%N, P+1, NEG
                    CALL MOVE_ALLOC(CH%VEC(I)%STR, CH%VEC(I+1)%STR)
            END DO
            !
            CALL MOVE_ALLOC(TMP, CH%VEC(P)%STR)
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE INSERT_DBL_CHARACTER_TYPE_ARRAY(CH, POS, VAL, PAD)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     INTEGER,                     INTENT(IN   ):: POS
     REAL(DBL),                   INTENT(IN   ):: VAL
     INTEGER,           OPTIONAL, INTENT(IN   ):: PAD
     CHARACTER(:), ALLOCATABLE:: TMP
     INTEGER:: P, I
     !
     CALL ADD_DBL_CHARACTER_TYPE_ARRAY(CH, VAL, PAD)
     !
     IF    (POS > 0) THEN
                     P = POS
     ELSEIF(POS < 0) THEN
                     P = CH%N + POS + TWO  !-1 IS THE END OF THE LIST
     ELSE
                     P = ONE
     END IF
     !
     IF(P < CH%N) THEN
            CALL MOVE_ALLOC(CH%VEC(CH%N)%STR, TMP)
            !
            DO I=CH%N, P+1, NEG
                    CALL MOVE_ALLOC(CH%VEC(I)%STR, CH%VEC(I+1)%STR)
            END DO
            !
            CALL MOVE_ALLOC(TMP, CH%VEC(P)%STR)
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_CHARACTER_TYPE_ARRAY(CH, STR)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     CHARACTER(*),                INTENT(IN   ):: STR
     !
     IF(CH%N + ONE > CH%DIM) CALL EXTEND_CHARACTER_TYPE_ARRAY(CH)
     !
     CH%N = CH%N + ONE
     CH%VEC(CH%N)%STR = STR
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_DBL_CHARACTER_TYPE_ARRAY(CH, VAL, PAD)  
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     REAL(DBL),                   INTENT(IN   ):: VAL
     INTEGER,           OPTIONAL, INTENT(IN   ):: PAD
     REAL(DBL):: DVAL1C, DVAL10, DVAL1K
     CHARACTER(16)::NUM                                ! Largest possible number is 14 characters
     INTEGER:: N
     !
     IF(CH%N + ONE > CH%DIM) CALL EXTEND_CHARACTER_TYPE_ARRAY(CH)
     CH%N = CH%N + ONE
     !
     NUM=''
     DVAL10 = 10_dbl*VAL;   DVAL1C = 100_dbl*VAL;   DVAL1K = 1000_dbl*VAL
     !
     IF(VAL /= VAL) THEN
                                         NUM = 'NaN'
     ELSEIF(VAL >=  0.999999*HUGE(VAL))  THEN
                                         NUM = 'inf'
     ELSEIF(VAL <= -0.999999*HUGE(VAL))  THEN
                                         NUM = '-inf'
     ELSEIF(VAL==0.D0)                    THEN
                                         WRITE(NUM,'(F3.1)') VAL
     ELSEIF(VAL>=1.D100 .OR. VAL<=-1.D100) THEN
                                         WRITE(NUM,'(ES16.7E3)') VAL
     ELSEIF(VAL>=1.D10 .OR. VAL<=-1.D10)   THEN
                                         WRITE(NUM,'(ES16.7E2)') VAL
     ELSEIF( DVAL10 == AINT(DVAL10) .AND. (DVAL10>=1.d0.OR.DVAL10<=-1.d0) ) THEN
                                                                          WRITE(NUM,'(F16.1)') VAL
     ELSEIF( DVAL1C == AINT(DVAL1C) .AND. (DVAL1C>=1.d0.OR.DVAL1C<=-1.d0) ) THEN
                                                                          WRITE(NUM,'(F16.2)') VAL
     ELSEIF( DVAL1K == AINT(DVAL1K) .AND. (DVAL1K>=1.d0.OR.DVAL1K<=-1.d0) ) THEN
                                                                          WRITE(NUM,'(F16.3)') VAL
     ELSEIF(VAL>=1.D6 .OR. VAL<=-1.D6)            THEN
                                                  WRITE(NUM,'(ES16.7E1)') VAL
     ELSEIF(VAL>=1.D2 .OR. VAL<=-1.D2 )           THEN
                                                  WRITE(NUM,'(F16.5)') VAL
     ELSEIF(VAL>=0.00099D0 .OR. VAL<=-0.00099D0 ) THEN
                                                  WRITE(NUM,'(F16.7)') VAL
     ELSEIF(VAL>=1.D-9 .OR. VAL<=-1.D-9)          THEN
                                                  WRITE(NUM,'(ES16.7E1)') VAL
     ELSEIF(VAL>=1.D-99 .OR. VAL<=-1.D-99)        THEN
                                                  WRITE(NUM,'(ES16.7E2)') VAL
     ELSE
                                                  WRITE(NUM,'(ES16.7E3)') VAL
     END IF
     !
     NUM = ADJUSTL(NUM)
     !    
     IF(PRESENT(PAD)) THEN
         N = LEN_TRIM(NUM)
         IF( N < ABS(PAD)) THEN
                 IF (PAD>0) THEN
                            CH%VEC(CH%N)%STR = REPEAT(' ',PAD-N)//TRIM(NUM)
                 ELSE
                            CH%VEC(CH%N)%STR = TRIM(NUM)//REPEAT(' ', N+PAD)   !ABS(PAD)-N
                 END IF
         ELSE
             CH%VEC(CH%N)%STR = TRIM(NUM)
         END IF
     ELSE
             CH%VEC(CH%N)%STR = TRIM(NUM)
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_INT_CHARACTER_TYPE_ARRAY(CH, VAL, PAD, ZPAD)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     INTEGER(INT32),              INTENT(IN   ):: VAL
     INTEGER,           OPTIONAL, INTENT(IN   ):: PAD
     LOGICAL,           OPTIONAL, INTENT(IN   ):: ZPAD
     CHARACTER(32)::NUM
     INTEGER:: N
     !
     IF(CH%N + ONE > CH%DIM) CALL EXTEND_CHARACTER_TYPE_ARRAY(CH)
     CH%N = CH%N + ONE
     !
     WRITE(NUM,'(I32)') VAL
     !
     NUM=ADJUSTL(NUM)
     IF(PRESENT(PAD)) THEN
           !
           N = LEN_TRIM(NUM)
           IF(N < ABS(PAD)) THEN
                 IF (PAD>0) THEN
                            IF(PRESENT(ZPAD)) THEN 
                                IF(ZPAD) THEN
                                    CH%VEC(CH%N)%STR = REPEAT('0',PAD-N)//TRIM(NUM)
                                ELSE
                                    CH%VEC(CH%N)%STR = REPEAT(' ',PAD-N)//TRIM(NUM)
                                END IF
                            ELSE
                                    CH%VEC(CH%N)%STR = REPEAT(' ',PAD-N)//TRIM(NUM)
                            END IF
                 ELSE
                                    CH%VEC(CH%N)%STR = TRIM(NUM)//REPEAT(' ',N+PAD)
                 END IF
           ELSE
                                    CH%VEC(CH%N)%STR = TRIM(NUM)
           END IF
     ELSE
                                    CH%VEC(CH%N)%STR = TRIM(NUM)
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_UNIQUE_CHARACTER_TYPE_ARRAY(CH, STR, IGNORE_CASE)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     CHARACTER(*),                INTENT(IN   ):: STR
     LOGICAL,           OPTIONAL, INTENT(IN   ):: IGNORE_CASE
     INTEGER:: CNT
     !
     CNT = NEG
     !
     IF(PRESENT(IGNORE_CASE)) THEN
             IF(IGNORE_CASE ) CNT = COUNT_NOCASE_CHARACTER_TYPE_ARRAY(CH, STR, IGNORE_CASE)
     END IF
     !
     IF(CNT == NEG) CNT = COUNT_CHARACTER_TYPE_ARRAY(CH, STR)
     !
     IF(CNT == Z) CALL ADD_CHARACTER_TYPE_ARRAY(CH, STR)
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_UNIQUE_INT_CHARACTER_TYPE_ARRAY(CH, VAL, PAD, ZPAD)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     INTEGER(INT32),              INTENT(IN   ):: VAL
     INTEGER,           OPTIONAL, INTENT(IN   ):: PAD
     LOGICAL,           OPTIONAL, INTENT(IN   ):: ZPAD
     INTEGER:: CNT, I
     !
     CALL ADD_INT_CHARACTER_TYPE_ARRAY(CH, VAL, PAD, ZPAD)
     !
     I    = CH%N
     CH%N = CH%N + NEG
     !
     CNT = COUNT_CHARACTER_TYPE_ARRAY(CH, CH%VEC(I)%STR) 
     !
     IF(CNT == Z) CH%N = CH%N + ONE
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE ADD_UNIQUE_DBL_CHARACTER_TYPE_ARRAY(CH, VAL, PAD)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(INOUT):: CH
     REAL(DBL),                   INTENT(IN   ):: VAL
     INTEGER,           OPTIONAL, INTENT(IN   ):: PAD
     INTEGER:: CNT, I
     !
     CALL ADD_DBL_CHARACTER_TYPE_ARRAY(CH, VAL, PAD)
     !
     I    = CH%N
     CH%N = CH%N + NEG
     !
     CNT = COUNT_CHARACTER_TYPE_ARRAY(CH, CH%VEC(I)%STR) 
     !
     IF(CNT == Z) CH%N = CH%N + ONE
     !
  END SUBROUTINE
  !    
  PURE FUNCTION FIND_CHARACTER_TYPE_ARRAY(CH, STR) RESULT(P)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(IN):: CH
     CHARACTER(*),                INTENT(IN):: STR
     INTEGER:: P
     INTEGER:: I
     !
     P = Z
     DO I=ONE, CH%N
         IF(CH%VEC(I)%STR == STR) THEN
             P = I
             EXIT
         END IF
     END DO
     !
  END FUNCTION
  !    
  PURE FUNCTION COUNT_CHARACTER_TYPE_ARRAY(CH, STR) RESULT(CNT)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(IN):: CH
     CHARACTER(*),                INTENT(IN):: STR
     INTEGER:: CNT, I
     !
     CNT = Z
     DO I=ONE, CH%N
         IF(CH%VEC(I)%STR == STR) CNT = CNT + ONE
     END DO
     !
  END FUNCTION
  !    
  PURE FUNCTION COUNT_NOCASE_CHARACTER_TYPE_ARRAY(CH, STR, IGNORE_CASE) RESULT(CNT)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(IN):: CH
     CHARACTER(*),                INTENT(IN):: STR
     LOGICAL,                     INTENT(IN):: IGNORE_CASE
     CHARACTER(LEN(STR)):: UP
     ! CHARACTER(CH%MAX_LEN()):: WORD -> gfortran does not like this
     INTEGER:: MAX_LEN
     INTEGER:: CNT, J
     !
     IF(IGNORE_CASE) THEN
         MAX_LEN = CH%MAX_LEN()
         BLOCK
            CHARACTER(MAX_LEN):: WORD
            UP = STR
            CALL UPPER(UP)
            !
            CNT = Z
            DO J=ONE, CH%N
                WORD = CH%VEC(J)%STR
                !
                CALL UPPER(WORD)
                !
                IF(WORD == UP) CNT = CNT + ONE
            END DO
         END BLOCK
     ELSE
         CNT = COUNT_CHARACTER_TYPE_ARRAY(CH, STR)
     END IF
     !
  END FUNCTION
  !
  PURE SUBROUTINE REMOVE_SPECIFIED_POSITION(CH,POS,LINE) 
     CLASS(CHARACTER_TYPE_ARRAY),         INTENT(INOUT):: CH
     INTEGER,                             INTENT(IN   ):: POS
     CHARACTER(:), OPTIONAL, ALLOCATABLE, INTENT(INOUT):: LINE
     INTEGER:: I, P
     !
     IF(CH%N > Z) THEN
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = CH%N + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
         !
         IF(PRESENT(LINE)) THEN
             IF(Z < P .AND. P <= CH%N) THEN
                 CALL MOVE_ALLOC(CH%VEC(P)%STR, LINE)
             ELSE
                 LINE = BLNK
             END IF
         END IF
         !
         IF( Z < P .AND. P < CH%N ) THEN
             P = P + 1
             DO I=P, CH%N
                     CALL MOVE_ALLOC(CH%VEC(I)%STR, CH%VEC(I-ONE)%STR) 
             END DO
         END IF
         CH%N = CH%N - ONE
     ELSEIF(PRESENT(LINE)) THEN
         LINE = BLNK
     END IF
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE REMOVE_LAST_POSITION(CH, LINE) 
     CLASS(CHARACTER_TYPE_ARRAY),         INTENT(INOUT):: CH
     CHARACTER(:), OPTIONAL, ALLOCATABLE, INTENT(INOUT):: LINE
     !
     CALL REMOVE_SPECIFIED_POSITION(CH,NEG,LINE)
     !
  END SUBROUTINE
  !
  PURE FUNCTION GET_CHARACTER_TYPE_ARRAY(CH, POS) RESULT(LINE)
     CLASS(CHARACTER_TYPE_ARRAY), INTENT(IN):: CH
     INTEGER,                     INTENT(IN):: POS
     CHARACTER(:),ALLOCATABLE:: LINE
     !
     IF(Z < POS .AND. POS <= CH%N) THEN
         ALLOCATE(LINE, SOURCE=CH%VEC(POS)%STR)
     ELSE
         ALLOCATE(LINE, SOURCE=BLNK)
     END IF
     !
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CHARACTER_TYPE_ARRAY(CH)
     CLASS(CHARACTER_TYPE_ARRAY),INTENT(INOUT):: CH
     !
     IF(CH%DIM > Z) DEALLOCATE(CH%VEC)
     CH%N   = Z
     CH%DIM = Z
     !
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_CHARACTER_TYPE_ARRAY(CH)
     TYPE(CHARACTER_TYPE_ARRAY),INTENT(INOUT):: CH
     !
     IF(CH%DIM > Z) DEALLOCATE(CH%VEC)
     CH%N   = Z
     CH%DIM = Z
     !
  END SUBROUTINE  
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !
  ! CHARACTER_BUF_TYPE Routines
  !
  ELEMENTAL PURE FUNCTION COMPARE_CHAR_BUF_TYPE_STR(CH, STR) RESULT(CMP)
     CLASS(CHARACTER_BUF_TYPE),INTENT(IN):: CH
     CHARACTER(*),         INTENT(IN):: STR
     LOGICAL:: CMP
     !
     CMP = CH%STR == STR
     !
  END FUNCTION
  !
  ELEMENTAL PURE FUNCTION COMPARE_CHAR_BUF_TYPE(CH, CH_CMP) RESULT(CMP)
     CLASS(CHARACTER_BUF_TYPE),INTENT(IN):: CH
     CLASS(CHARACTER_BUF_TYPE),INTENT(IN):: CH_CMP
     LOGICAL:: CMP
     !
     CMP = CH%STR == CH_CMP%STR
     !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE SET_SIZE_CHAR_BUF_TYPE(CH, DIM)
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    INTEGER,                   INTENT(IN   ):: DIM
    CHARACTER(:), ALLOCATABLE:: STR
    INTEGER:: SIZ
    !
    SIZ = DIM
    IF(SIZ < 64) SIZ = 64
    !
    IF(.NOT. ALLOCATED(CH%STR)) THEN
                                ALLOCATE(CHARACTER(SIZ):: CH%STR)
                                CH%STR(:) = BLNK
                                CH%N   = Z
                                CH%DIM = SIZ
    ELSEIF(SIZ > CH%DIM) THEN
                                ALLOCATE(CHARACTER(SIZ):: STR)
                                STR(:) = CH%STR
                                CALL MOVE_ALLOC(STR,CH%STR)
                                CH%DIM = SIZ
    END IF
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_CHAR_BUF_TYPE(CH) RESULT(LINE)
    CLASS(CHARACTER_BUF_TYPE), INTENT(IN):: CH
    CHARACTER(:),ALLOCATABLE:: LINE
    !
    IF( CH%N > Z) THEN
        ALLOCATE(LINE, SOURCE=CH%STR(:CH%N))
    ELSE
        ALLOCATE(LINE, SOURCE=BLNK)
    END IF
    !
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE GROW_SIZE_CHAR_BUF_TYPE(CH, N) !Check if you can add N letters
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    INTEGER,                   INTENT(IN   ):: N
    INTEGER:: DIM, SIZ
    !
    SIZ = CH%N+N
    DIM = CH%DIM
    IF(SIZ > DIM) THEN
                       IF(DIM < 64) DIM = 64
                       !
                       IF (DIM < 8192) THEN
                           DO WHILE (SIZ > DIM)
                                           DIM = 2*DIM
                           END DO
                       ELSE
                           DO WHILE (SIZ > DIM)
                                           DIM = DIM + 2048
                           END DO
                       END IF
                       CALL SET_SIZE_CHAR_BUF_TYPE(CH, DIM)
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_BLANKS_CHAR_BUF_TYPE(CH,NSPACE)
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    INTEGER,                   INTENT(IN   ):: NSPACE
    INTEGER:: N
    !
    CALL GROW_SIZE_CHAR_BUF_TYPE(CH, NSPACE)
    !
    N = CH%N + NSPACE                 !New ending position
    CH%STR(CH%N+ONE : N) = BLNK
    CH%N = N
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_TO_ENDING_CHAR_BUF_TYPE(CH,LINE,TRIM_IT)
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    CHARACTER(*),              INTENT(IN   ):: LINE
    LOGICAL,         OPTIONAL, INTENT(IN   ):: TRIM_IT
    INTEGER:: N, P
    P = LEN(LINE)
    IF(PRESENT(TRIM_IT)) THEN
            IF(TRIM_IT) P = LEN_TRIM(LINE)
    END IF
    !
    CALL GROW_SIZE_CHAR_BUF_TYPE(CH, P)
    !
    N = CH%N + P                    !New ending position
    CH%STR(CH%N+ONE : N) = LINE(1:P)
    CH%N = N
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_NL_ENDING_CHAR_BUF_TYPE(CH,LINE,TRIM_IT)
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    CHARACTER(*),              INTENT(IN   ):: LINE
    LOGICAL,         OPTIONAL, INTENT(IN   ):: TRIM_IT
    INTEGER:: N, P
    P = LEN(LINE)
    IF(PRESENT(TRIM_IT)) THEN
            IF(TRIM_IT) P = LEN_TRIM(LINE)
    END IF
    !
    CALL GROW_SIZE_CHAR_BUF_TYPE(CH, P+ONE)
    !
    N = CH%N + P                    !New ending position, without the NL
    CH%STR(CH%N+ONE : N) = LINE(1:P)
    CH%N = N + ONE
    CH%STR(CH%N:CH%N) = NL
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE NL_ENDING_CHAR_BUF_TYPE(CH)
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    !
    CALL GROW_SIZE_CHAR_BUF_TYPE(CH, ONE)
    !
    CH%N = CH%N + ONE                    !New ending position
    CH%STR(CH%N:CH%N) = NL
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_TO_BEGIN_CHAR_BUF_TYPE(CH, LINE, TRIM_IT)
    CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
    CHARACTER(*),              INTENT(IN   ):: LINE
    LOGICAL,         OPTIONAL, INTENT(IN   ):: TRIM_IT
    INTEGER:: N, P
    P = LEN(LINE)
    IF(PRESENT(TRIM_IT)) THEN
            IF(TRIM_IT) P = LEN_TRIM(LINE)
    END IF
    !
    CALL GROW_SIZE_CHAR_BUF_TYPE(CH, P)
    !
    N = CH%N + P                    !New ending position
    IF(CH%N == Z) THEN
        CH%STR(1:P) = LINE(1:P)
        CH%N = P
    ELSE
        CH%STR(P+ONE : N) = CH%STR(1:CH%N)  !Move to right
        CH%STR(1:P) = LINE(1:P)             !Copy line
        CH%N = N
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE TRIM_ADD_TO_ENDING_CHAR_BUF_TYPE(CH,LINE)
     CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: LINE
     !
     CALL ADD_TO_ENDING_CHAR_BUF_TYPE(CH, LINE, TRUE)
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_CHAR_BUF_TYPE(CH,CH_OUT)
     CLASS(CHARACTER_BUF_TYPE),INTENT(INOUT):: CH
     CLASS(CHARACTER_BUF_TYPE),INTENT(INOUT):: CH_OUT
     !
     IF (CH%DIM > Z) THEN
         CALL MOVE_ALLOC(CH%STR,CH_OUT%STR)
         CH_OUT%N   = CH%N
         CH_OUT%DIM = CH%DIM
         CH%N       = Z 
         CH%DIM     = Z
     ELSE
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
         CH_OUT%N   = Z
         CH_OUT%DIM = Z
     END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE COPY_CHAR_BUF_TYPE_OPERATOR(CH_OUT,CH_IN)
    CLASS(CHARACTER_BUF_TYPE),INTENT(IN   ):: CH_IN
    CLASS(CHARACTER_BUF_TYPE),INTENT(INOUT):: CH_OUT
    !
    !IF(CH_OUT%DIM > Z) CH_OUT%STR(:) = BLNK
    !
    IF ( CH_IN%N == Z) THEN
        CH_OUT%N  = Z
    ELSE
        IF(CH_IN%DIM > CH_OUT%DIM) THEN
            IF(CH_OUT%DIM > Z) DEALLOCATE(CH_OUT%STR)
            ALLOCATE(CH_OUT%STR, SOURCE=CH_IN%STR)
        ELSE
            CH_OUT%STR(1:CH_IN%N) = CH_IN%STR(1:CH_IN%N)
            CH_OUT%N = CH_IN%N
        END IF
    END IF
  END SUBROUTINE
  !
  ELEMENTAL PURE SUBROUTINE SET_CHAR_BUF_TYPE_OPERATOR(CH,LINE)
     CLASS(CHARACTER_BUF_TYPE), INTENT(INOUT):: CH
     CHARACTER(*),              INTENT(IN   ):: LINE
     !
     !IF(CH_OUT%DIM > Z) CH_OUT%STR(:) = BLNK
     CH%N = Z
     CALL ADD_TO_ENDING_CHAR_BUF_TYPE(CH,LINE)
    !
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CHAR_BUF_TYPE(CH)
     CLASS(CHARACTER_BUF_TYPE),INTENT(INOUT):: CH
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     CH%N = Z 
     CH%DIM = Z 
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_CHAR_BUF_TYPE(CH)
     TYPE(CHARACTER_BUF_TYPE),INTENT(INOUT):: CH
     CALL DEALLOCATE_CHAR_BUF_TYPE(CH)
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! CHARACTER_ARRAY Routines
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_CHARACTER_ARRAY(CH,MAX_LEN,DIM)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     INTEGER,               INTENT(IN   ):: MAX_LEN, DIM
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     ALLOCATE(CHARACTER(MAX_LEN)::CH%STR(DIM))
     CH%N=DIM
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_CHARACTER_ARRAY_STR(CH,STR,MAX_LEN,DIM)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: STR
     INTEGER, OPTIONAL,     INTENT(IN   ):: MAX_LEN, DIM
     INTEGER:: LIN_LEN, NDIM
     !
     LIN_LEN = LEN(STR)
     IF(LIN_LEN < ONE) LIN_LEN = ONE
     !
     NDIM    = ONE
     IF(PRESENT(MAX_LEN)) LIN_LEN = MAX_LEN
     IF(PRESENT(DIM))     NDIM    = DIM
     !
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     ALLOCATE(CHARACTER(LIN_LEN)::CH%STR(NDIM))
     CH%N=NDIM
     !
     CH%STR(ONE) = STR
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_CHARACTER_ARRAY(CH,CH_OUT)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH_OUT
     !
     IF (CH%N > 0) THEN
         CH_OUT%N = CH%N
         CH%N     = Z
         CALL MOVE_ALLOC(CH%STR,CH_OUT%STR)
     ELSE
         CH_OUT%N = Z
         IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_CHARACTER_ARRAY_OPERATOR(CH_OUT,CH_IN)
     CLASS(CHARACTER_ARRAY),INTENT(IN   ):: CH_IN
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH_OUT
     INTEGER:: I
      !
      IF (CH_IN%N > Z) THEN
          IF(CH_OUT%N /= CH_IN%N) THEN
                                    I  = LEN(CH_IN%STR)
                                    CH_OUT%N = CH_IN%N
                                    IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
                                    ALLOCATE(CHARACTER(I):: CH_OUT%STR(CH_IN%N) )
          END IF
          !
          DO I=ONE, CH_IN%N
                           CH_OUT%STR(I)(:) = CH_IN%STR(I)
          END DO
      ELSE
          CH_OUT%N = Z
          IF(ALLOCATED(CH_OUT%STR)) DEALLOCATE(CH_OUT%STR)
      END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_ROW_CHARACTER_ARRAY(CH,STR)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: STR
     INTEGER:: MAX_LEN, DIM
     CHARACTER(:),DIMENSION(:), ALLOCATABLE::TMP
     !
     IF (CH%N > 0) THEN
         DIM  = CH%N
         CH%N = CH%N + ONE
         MAX_LEN = LEN(CH%STR)
         IF(MAX_LEN < LEN(STR)) MAX_LEN = LEN(STR)
         !
         ALLOCATE(CHARACTER(MAX_LEN)::TMP(DIM+ONE))
         !
         TMP(:DIM) = CH%STR
         TMP(DIM+ONE) = STR
         !
         CALL MOVE_ALLOC(TMP,CH%STR)
         !CALL MOVE_ALLOC_CHARACTER_ARRAY(TMP,CH%STR)
     ELSE
         CALL ALLOCATE_CHARACTER_ARRAY_STR(CH,STR)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_UNIQUE_ROW_CHARACTER_ARRAY(CH,STR,POS)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     CHARACTER(*),          INTENT(IN   ):: STR
     INTEGER,     OPTIONAL, INTENT(OUT  ):: POS
     INTEGER:: I
     LOGICAL:: NOT_FOUND
     !
     IF (CH%N > 0) THEN
         !
         IF(PRESENT(POS)) POS = Z
         NOT_FOUND = TRUE
         !
         DO I = ONE, CH%N
             IF(STR == CH%STR(I)) THEN
                 IF(PRESENT(POS)) POS = I
                 NOT_FOUND = FALSE
                 EXIT
             END IF
         END DO
         !
         IF(NOT_FOUND) CALL ADD_ROW_CHARACTER_ARRAY(CH,STR)
     ELSE
         CALL ALLOCATE_CHARACTER_ARRAY_STR(CH,STR)
         IF(PRESENT(POS)) POS = ONE
     END IF
  END SUBROUTINE
  !
  PURE FUNCTION GET_CHARACTER_ROW(CH,POS) RESULT (STR)
     CLASS(CHARACTER_ARRAY),INTENT(IN):: CH
     INTEGER,               INTENT(IN):: POS
     CHARACTER(:), ALLOCATABLE::STR
     !
     IF(Z < POS .AND. POS <= CH%N) THEN
         ALLOCATE(STR, SOURCE=CH%STR(POS))
     ELSE
         ALLOCATE(STR, SOURCE='ERROR')
     END IF
  END FUNCTION
  !
  PURE FUNCTION GET_CHARACTER_POSITION(CH,STR) RESULT (POS)
     CLASS(CHARACTER_ARRAY),INTENT(IN):: CH
     CHARACTER(*),          INTENT(IN):: STR
     INTEGER:: POS
     INTEGER:: I
     !
     POS = Z
     DO I = ONE, CH%N
         IF(STR == CH%STR(I)) THEN
             POS = I
             EXIT
         END IF
     END DO
     !
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_CHARACTER_ARRAY(CH)
     CLASS(CHARACTER_ARRAY),INTENT(INOUT):: CH
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     CH%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_CHARACTER_ARRAY(CH)
     TYPE(CHARACTER_ARRAY),INTENT(INOUT):: CH
     IF(ALLOCATED(CH%STR)) DEALLOCATE(CH%STR)
     CH%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! DOUBLE_VECTOR Routines
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_DOUBLE_VECTOR(DB,DIM,VAL)
     CLASS(DOUBLE_VECTOR),       INTENT(INOUT):: DB
     INTEGER,                    INTENT(IN   ):: DIM
     DOUBLE PRECISION, OPTIONAL, INTENT(IN   ):: VAL
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
         DB%N=Z
     ELSEIF(PRESENT(VAL)) THEN
        IF(DB%N /= DIM) THEN
            IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
            ALLOCATE(DB%VEC(DIM), SOURCE=VAL)
            DB%N=DIM
        ELSE
            DB%VEC = VAL
        END IF
     ELSEIF(DB%N /= DIM) THEN
            IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
            ALLOCATE(DB%VEC(DIM))
            DB%N=DIM
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_DOUBLE_VECTOR(DB,DB_OUT)
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB_OUT
     !
     IF (DB%N > 0) THEN
         DB_OUT%N = DB%N
         DB%N     = Z
         CALL MOVE_ALLOC(DB%VEC,DB_OUT%VEC)
     ELSE
         DB_OUT%N = Z
         IF(ALLOCATED(DB_OUT%VEC)) DEALLOCATE(DB_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_DOUBLE_VECTOR_OPERATOR(DB_OUT,DB_IN)
     CLASS(DOUBLE_VECTOR),INTENT(IN   ):: DB_IN
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB_OUT
      !
      IF (DB_IN%N > Z) THEN
          DB_OUT%N = DB_IN%N
          IF(ALLOCATED(DB_OUT%VEC)) DEALLOCATE(DB_OUT%VEC)
          ALLOCATE(DB_OUT%VEC, SOURCE=DB_IN%VEC)
      ELSE
          DB_OUT%N = Z
          IF(ALLOCATED(DB_OUT%VEC)) DEALLOCATE(DB_OUT%VEC)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_DOUBLE_VECTOR_OPERATOR(DB_OUT,VEC)
     DOUBLE PRECISION,DIMENSION(:), INTENT(IN   ):: VEC
     CLASS(DOUBLE_VECTOR),          INTENT(INOUT):: DB_OUT
     INTEGER:: N
     LOGICAL:: ALLOC
     N     = SIZE(VEC)
     ALLOC = ALLOCATED(DB_OUT%VEC)
     !
     IF (N > Z) THEN
         IF(DB_OUT%N == SIZE(VEC) .AND. ALLOC) THEN
                           DB_OUT%VEC = VEC
         ELSEIF(ALLOC) THEN
                DEALLOCATE(DB_OUT%VEC)
                  ALLOCATE(DB_OUT%VEC, SOURCE=VEC)
         ELSE
               ALLOCATE(DB_OUT%VEC, SOURCE=VEC)
         END IF
     ELSE
         DB_OUT%N = Z
         IF(ALLOC) DEALLOCATE(DB_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_DOUBLE_VEC_BY_INDEX(DB,POS) RESULT (VAL)
     CLASS(DOUBLE_VECTOR),INTENT(IN):: DB
     INTEGER,             INTENT(IN):: POS
     DOUBLE PRECISION:: VAL
     !
     IF(Z < POS .AND. POS <= DB%N) THEN
         VAL=DB%VEC(POS)
     ELSE
         VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
     END IF
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_DOUBLE_VECTOR(DB)
     CLASS(DOUBLE_VECTOR),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
     DB%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_DOUBLE_VECTOR(DB)
     TYPE(DOUBLE_VECTOR),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%VEC)) DEALLOCATE(DB%VEC)
     DB%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! DOUBLE_MATRIX Routines
  ! 
  PURE SUBROUTINE INIT_DOUBLE_MATRIX_OPERATOR(DB,MAT)
     CLASS(DOUBLE_MATRIX),             INTENT(INOUT):: DB
     DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_DOUBLE_MATRIX_SRC(DB,DIM1,DIM2,MAT)
  END SUBROUTINE
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_DOUBLE_MATRIX(DB,DIM1,DIM2,SRC)
     CLASS(DOUBLE_MATRIX),         INTENT(INOUT):: DB
     INTEGER,                      INTENT(IN   ):: DIM1,DIM2
     DOUBLE PRECISION,    OPTIONAL,INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         DB%N=Z
         DB%M=Z
     ELSEIF(DB%N /= DIM1 .OR. DB%M /= DIM2) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         IF(PRESENT(SRC)) THEN
                             ALLOCATE(DB%MAT(DIM1,DIM2), SOURCE=SRC)
         ELSE
                             ALLOCATE(DB%MAT(DIM1,DIM2))
         END IF
         DB%N=DIM1
         DB%M=DIM2
    ELSEIF(PRESENT(SRC)) THEN
        DB%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOCATE_DOUBLE_MATRIX_SRC(DB,DIM1,DIM2,SRC)
     CLASS(DOUBLE_MATRIX),                  INTENT(INOUT):: DB
     INTEGER,                               INTENT(IN   ):: DIM1,DIM2
     DOUBLE PRECISION, DIMENSION(DIM1,DIM2),INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         DB%N=Z
         DB%M=Z
     ELSEIF(DB%N /= DIM1 .OR. DB%M /= DIM2) THEN
         IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
         !
         ALLOCATE(DB%MAT(DIM1,DIM2), SOURCE=SRC)
         DB%N=DIM1
         DB%M=DIM2
    ELSE
        DB%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_DOUBLE_MATRIX(DB,DB_OUT)
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB_OUT
     !
     IF (DB%N > 0) THEN
         DB_OUT%N = DB%N
         DB_OUT%M = DB%M
         DB%N     = Z
         DB%M     = Z
         CALL MOVE_ALLOC(DB%MAT,DB_OUT%MAT)
     ELSE
         DB_OUT%N = Z
         DB_OUT%M = Z
         IF(ALLOCATED(DB_OUT%MAT)) DEALLOCATE(DB_OUT%MAT)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_DOUBLE_MATRIX_OPERATOR(DB_OUT,DB_IN)
     CLASS(DOUBLE_MATRIX),INTENT(IN   ):: DB_IN
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB_OUT
      !
      IF (DB_IN%N > Z) THEN
          DB_OUT%N = DB_IN%N
          DB_OUT%M = DB_IN%M
          IF(ALLOCATED(DB_OUT%MAT)) DEALLOCATE(DB_OUT%MAT)
          ALLOCATE(DB_OUT%MAT, SOURCE=DB_IN%MAT)
      ELSE
          DB_OUT%N = Z
          DB_OUT%M = Z
          IF(ALLOCATED(DB_OUT%MAT)) DEALLOCATE(DB_OUT%MAT)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_DOUBLE_MATRIX_OPERATOR(DB_OUT,MAT)
     CLASS(DOUBLE_MATRIX),             INTENT(INOUT):: DB_OUT
     DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_DOUBLE_MATRIX_SRC(DB_OUT,DIM1,DIM2,MAT)
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_DOUBLE_MAT_BY_INDEX(DB,POS1,POS2) RESULT (VAL)
     CLASS(DOUBLE_MATRIX),INTENT(IN):: DB
     INTEGER,             INTENT(IN):: POS1,POS2
     DOUBLE PRECISION:: VAL
     !
     IF(Z < POS1 .AND. POS1 <= DB%N .AND. Z < POS2 .AND. POS2 <= DB%M) THEN
         VAL=DB%MAT(POS1,POS2)
     ELSE
         VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
     END IF
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE SET_DOUBLE_MAT_BY_2_INDEX(DB,POS1,POS2,VAL)
     CLASS(DOUBLE_MATRIX), INTENT(INOUT):: DB
     INTEGER,              INTENT(IN   ):: POS1,POS2
     DOUBLE PRECISION,     INTENT(IN   ):: VAL
     !
     IF(Z < POS1 .AND. POS1 <= DB%N .AND. Z < POS2 .AND. POS2 <= DB%M)  DB%MAT(POS1,POS2) = VAL
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_DOUBLE_MAT_BY_1_INDEX(DB,POS,VEC,DIMSET)
     CLASS(DOUBLE_MATRIX),                     INTENT(INOUT):: DB
     INTEGER,                                  INTENT(IN   ):: POS
     DOUBLE PRECISION,DIMENSION(:),CONTIGUOUS, INTENT(IN   ):: VEC
     INTEGER,                      OPTIONAL,   INTENT(IN   ):: DIMSET
     INTEGER:: DIM
     !
     IF(PRESENT(DIMSET)) THEN
         IF    (DIMSET==1) THEN
                               DIM = NEG
         ELSEIF(DIMSET==2) THEN
                               DIM = NINER
         ELSE
                               DIM = SIZE(VEC)
         END IF
    ELSE
                               DIM = SIZE(VEC)
    END IF
    !
    IF    (DIM == DB%N .OR. DIM == NEG  ) THEN
                                              DB%MAT(:,POS) = VEC
    ELSEIF(DIM == DB%M .OR. DIM == NINER) THEN
                                              DB%MAT(POS,:) = VEC
    END IF
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_DOUBLE_MATRIX(DB)
     CLASS(DOUBLE_MATRIX),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
     DB%N=Z
     DB%M=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_DOUBLE_MATRIX(DB)
     TYPE(DOUBLE_MATRIX),INTENT(INOUT):: DB
     IF(ALLOCATED(DB%MAT)) DEALLOCATE(DB%MAT)
     DB%N=Z
     DB%M=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! INTEGER_VECTOR Routines
  ! 
  PURE SUBROUTINE INIT_INTEGER_VECTOR(IT,VEC)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER, DIMENSION(:),INTENT(IN   ):: VEC
     !
     CALL ALLOCATE_INTEGER_VECTOR(IT,SIZE(VEC))
     IT%VEC = VEC
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_INTEGER_VECTOR(IT,DIM,IVAL)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,             INTENT(IN   ):: DIM
     INTEGER, OPTIONAL,   INTENT(IN   ):: IVAL
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
         IT%N=Z
     ELSEIF(IT%N /= DIM) THEN
         IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
         ALLOCATE(IT%VEC(DIM))
         IT%N=DIM
    END IF
    !
    IF(PRESENT(IVAL) .AND. IT%N > Z) THEN
        IT%VEC = IVAL
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_INTEGER_VECTOR_VALUE(IT,POS,VAL)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: POS,VAL
     !
     IF(IT%N < ONE) CALL ALLOCATE_INTEGER_VECTOR(IT,POS)
     !
     IF(POS  <=  IT%N) THEN
          IT%VEC(POS) = VAL
     ELSEIF(POS > IT%N) THEN
        BLOCK 
            TYPE(INTEGER_VECTOR):: IT2
            CALL IT%MOVE(IT2)
            CALL ALLOCATE_INTEGER_VECTOR(IT,POS)
            CALL IT2%COPY(IT)
            IT%VEC(POS) = VAL
        END BLOCK
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_VAL_INTEGER_VECTOR(IT,IVAL,POS)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: IVAL
     INTEGER,    OPTIONAL, INTENT(IN   ):: POS
     INTEGER, DIMENSION(:), ALLOCATABLE:: TMP
     INTEGER:: P
     !
     IF(PRESENT(POS)) THEN
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = IT%N + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
     ELSE
                  P = IT%N + ONE
     END IF
     !
     IF (IT%N > 0) THEN
         !
         IT%N = IT%N + ONE
         !
         ALLOCATE(TMP(IT%N))
         !
         IF    ( P==IT%N ) THEN
                               TMP(  :IT%N-1) = IT%VEC
                               TMP(IT%N)      = IVAL
         ELSEIF( P==ONE ) THEN
                               TMP(ONE ) = IVAL
                               TMP(TWO:) = IT%VEC
         ELSE
                               TMP(:P-1) = IT%VEC(:P-1)
                               TMP(P)    = IVAL
                               TMP(P+1:) = IT%VEC(P:)
         END IF
         !
         CALL MOVE_ALLOC(TMP,IT%VEC)
     ELSE
         CALL ALLOCATE_INTEGER_VECTOR(IT, ONE, IVAL)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_UNIQUE_VAL_INTEGER_VECTOR(IT,IVAL)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: IVAL
     !
     IF (IT%N > 0) THEN
         !
         IF(ALL(IVAL /= IT%VEC)) CALL ADD_VAL_INTEGER_VECTOR(IT,IVAL)
     ELSE
         CALL ALLOCATE_INTEGER_VECTOR(IT, ONE, IVAL)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_INTEGER_VECTOR(IT,IT_OUT)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     TYPE (INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
     !
     IF (IT%N > 0) THEN
         IT_OUT%N = IT%N
         IT%N     = Z
         CALL MOVE_ALLOC(IT%VEC,IT_OUT%VEC)
     ELSE
         IT_OUT%N = Z
         IF(ALLOCATED(IT_OUT%VEC)) DEALLOCATE(IT_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_INTEGER_VECTOR_OPERATOR(IT_OUT,IT_IN)
     CLASS(INTEGER_VECTOR),INTENT(IN   ):: IT_IN
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
      !
      IF (IT_IN%N > Z) THEN
          IF (IT_OUT%N == IT_IN%N) THEN
              IT_OUT%VEC= IT_IN%VEC
          ELSE
              IT_OUT%N = IT_IN%N
              IF(ALLOCATED(IT_OUT%VEC)) DEALLOCATE(IT_OUT%VEC)
              ALLOCATE(IT_OUT%VEC, SOURCE=IT_IN%VEC)
          END IF
      ELSE
          IT_OUT%N = Z
          IF(ALLOCATED(IT_OUT%VEC)) DEALLOCATE(IT_OUT%VEC)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_INTEGER_VECTOR_OPERATOR(IT_OUT,VEC)
     INTEGER, DIMENSION(:),INTENT(IN   ):: VEC
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
     INTEGER:: N
     LOGICAL:: ALLOC
     !
     N     = SIZE(VEC)
     ALLOC = ALLOCATED(IT_OUT%VEC)
     !
     IF (N > Z) THEN
         IF(IT_OUT%N == SIZE(VEC) .AND. ALLOC) THEN
                           IT_OUT%VEC = VEC
         ELSEIF(ALLOC) THEN
                DEALLOCATE(IT_OUT%VEC)
                  ALLOCATE(IT_OUT%VEC, SOURCE=VEC)
         ELSE
               ALLOCATE(IT_OUT%VEC, SOURCE=VEC)
         END IF
     ELSE
         IT_OUT%N = Z
         IF(ALLOC) DEALLOCATE(IT_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE TRANSFER_INTEGER_VECTOR(IT,IT_OUT)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT_OUT
     !
     IF (IT%N > 0) THEN
         IF(IT%N <= IT_OUT%N) THEN
             IT_OUT%VEC(:IT%N) = IT%VEC
         ELSE
             IT_OUT = IT
         END IF
     END IF
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_INTEGER_BY_INDEX(IT,POS) RESULT (VAL)
     CLASS(INTEGER_VECTOR),INTENT(IN):: IT
     INTEGER,             INTENT(IN):: POS
     INTEGER :: VAL
     !
     IF(Z < POS .AND. POS <= IT%N) THEN
         VAL=IT%VEC(POS)
     ELSE
         VAL = inf_I
     END IF
  END FUNCTION
  !
  PURE ELEMENTAL FUNCTION FIND_INT_POS_INTEGER_VECTOR(IT, IVAL) RESULT(IDX)
    CLASS(INTEGER_VECTOR),INTENT(IN):: IT
    INTEGER,              INTENT(IN):: IVAL
    INTEGER:: IDX
    INTEGER:: I
    !
    IDX = Z
    DO I=ONE, IT%N
        IF(IVAL == IT%VEC(I)) THEN
            IDX = I
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION IS_UNIQUE_INTEGER_VECTOR(IT,I) RESULT(ANS)
    CLASS(INTEGER_VECTOR),INTENT(IN):: IT
    INTEGER,                     INTENT(IN):: I
    LOGICAL:: ANS
    !
    IF(IT%N > Z) THEN
        ANS = ALL(I /= IT%VEC)
    ELSE
        ANS = TRUE
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION NOT_UNIQUE_INTEGER_VECTOR(IT,I) RESULT(ANS)
    CLASS(INTEGER_VECTOR),INTENT(IN):: IT
    INTEGER,              INTENT(IN):: I
    LOGICAL:: ANS
    !
    IF(IT%N > Z) THEN
        ANS = ANY(I == IT%VEC)
    ELSE
        ANS = FALSE
    END IF
    !
  END FUNCTION
  !
  PURE SUBROUTINE REMOVE_LOCATION_INTEGER_VECTOR(IT,POS)
    CLASS(INTEGER_VECTOR), INTENT(INOUT):: IT
    INTEGER, OPTIONAL,     INTENT(IN   ):: POS
    INTEGER, DIMENSION(:), ALLOCATABLE:: TMP
    INTEGER:: N
    !
    N = IT%N - ONE
    !
    IF(IT%N <= ONE) THEN
        !
        N = Z
        IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC) 
        !
    ELSEIF(PRESENT(POS)) THEN
        IF(POS == ONE) THEN 
                                 ALLOCATE(TMP, SOURCE=IT%VEC(TWO:))
                                 CALL MOVE_ALLOC(TMP,IT%VEC)
        ELSEIF(POS == IT%N) THEN
                                 ALLOCATE(TMP, SOURCE=IT%VEC(:N))
                                 CALL MOVE_ALLOC(TMP,IT%VEC)
        ELSE
                                 ALLOCATE(TMP(N))
                                 TMP(:POS-ONE ) = IT%VEC(:POS-ONE )
                                 TMP( POS+ONE:) = IT%VEC( POS+ONE:)
                                 CALL MOVE_ALLOC(TMP,IT%VEC)
        END IF
    ELSE
        ALLOCATE(TMP, SOURCE=IT%VEC(:N))
        CALL MOVE_ALLOC(TMP,IT%VEC)
    END IF
    !
    IT%N = N
    !
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_INTEGER_VECTOR(IT)
     TYPE(INTEGER_VECTOR),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
     IT%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_INTEGER_VECTOR(IT)
     CLASS(INTEGER_VECTOR),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%VEC)) DEALLOCATE(IT%VEC)
     IT%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! INTEGER_MATRIX Routines
  ! 
  PURE SUBROUTINE INIT_INTEGER_MATRIX_OPERATOR(IT,MAT)
     CLASS(INTEGER_MATRIX),   INTENT(INOUT):: IT
     INTEGER, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_INTEGER_MATRIX_SRC(IT,DIM1,DIM2,MAT)
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ALLOCATE_INTEGER_MATRIX(IT,DIM1,DIM2,SRC)
     CLASS(INTEGER_MATRIX),        INTENT(INOUT):: IT
     INTEGER,                      INTENT(IN   ):: DIM1,DIM2
     INTEGER,             OPTIONAL,INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         IT%N=Z
         IT%M=Z
     ELSEIF(IT%N /= DIM1 .OR. IT%M /= DIM2) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         IF(PRESENT(SRC)) THEN
                             ALLOCATE(IT%MAT(DIM1,DIM2), SOURCE=SRC)
         ELSE
                             ALLOCATE(IT%MAT(DIM1,DIM2))
         END IF
         IT%N=DIM1
         IT%M=DIM2
    ELSEIF(PRESENT(SRC)) THEN
        IT%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOCATE_INTEGER_MATRIX_SRC(IT,DIM1,DIM2,SRC)
     CLASS(INTEGER_MATRIX),                  INTENT(INOUT):: IT
     INTEGER,                               INTENT(IN   ):: DIM1,DIM2
     INTEGER, DIMENSION(DIM1,DIM2),INTENT(IN   ):: SRC
     !
     IF(DIM1 < ONE .OR. DIM2 < ONE) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         IT%N=Z
         IT%M=Z
     ELSEIF(IT%N /= DIM1 .OR. IT%M /= DIM2) THEN
         IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
         !
         ALLOCATE(IT%MAT(DIM1,DIM2), SOURCE=SRC)
         IT%N=DIM1
         IT%M=DIM2
    ELSE
        IT%MAT = SRC
    END IF
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_INTEGER_MATRIX(IT,IT_OUT)
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT_OUT
     !
     IF (IT%N > 0) THEN
         IT_OUT%N = IT%N
         IT_OUT%M = IT%M
         IT%N     = Z
         IT%M     = Z
         CALL MOVE_ALLOC(IT%MAT,IT_OUT%MAT)
     ELSE
         IT_OUT%N = Z
         IT_OUT%M = Z
         IF(ALLOCATED(IT_OUT%MAT)) DEALLOCATE(IT_OUT%MAT)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_INTEGER_MATRIX_OPERATOR(IT_OUT,IT_IN)
     CLASS(INTEGER_MATRIX),INTENT(IN   ):: IT_IN
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT_OUT
      !
      IF (IT_IN%N > Z) THEN
          IT_OUT%N = IT_IN%N
          IT_OUT%M = IT_IN%M
          IF(ALLOCATED(IT_OUT%MAT)) DEALLOCATE(IT_OUT%MAT)
          ALLOCATE(IT_OUT%MAT, SOURCE=IT_IN%MAT)
      ELSE
          IT_OUT%N = Z
          IT_OUT%M = Z
          IF(ALLOCATED(IT_OUT%MAT)) DEALLOCATE(IT_OUT%MAT)
      END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_INTEGER_MATRIX_OPERATOR(IT,MAT)
     CLASS(INTEGER_MATRIX),   INTENT(INOUT):: IT
     INTEGER, DIMENSION(:,:), INTENT(IN   ):: MAT
     INTEGER:: DIM1,DIM2
     !
     DIM1 = SIZE(MAT,1)
     DIM2 = SIZE(MAT,2)
     !
     CALL ALLOCATE_INTEGER_MATRIX_SRC(IT,DIM1,DIM2,MAT)
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_INTEGER_MAT_BY_INDEX(IT,POS1,POS2) RESULT (VAL)
     CLASS(INTEGER_MATRIX),INTENT(IN):: IT
     INTEGER,             INTENT(IN):: POS1,POS2
     INTEGER:: VAL
     !
     IF(Z < POS1 .AND. POS1 <= IT%N .AND. Z < POS2 .AND. POS2 <= IT%M) THEN
         VAL=IT%MAT(POS1,POS2)
     ELSE
         VAL = inf_I
     END IF
  END FUNCTION
  !
  PURE ELEMENTAL SUBROUTINE SET_INTEGER_MAT_BY_2_INDEX(IT,POS1,POS2,IVAL)
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT
     INTEGER,              INTENT(IN   ):: POS1,POS2,IVAL
     !
     IF(Z < POS1 .AND. POS1 <= IT%N .AND. Z < POS2 .AND. POS2 <= IT%M)  IT%MAT(POS1,POS2) = IVAL
     !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_INTEGER_MAT_BY_1_INDEX(IT,POS,VEC,DIMSET)
     CLASS(INTEGER_MATRIX),           INTENT(INOUT):: IT
     INTEGER,                         INTENT(IN   ):: POS
     INTEGER,DIMENSION(:),CONTIGUOUS, INTENT(IN   ):: VEC
     INTEGER,             OPTIONAL,   INTENT(IN   ):: DIMSET
     INTEGER:: DIM
     !
     IF(PRESENT(DIMSET)) THEN
         IF    (DIMSET==1) THEN
                               DIM = NEG
         ELSEIF(DIMSET==2) THEN
                               DIM = NINER
         ELSE
                               DIM = SIZE(VEC)
         END IF
    ELSE
                               DIM = SIZE(VEC)
    END IF
    !
    IF    (DIM == IT%N .OR. DIM == NEG  ) THEN
                                              IT%MAT(:,POS) = VEC
    ELSEIF(DIM == IT%M .OR. DIM == NINER) THEN
                                              IT%MAT(POS,:) = VEC
    END IF
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_INTEGER_MATRIX(IT)
     CLASS(INTEGER_MATRIX),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
     IT%N=Z
     IT%M=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_INTEGER_MATRIX(IT)
     TYPE(INTEGER_MATRIX),INTENT(INOUT):: IT
     IF(ALLOCATED(IT%MAT)) DEALLOCATE(IT%MAT)
     IT%N=Z
     IT%M=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! LOGICAL_VECTOR Routines
  ! 
  PURE ELEMENTAL SUBROUTINE ALLOCATE_LOGICAL_VECTOR(TF,DIM,LVAL)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     INTEGER,              INTENT(IN   ):: DIM
     LOGICAL, OPTIONAL,    INTENT(IN   ):: LVAL
     !
     IF(DIM < ONE) THEN
         IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
         TF%N=Z
     ELSEIF(TF%N /= DIM) THEN
         IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
         ALLOCATE(TF%VEC(DIM))
         TF%N=DIM
     END IF
     !
     IF(PRESENT(LVAL) .AND. TF%N > Z) THEN
         TF%VEC = LVAL
     END IF
     !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE ADD_VAL_LOGICAL_VECTOR(TF,LVAL,POS)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     LOGICAL,              INTENT(IN   ):: LVAL
     INTEGER,    OPTIONAL, INTENT(IN   ):: POS
     LOGICAL,  DIMENSION(:), ALLOCATABLE:: TMP
     INTEGER:: P
     !
     IF(PRESENT(POS)) THEN
         IF    (POS >= 0) THEN
                 P = POS
         ELSEIF(POS < 0) THEN
                 P = TF%N + POS + ONE  !-1 IS THE END OF THE LIST
         END IF
     ELSE
                  P = TF%N + ONE
     END IF
     !
     IF (TF%N > 0) THEN
         !
         TF%N = TF%N + ONE
         !
         ALLOCATE(TMP(TF%N))
         !
         IF    ( P==TF%N ) THEN
                               TMP(  :TF%N-1) = TF%VEC
                               TMP(TF%N)      = LVAL
         ELSEIF( P==ONE ) THEN
                               TMP(ONE ) = LVAL
                               TMP(TWO:) = TF%VEC
         ELSE
                               TMP(:P-1) = TF%VEC(:P-1)
                               TMP(P)    = LVAL
                               TMP(P+1:) = TF%VEC(P:)
         END IF
         !
         CALL MOVE_ALLOC(TMP,TF%VEC)
     ELSE
         CALL ALLOCATE_LOGICAL_VECTOR(TF, ONE, LVAL)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE MOVE_LOGICAL_VECTOR(TF,TF_OUT)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF_OUT
     !
     IF (TF%N > 0) THEN
         TF_OUT%N = TF%N
         TF%N     = Z
         CALL MOVE_ALLOC(TF%VEC,TF_OUT%VEC)
     ELSE
         TF_OUT%N = Z
         IF(ALLOCATED(TF_OUT%VEC)) DEALLOCATE(TF_OUT%VEC)
     END IF
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE COPY_LOGICAL_VECTOR_OPERATOR(TF_OUT,TF_IN)
     CLASS(LOGICAL_VECTOR),INTENT(IN   ):: TF_IN
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF_OUT
      !
      IF (TF_IN%N > Z) THEN
          TF_OUT%N = TF_IN%N
          IF(ALLOCATED(TF_OUT%VEC)) DEALLOCATE(TF_OUT%VEC)
          ALLOCATE(TF_OUT%VEC, SOURCE=TF_IN%VEC)
      ELSE
          TF_OUT%N = Z
          IF(ALLOCATED(TF_OUT%VEC)) DEALLOCATE(TF_OUT%VEC)
      END IF
  END SUBROUTINE
  !
  IMPURE ELEMENTAL FUNCTION GET_LOGICAL_BY_INDEX(TF,POS) RESULT (VAL)
     CLASS(LOGICAL_VECTOR),INTENT(IN):: TF
     INTEGER,             INTENT(IN):: POS
     LOGICAL:: VAL
     !
     IF(Z < POS .AND. POS <= TF%N) THEN
         VAL=TF%VEC(POS)
     ELSE
         VAL=FALSE
     END IF
  END FUNCTION
  !    
  PURE ELEMENTAL SUBROUTINE DEALLOCATE_LOGICAL_VECTOR(TF)
     CLASS(LOGICAL_VECTOR),INTENT(INOUT):: TF
     IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
     TF%N=Z
  END SUBROUTINE
  !    
  PURE ELEMENTAL SUBROUTINE FINAL_DEALLOCATE_LOGICAL_VECTOR(TF)
     TYPE(LOGICAL_VECTOR),INTENT(INOUT):: TF
     IF(ALLOCATED(TF%VEC)) DEALLOCATE(TF%VEC)
     TF%N=Z
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! COMPRESSED_VALUE_STORAGE Routines
  !
  PURE SUBROUTINE ALLOCATE_CVS(CVS, N, NDIM, NEW_ALLOC)
    !VEC IS VECTOR TO ALLOCATE
    !N IS THE DIMENSION TO ALLOCATE. IF <1 THEN SUBROUTINE DOES NOTHING
    !EXACT IF SET TO TRUE TO INDICATE ALLOCATION MUST MATCH N  (DEFAULT)
    !      IF SET TO FALSE THEN IF ALREADY ALLOCATED AND ALLOCATION IS GREATER THAN N, THEN NOTHING IS DONE
    CLASS (COMPRESSED_VALUE_STORAGE),   INTENT(INOUT):: CVS
    INTEGER,                            INTENT(IN   ):: N
    INTEGER,                  OPTIONAL, INTENT(IN   ):: NDIM  !Default to 2
    LOGICAL,                  OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: NEW_ALLOCATION
    INTEGER:: M
    !
    NEW_ALLOCATION  = FALSE
    CVS%IS_CONSTANT = FALSE
    !
    IF    (PRESENT(NDIM)) THEN
                              M = NDIM
    ELSEIF(CVS%M  > Z   ) THEN
                              M = CVS%M
    ELSE
                              M = TWO
    END IF
    !
    IF( ALLOCATED(CVS%VAL)) THEN
                  CVS%CAP = SIZE(CVS%VAL)
    ELSE
                  CVS%CAP = Z
    END IF
    !
    IF(N > Z) THEN
                  NEW_ALLOCATION = CVS%CAP < N .OR. CVS%M /= M
                  !
                  IF(NEW_ALLOCATION) THEN
                      !
                      CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
                      !
                      CVS%CAP = N
                      CVS%N = N
                      CVS%M = M
                      ALLOCATE(CVS%DIM(M,N))
                      ALLOCATE(CVS%VAL(N))
                  END IF
    ELSEIF (CVS%M /= M) THEN
                  CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
    ELSE
                  CVS%N = Z
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_CONSTANT_CVS(CVS, VAL, NDIM)
    CLASS (COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    DOUBLE PRECISION,                 INTENT(IN   ):: VAL
    INTEGER,          OPTIONAL,       INTENT(IN   ):: NDIM  !Default to 2
    !
    IF(CVS%CAP < ONE .OR. CVS%M /= NDIM) CALL ALLOCATE_CVS(CVS, ONE, NDIM)
    CVS%IS_CONSTANT = TRUE
    CVS%N = ONE
    CVS%DIM = Z
    CVS%VAL = VAL
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_NONZERO_CVS(CVS, ARR, TOLERANCE)
    CLASS (COMPRESSED_VALUE_STORAGE),            INTENT(INOUT):: CVS
    DOUBLE PRECISION, DIMENSION(:,:),CONTIGUOUS, INTENT(IN   ):: ARR
    DOUBLE PRECISION,                  OPTIONAL, INTENT(IN   ):: TOLERANCE
    INTEGER:: I,J,K,N,DIM1,DIM2
    DOUBLE PRECISION:: TOL
    !
    CVS%IS_CONSTANT = FALSE
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    !
    IF(PRESENT(TOLERANCE)) THEN
        TOL = TOLERANCE
    ELSE
        TOL = 1.0E-30_dbl !NEARZERO_30
    END IF
    !
    N = Z
    DO J=ONE, DIM2
    DO I=ONE, DIM1
        IF (ARR(I,J) == ARR(I,J) .AND. ABS(ARR(I,J)) > TOL) N = N + ONE  ! Not NaN and Non-Zero
    END DO
    END DO
    !
    IF(N == DIM1*DIM2 .AND. N > Z) THEN  !Check if all the same values
                                   !
                                   N = Z
                                   DO J=ONE, DIM2
                                   DO I=ONE, DIM1
                                       IF (ABS(ARR(ONE,ONE)-ARR(I,J)) < TOL) N = N + ONE
                                   END DO
                                   END DO
                                   CVS%IS_CONSTANT = N == DIM1*DIM2
                                   N = DIM1*DIM2                    ! Go back to original dim in case it is not constant
    END IF
    !
    IF(CVS%IS_CONSTANT) THEN
        CALL SET_CONSTANT_CVS(CVS, ARR(ONE,ONE), TWO)
    ELSE
        IF ( N > CVS%CAP .OR. (CVS%M > Z .AND. CVS%M /= TWO)) CALL ALLOCATE_CVS(CVS, N, TWO)
        CVS%N = N
        !
        IF ( N > Z ) THEN
                     K=Z
                     DO J=ONE, DIM2
                     DO I=ONE, DIM1
                           IF( ABS(ARR(I,J)) > TOL .AND. ARR(I,J) == ARR(I,J) ) THEN
                                 K = K + ONE
                                 CVS%DIM(ONE,K) = I
                                 CVS%DIM(TWO,K) = J
                                 CVS%VAL(K)     = ARR(I,J)
                           END IF
                     END DO
                     END DO
        END IF
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_TO_ARRAY_DBL(CVS, ARR)
    CLASS (COMPRESSED_VALUE_STORAGE),     INTENT(IN   ):: CVS
    REAL(DBL), DIMENSION(:,:),CONTIGUOUS, INTENT(INOUT):: ARR
    INTEGER:: I,J,K
    !
    IF(CVS%IS_CONSTANT) THEN
        ARR = CVS%VAL(ONE)
        RETURN
    END IF
    !
    ARR = 0.0_dbl
    DO K=ONE, CVS%N
        I = CVS%DIM(ONE,K)
        J = CVS%DIM(TWO,K)
        ARR(I,J) = CVS%VAL(K)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_TO_ARRAY_SNG(CVS, ARR)
    CLASS (COMPRESSED_VALUE_STORAGE),     INTENT(IN   ):: CVS
    REAL(SNG), DIMENSION(:,:),CONTIGUOUS, INTENT(INOUT):: ARR
    INTEGER:: I,J,K
    !
    IF(CVS%IS_CONSTANT) THEN
        ARR = CVS%VAL(ONE)
        RETURN
    END IF
    !
    ARR = 0.0_sng
    DO K=ONE, CVS%N
        I = CVS%DIM(ONE,K)
        J = CVS%DIM(TWO,K)
        ARR(I,J) = REAL(CVS%VAL(K), SNG)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
    CLASS (COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    !
    CVS%CAP = Z
    CVS%N = Z
    CVS%M = Z
    IF(ALLOCATED(CVS%DIM)) DEALLOCATE(CVS%DIM)
    IF(ALLOCATED(CVS%VAL)) DEALLOCATE(CVS%VAL)
    ! 
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_VALUE_STORAGE_FINAL(CVS)
    TYPE (COMPRESSED_VALUE_STORAGE), INTENT(INOUT):: CVS
    !
    CALL DEALLCOATE_COMPRESSED_VALUE_STORAGE(CVS)
    ! 
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! COMPRESSED_LOCATION_STORAGE Routines
  ! 
  PURE SUBROUTINE ALLOCATE_LAC(LAC, N, NDIM, NEW_ALLOC)
    CLASS (COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    INTEGER,                             INTENT(IN   ):: N
    INTEGER,                   OPTIONAL, INTENT(IN   ):: NDIM  !Default to 2
    LOGICAL,                   OPTIONAL, INTENT(OUT  ):: NEW_ALLOC
    LOGICAL:: NEW_ALLOCATION
    INTEGER:: M
    !
    NEW_ALLOCATION  = FALSE
    LAC%IS_CONSTANT = FALSE
    !
    IF    (PRESENT(NDIM)) THEN
                              M = NDIM
    ELSEIF(LAC%M  > Z   ) THEN
                              M = LAC%M
    ELSE                       
                              M = TWO
    END IF
    !
    IF(N > Z) THEN
                  NEW_ALLOCATION = LAC%SIZ < N .OR. LAC%M /= M
                  !
                  IF(NEW_ALLOCATION) THEN
                      !
                      CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                      !
                      LAC%SIZ = N
                      LAC%N   = Z
                      LAC%M   = M
                      ALLOCATE(LAC%DIM(M,N))
                  END IF
    END IF
    !
    IF(PRESENT(NEW_ALLOC)) NEW_ALLOC=NEW_ALLOCATION
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_DIM2(LAC, ID, ARR)
    CLASS (COMPRESSED_LOCATION_STORAGE),         INTENT(INOUT):: LAC
    INTEGER,                                     INTENT(IN   ):: ID
    INTEGER, DIMENSION(:,:),         CONTIGUOUS, INTENT(IN   ):: ARR
    INTEGER:: I,J,K,N,DIM1,DIM2
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    !
    LAC%ID = ID
    LAC%IS_CONSTANT = FALSE
    !
    N = Z
    DO CONCURRENT (J=ONE:DIM2, I=ONE:DIM1, ARR(I,J) == ID)
       N = N + ONE
    END  DO
    !
    LAC%N = N
    !
    IF(N == DIM1*DIM2 .AND. N > Z) THEN
                                   LAC%IS_CONSTANT = TRUE
                                   LAC%N = ONE
                                   N     = ONE
                                   IF( N > LAC%SIZ .OR. LAC%M /= TWO) THEN
                                                         CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                                         ALLOCATE(LAC%DIM(TWO,N))
                                                         LAC%SIZ = N
                                   END IF
    ELSEIF (N > Z) THEN
                       IF( N > LAC%SIZ .OR. LAC%M /= TWO) THEN
                                             CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                             ALLOCATE(LAC%DIM(TWO,N))
                                             LAC%SIZ = N
                       END IF
                       !
                       K=Z
                       DO J=ONE, DIM2
                       DO I=ONE, DIM1
                             IF( ARR(I,J) == ID ) THEN
                                   K = K + ONE
                                   LAC%DIM(ONE,K) = I
                                   LAC%DIM(TWO,K) = J
                             END IF
                       END DO
                       END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_DIM3(LAC, ID, ARR)
    CLASS (COMPRESSED_LOCATION_STORAGE),         INTENT(INOUT):: LAC
    INTEGER,                                     INTENT(IN   ):: ID
    INTEGER, DIMENSION(:,:,:),       CONTIGUOUS, INTENT(IN   ):: ARR
    INTEGER:: I,J,K,N,DIM1,DIM2,DIM3
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    DIM3 = SIZE(ARR, 3)
    !
    LAC%ID = ID
    LAC%IS_CONSTANT = FALSE
    !
    N = Z
    DO CONCURRENT (K=ONE:DIM3, J=ONE:DIM2, I=ONE:DIM1, ARR(I,J,K) == ID)
       N = N + ONE
    END  DO
    !
    LAC%N = N
    IF(N == DIM1*DIM2*DIM3 .AND. N > Z) THEN
                                   LAC%IS_CONSTANT = TRUE
                                   LAC%N = ONE
                                   N     = ONE
                                   IF( N > LAC%SIZ .OR. LAC%M /= TWO) THEN
                                                         CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                                         ALLOCATE(LAC%DIM(3,N))
                                                         LAC%SIZ = N
                                   END IF
    ELSEIF (N > Z) THEN
                       IF( N > LAC%SIZ .OR. LAC%M /= 3) THEN
                                             CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
                                             ALLOCATE(LAC%DIM(3,N))
                                             LAC%SIZ = N
                       END IF
                       !
                       N=Z
                       DO K=ONE, DIM3
                       DO J=ONE, DIM2
                       DO I=ONE, DIM1
                             IF( ARR(I,J,K) == ID ) THEN
                                   N = N + ONE
                                   LAC%DIM(ONE,N) = I                   
                                   LAC%DIM(TWO,N) = J                 
                                   LAC%DIM(  3,N) = K
                             END IF
                       END DO
                       END DO
                       END DO
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE BUILD_COMPRESSED_LOCATION_STORAGE_ALOC(LAC, ARR, HAS_ZERO, ID)
    TYPE(COMPRESSED_LOCATION_STORAGE),DIMENSION(:),ALLOCATABLE, INTENT(INOUT):: LAC
    INTEGER, DIMENSION(:,:),                        CONTIGUOUS, INTENT(IN   ):: ARR
    LOGICAL,                                          OPTIONAL, INTENT(IN   ):: HAS_ZERO
    INTEGER, DIMENSION(:),ALLOCATABLE,                OPTIONAL, INTENT(INOUT):: ID
    INTEGER:: I,J,K,N,DIM1,DIM2,SIZ
    INTEGER, DIMENSION(:), ALLOCATABLE:: TMP1, TMP2
    LOGICAL:: DO_Z
    !
    DIM1 = SIZE(ARR, ONE)
    DIM2 = SIZE(ARR, TWO)
    !
    IF(PRESENT(HAS_ZERO)) THEN
        DO_Z = HAS_ZERO
    ELSE
        DO_Z = FALSE
    END IF
    !
    ALLOCATE(TMP1(64), SOURCE=Z)
    SIZ = 64
    N   = Z
    !
    IF(DO_Z) THEN
       DO J=ONE,DIM2
       DO I=ONE,DIM1
           IF( N==Z ) THEN
                                               N = N + ONE
                                               TMP1(ONE) = ARR(I,J)
           ELSEIF( ALL(ARR(I,J) /= TMP1(:N)) ) THEN
               !
               N = N + ONE
               IF(N > SIZ) THEN
                   ALLOCATE(TMP2(N+63))
                   TMP2(:SIZ) = TMP1
                   CALL MOVE_ALLOC(TMP2, TMP1)
                   SIZ = N+50
               END IF
               !
               TMP1(N) = ARR(I,J)
           END IF
       END DO
       END DO
    ELSE
       DO J=ONE,DIM2
       DO I=ONE,DIM1
         IF(ARR(I,J) /= Z) THEN
           IF( N==Z ) THEN
                                               N = N + ONE
                                               TMP1(ONE) = ARR(I,J)
           ELSEIF( ALL(ARR(I,J) /= TMP1(:N)) ) THEN
               !
               N = N + ONE
               IF(N > SIZ) THEN
                   ALLOCATE(TMP2(N+63))
                   TMP2(:SIZ) = TMP1
                   CALL MOVE_ALLOC(TMP2, TMP1)
                   SIZ = N+50
               END IF
               !
               TMP1(N) = ARR(I,J)
           END IF
         END IF
       END DO
       END DO
    END IF
    !
    ! SORT VALUES
    !
    DO I=2, N
        K=TMP1(I)
        J=I
        DO WHILE ( J > ONE )
                           IF (TMP1(J-ONE) < K) EXIT
                           TMP1(J) = TMP1(J-ONE)
                           J=J-ONE
        END DO
        TMP1(J) = K
    END DO
    !
    IF(ALLOCATED(LAC)) THEN
        IF(SIZE(LAC) /= N) THEN
            DEALLOCATE(LAC)
              ALLOCATE(LAC(N))
        END IF
    ELSE
        ALLOCATE(LAC(N))
    END IF
    !
    DO CONCURRENT(I=ONE:N)
        CALL BUILD_COMPRESSED_LOCATION_STORAGE_DIM2(LAC(I), TMP1(I), ARR)
    END DO
    !
    IF(PRESENT(ID)) THEN
        IF(ALLOCATED(ID)) THEN
          IF(SIZE(ID) /= N) THEN
              DEALLOCATE(ID)
                ALLOCATE(ID(N))
          END IF
        ELSE
            ALLOCATE(ID(N))
        END IF
        !
        ID = TMP1(:N)
    END IF
    !
  END SUBROUTINE
  ! 
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
    CLASS (COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    !
    LAC%ID  = Z
    LAC%N   = Z
    LAC%M   = Z
    LAC%SIZ = Z
    !
    LAC%IS_CONSTANT = FALSE
    !
    IF(ALLOCATED(LAC%DIM) ) DEALLOCATE(LAC%DIM)
    ! 
  END SUBROUTINE
  !
  PURE SUBROUTINE DEALLCOATE_COMPRESSED_LOCATION_STORAGE_FINAL(LAC)
    TYPE (COMPRESSED_LOCATION_STORAGE), INTENT(INOUT):: LAC
    !
    CALL DEALLCOATE_COMPRESSED_LOCATION_STORAGE(LAC)
    ! 
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! ID1_ID2_RAT_VOL_TYPE Routines
  ! 
  PURE SUBROUTINE ALLOC_ID1_ID2_RAT_VOL_TYPE(TYP, DIM)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT):: TYP
    INTEGER,            INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
  END SUBROUTINE
  !
  !
  PURE SUBROUTINE EXTEND_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, RAT, VOL)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                           INTENT(IN   ):: ID1, ID2
    DOUBLE PRECISION,                  INTENT(IN   ):: RAT, VOL
    TYPE (ID1_ID2_RAT_VOL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%ID1 = ID1;   TYP%PT(TYP%N)%ID2 = ID2
                  TYP%PT(TYP%N)%RAT = RAT;   TYP%PT(TYP%N)%VOL  = VOL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%ID1 = ID1;   EXT%PT(EXT%N)%ID2 = ID2
                  EXT%PT(EXT%N)%RAT = RAT;   EXT%PT(EXT%N)%VOL  = VOL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_RAT_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, RAT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                       INTENT(IN   ):: ID1, ID2
    DOUBLE PRECISION,              INTENT(IN   ):: RAT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            TYP%PT(I)%RAT = RAT
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, VOL)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                       INTENT(IN   ):: ID1, ID2
    DOUBLE PRECISION,              INTENT(IN   ):: VOL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            TYP%PT(I)%VOL = VOL
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_ID1_ID2_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,              INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%RAT = TYP%PT(I)%VOL / DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_ID1_ID2_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,              INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%VOL = TYP%PT(I)%RAT * DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, EVAL) RESULT(RAT)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(IN):: TYP
    INTEGER,                     INTENT(IN):: ID1, ID2
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN):: EVAL
    DOUBLE PRECISION:: RAT
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        RAT = EVAL
    ELSE
        RAT = IEEE_VALUE(RAT, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            RAT = TYP%PT(I)%RAT
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_ID1_ID2_RAT_VOL_TYPE(TYP, ID1, ID2, EVAL) RESULT(VOL)
    CLASS(ID1_ID2_RAT_VOL_TYPE), INTENT(IN):: TYP
    INTEGER,                     INTENT(IN):: ID1, ID2
    DOUBLE PRECISION, OPTIONAL,  INTENT(IN):: EVAL
    DOUBLE PRECISION:: VOL
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        VOL = EVAL
    ELSE
        VOL = IEEE_VALUE(VOL, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID1 == TYP%PT(I)%ID1 .AND. ID2 == TYP%PT(I)%ID2) THEN
            VOL = TYP%PT(I)%VOL
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! ID_RAT_VOL_TYPE
  ! 
  PURE SUBROUTINE ALLOC_ID_RAT_VOL_TYPE(TYP, DIM)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_RAT_VOL_TYPE_INIT_SCA(TYP, DIM, INIT)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    DOUBLE PRECISION,           INTENT(IN   ):: INIT !If present then make ID sequential and set VAL to INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%RAT = INIT
        TYP%PT(I)%VOL = INIT
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_RAT_VOL_TYPE_INIT_VEC(TYP, DIM, INIT)
    CLASS(ID_RAT_VOL_TYPE),          INTENT(INOUT):: TYP
    INTEGER,                         INTENT(IN   ):: DIM
    DOUBLE PRECISION,DIMENSION(DIM), INTENT(IN   ):: INIT !If present then make ID sequential and set VAL to INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%RAT = INIT(I)
        TYP%PT(I)%VOL = INIT(I)
    END DO
  END SUBROUTINE
  !
  SUBROUTINE EXTEND_ID_RAT_VOL_TYPE(TYP, ID, RAT, VOL)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                           INTENT(IN   ):: ID
    DOUBLE PRECISION,                  INTENT(IN   ):: RAT, VOL
    TYPE (ID_RAT_VOL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%ID = ID;   TYP%PT(TYP%N)%RAT = RAT;   TYP%PT(TYP%N)%VOL = VOL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%ID = ID;   EXT%PT(EXT%N)%RAT = RAT;   EXT%PT(EXT%N)%VOL = VOL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_RAT_ID_RAT_VOL_TYPE(TYP, ID, RAT)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                 INTENT(IN   ):: ID
    DOUBLE PRECISION,        INTENT(IN   ):: RAT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            TYP%PT(I)%RAT = RAT
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_ID_RAT_VOL_TYPE(TYP, ID, VOL)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    INTEGER,                 INTENT(IN   ):: ID
    DOUBLE PRECISION,        INTENT(IN   ):: VOL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            TYP%PT(I)%VOL = VOL
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_ID_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%RAT =  TYP%PT(I)%VOL / DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_ID_RAT_VOL_TYPE(TYP, DELT)
    CLASS(ID_RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%VOL = TYP%PT(I)%RAT * DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_ID_RAT_VOL_TYPE(TYP, ID, EVAL) RESULT(RAT)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: ID
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: RAT
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        RAT = EVAL
    ELSE
        RAT = IEEE_VALUE(RAT, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            RAT = TYP%PT(I)%RAT
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_ID_RAT_VOL_TYPE(TYP, ID, EVAL) RESULT(VOL)
    CLASS(ID_RAT_VOL_TYPE),     INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: ID
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: VOL
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        VOL = EVAL
    ELSE
        VOL = IEEE_VALUE(VOL, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            VOL = TYP%PT(I)%VOL
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! ID_VAL_TYPE
  ! 
  PURE SUBROUTINE ALLOC_ID_VAL_TYPE(TYP, DIM)
    CLASS(ID_VAL_TYPE),         INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_VAL_TYPE_INIT_SCA(TYP, DIM, INIT)
    CLASS(ID_VAL_TYPE),         INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    DOUBLE PRECISION,           INTENT(IN   ):: INIT !If present then make ID sequential and set VAL to INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_VAL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%VAL = INIT
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_ID_VAL_TYPE_INIT_VEC(TYP, DIM, INIT)
    CLASS(ID_VAL_TYPE),               INTENT(INOUT):: TYP
    INTEGER,                          INTENT(IN   ):: DIM
    DOUBLE PRECISION, DIMENSION(DIM), INTENT(IN   ):: INIT
    INTEGER:: I
    !
    CALL ALLOC_ID_VAL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%ID  = I
        TYP%PT(I)%VAL = INIT(I)
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
    CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
    INTEGER,            INTENT(IN   ):: ID
    DOUBLE PRECISION,   INTENT(IN   ):: VAL
    TYPE (ID_VAL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%ID = ID;   TYP%PT(TYP%N)%VAL = VAL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%ID = ID;   EXT%PT(EXT%N)%VAL = VAL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VAL_ID_VAL_TYPE(TYP, ID, VAL)
    CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
    INTEGER,            INTENT(IN   ):: ID
    DOUBLE PRECISION,   INTENT(IN   ):: VAL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            TYP%PT(I)%VAL = VAL
            EXIT
        END IF
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_VAL_ID_VAL_TYPE(TYP, ID, EVAL) RESULT(VAL)
    CLASS(ID_VAL_TYPE),         INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: ID
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: VAL
    INTEGER:: I
    !
    IF(PRESENT(EVAL)) THEN
        VAL = EVAL
    ELSE
        VAL = IEEE_VALUE(VAL, IEEE_QUIET_NAN)
    END IF
    !
    DO I=ONE, TYP%N
        IF(ID == TYP%PT(I)%ID) THEN
            VAL = TYP%PT(I)%VAL
            EXIT
        END IF
    END DO
    !
  END FUNCTION
  !
  PURE SUBROUTINE SET_ID_VAL_TYPE_ALL(TYP, ID, VAL)
    CLASS(ID_VAL_TYPE),                 INTENT(INOUT)::TYP
    INTEGER,          DIMENSION(TYP%N), INTENT(IN   ):: ID
    DOUBLE PRECISION, DIMENSION(TYP%N), INTENT(IN   ):: VAL
    INTEGER:: I
    !
    DO I=ONE, TYP%N
            TYP%PT(I)%ID  = ID(I)
            TYP%PT(I)%VAL = VAL(I)
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_ID_VAL_TYPE_POS(TYP, POS, ID, VAL, INUL, NUL)
    CLASS(ID_VAL_TYPE), INTENT(INOUT)::TYP
    INTEGER,            INTENT(IN   ):: POS, ID
    DOUBLE PRECISION,   INTENT(IN   ):: VAL
    INTEGER,           OPTIONAL, INTENT(IN   ):: INUL
    DOUBLE PRECISION,  OPTIONAL, INTENT(IN   ):: NUL
    INTEGER:: I
    !
    IF( Z < POS .AND. POS <= TYP%N) THEN
        TYP%PT(POS)%ID  = ID
        TYP%PT(POS)%VAL = VAL
    ELSEIF(TYP%N < POS) THEN
        IF(.NOT. PRESENT(INUL) .AND. .NOT. PRESENT(NUL)) THEN
            DO I= TYP%N+ONE, POS
                             CALL EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
            END DO
        ELSEIF(PRESENT(INUL) .AND. PRESENT(NUL)) THEN
            DO I= TYP%N+ONE, POS - 1
                             CALL EXTEND_ID_VAL_TYPE(TYP, INUL, NUL)
            END DO
            CALL EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
        ELSEIF(PRESENT(NUL)) THEN
            DO I= TYP%N+ONE, POS - 1
                             CALL EXTEND_ID_VAL_TYPE(TYP, I, NUL)
            END DO
            CALL EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
        ELSE
            DO I= TYP%N+ONE, POS - 1
                             CALL EXTEND_ID_VAL_TYPE(TYP, INUL, VAL)
            END DO
            CALL EXTEND_ID_VAL_TYPE(TYP, ID, VAL)
        END IF
    END IF
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! RAT_VOL_TYPE
  ! 
  PURE SUBROUTINE ALLOC_RAT_VOL_TYPE(TYP, DIM)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                 INTENT(IN   ):: DIM
    !
    IF(ALLOCATED(TYP%PT)) DEALLOCATE(TYP%PT)
    !
    IF(DIM > Z) THEN
                  ALLOCATE(TYP%PT(DIM))
                  TYP%N = DIM
                  TYP%INUSE = TRUE
    ELSE
                  TYP%N     = Z
                  TYP%INUSE = FALSE
    END IF
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_RAT_VOL_TYPE_INIT_SCA(TYP, DIM, INIT)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                    INTENT(IN   ):: DIM
    DOUBLE PRECISION,           INTENT(IN   ):: INIT
    INTEGER:: I
    !
    CALL ALLOC_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%RAT = INIT
        TYP%PT(I)%VOL = INIT
    END DO
  END SUBROUTINE
  !
  PURE SUBROUTINE ALLOC_RAT_VOL_TYPE_INIT_VEC(TYP, DIM, INIT)
    CLASS(RAT_VOL_TYPE),          INTENT(INOUT):: TYP
    INTEGER,                         INTENT(IN   ):: DIM
    DOUBLE PRECISION,DIMENSION(DIM), INTENT(IN   ):: INIT 
    INTEGER:: I
    !
    CALL ALLOC_RAT_VOL_TYPE(TYP, DIM)
    !
    DO I=ONE, DIM
        TYP%PT(I)%RAT = INIT(I)
        TYP%PT(I)%VOL = INIT(I)
    END DO
  END SUBROUTINE
  !
  SUBROUTINE EXTEND_RAT_VOL_TYPE(TYP, RAT, VOL)
    CLASS(RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: RAT, VOL
    TYPE (RAT_VOL_TYPE):: EXT
    !
    TYP%INUSE = TRUE
    !
    IF(TYP%N == Z) THEN
                  TYP%N = ONE
                  !
                  ALLOCATE( TYP%PT(TYP%N) )
                  TYP%PT(TYP%N)%RAT = RAT;   TYP%PT(TYP%N)%VOL = VOL
    ELSE
                  EXT%N = TYP%N + ONE
                  !
                  ALLOCATE( EXT%PT (EXT%N) )
                  EXT%PT(:TYP%N)  = TYP%PT
                  !
                  EXT%PT(EXT%N)%RAT = RAT;   EXT%PT(EXT%N)%VOL = VOL
                  !
                  CALL MOVE_ALLOC(EXT%PT,  TYP%PT)
                  TYP%N = EXT%N
    END IF
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_RAT_POS_RAT_VOL_TYPE(TYP, POS, RAT)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                 INTENT(IN   ):: POS
    DOUBLE PRECISION,        INTENT(IN   ):: RAT
    !
    IF(Z<POS .AND. POS <= TYP%N) TYP%PT(POS)%RAT = RAT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_POS_RAT_VOL_TYPE(TYP, POS, VOL)
    CLASS(RAT_VOL_TYPE),     INTENT(INOUT):: TYP
    INTEGER,                 INTENT(IN   ):: POS
    DOUBLE PRECISION,        INTENT(IN   ):: VOL
    !
    IF(Z<POS .AND. POS <= TYP%N) TYP%PT(POS)%VOL = VOL
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_RAT_VOL_TYPE(TYP, DELT)
    CLASS(RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%RAT =  TYP%PT(I)%VOL / DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_RAT_VOL_TYPE(TYP, DELT)
    CLASS(RAT_VOL_TYPE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    INTEGER:: I
    !
    DO I=ONE, TYP%N
              TYP%PT(I)%VOL = TYP%PT(I)%RAT * DELT
    END DO
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_POS_RAT_VOL_TYPE(TYP, POS, EVAL) RESULT(RAT)
    CLASS(RAT_VOL_TYPE),        INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: POS
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: RAT
    !
    IF(Z<POS .AND. POS <= TYP%N) THEN
                                      RAT = TYP%PT(POS)%RAT
    ELSEIF(PRESENT(EVAL)) THEN
                                      RAT = EVAL
    ELSE
                                      RAT = IEEE_VALUE(RAT, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_POS_RAT_VOL_TYPE(TYP, POS, EVAL) RESULT(VOL)
    CLASS(RAT_VOL_TYPE),     INTENT(IN):: TYP
    INTEGER,                    INTENT(IN):: POS
    DOUBLE PRECISION, OPTIONAL, INTENT(IN):: EVAL
    DOUBLE PRECISION:: VOL
    !
    IF(Z<POS .AND. POS <= TYP%N) THEN
                                      VOL = TYP%PT(POS)%VOL
    ELSEIF(PRESENT(EVAL)) THEN
                                      VOL = EVAL
    ELSE
                                      VOL = IEEE_VALUE(VOL, IEEE_QUIET_NAN)
    END IF
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  ! RAT_VOL_BASE Routines
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_RAT_VOL_BASE(OTYP, ITYP)
    CLASS(RAT_VOL_BASE), INTENT(IN   ):: ITYP
    CLASS(RAT_VOL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%RAT = ITYP%RAT
    OTYP%VOL = ITYP%VOL
    !
  END SUBROUTINE
  !
  PURE ELEMENTAL SUBROUTINE SET_RAT_RAT_VOL_BASE(TYP, RAT)
    CLASS(RAT_VOL_BASE),     INTENT(INOUT):: TYP
    DOUBLE PRECISION,        INTENT(IN   ):: RAT
    !
    TYP%RAT = RAT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE SET_VOL_RAT_VOL_BASE(TYP, VOL)
    CLASS(RAT_VOL_BASE),     INTENT(INOUT):: TYP
    DOUBLE PRECISION,        INTENT(IN   ):: VOL
    !
    TYP%VOL = VOL
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_RAT_RAT_VOL_BASE(TYP, DELT)
    CLASS(RAT_VOL_BASE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,       INTENT(IN   ):: DELT
    !
    TYP%RAT =  TYP%VOL / DELT
    !
  END SUBROUTINE
  !
  PURE SUBROUTINE CALC_VOL_RAT_VOL_BASE(TYP, DELT)
    CLASS(RAT_VOL_BASE), INTENT(INOUT)::TYP
    DOUBLE PRECISION,    INTENT(IN   ):: DELT
    !
    TYP%VOL = TYP%RAT * DELT
    !
  END SUBROUTINE
  !
  PURE FUNCTION GET_RAT_RAT_VOL_BASE(TYP) RESULT(RAT)
    CLASS(RAT_VOL_BASE), INTENT(IN):: TYP
    DOUBLE PRECISION:: RAT
    !
    RAT = TYP%RAT
    !
  END FUNCTION
  !
  PURE FUNCTION GET_VOL_RAT_VOL_BASE(TYP) RESULT(VOL)
    CLASS(RAT_VOL_BASE), INTENT(IN):: TYP
    DOUBLE PRECISION:: VOL
    !
    VOL = TYP%VOL
    !
  END FUNCTION
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_ID1_ID2_RAT_VOL_BASE(OTYP, ITYP)
    CLASS(ID1_ID2_RAT_VOL_BASE), INTENT(IN   ):: ITYP
    CLASS(ID1_ID2_RAT_VOL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%ID1 = ITYP%ID1
    OTYP%ID2 = ITYP%ID2
    OTYP%RAT  = ITYP%RAT
    OTYP%VOL  = ITYP%VOL
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_ID_RAT_VOL_BASE(OTYP, ITYP)
    CLASS(ID_RAT_VOL_BASE), INTENT(IN   ):: ITYP
    CLASS(ID_RAT_VOL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%ID = ITYP%ID
    OTYP%RAT = ITYP%RAT
    OTYP%VOL = ITYP%VOL
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE ELEMENTAL SUBROUTINE COPY_ID_VAL_BASE(OTYP, ITYP)
    CLASS(ID_VAL_BASE), INTENT(IN   ):: ITYP
    CLASS(ID_VAL_BASE), INTENT(INOUT):: OTYP
    !
    OTYP%ID  = ITYP%ID
    OTYP%VAL = ITYP%VAL
    !
  END SUBROUTINE
  !
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  ! 
  PURE SUBROUTINE UPPER(LN)
    CHARACTER(*), INTENT(INOUT):: LN
    INTEGER:: I, N
    !
    DO I=1, LEN(LN)
        N = INDEX( lowerCHAR, LN(I:I))
        !
        IF(N > 0) LN(I:I) = upperCHAR(N:N)
    END DO
  END SUBROUTINE
  !
END MODULE
